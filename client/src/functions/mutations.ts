import { ErrorModel } from "@/api"
import { joinPath, PathPrefix, Schema, useSchema } from "@/composables/schema"
import { useMutation, UseMutationOptions } from "@tanstack/vue-query"
import { reactiveComputed } from "@vueuse/core"
import { StatusCodes } from "http-status-codes"
import { Equal } from "node_modules/@tanstack/vue-query/build/modern/types"
import { Optional } from "ts-toolbelt/out/Object/Optional"
import { computed, ModelRef, ref, watch } from "vue"

export type Mode = 'Create' | 'Edit'

export type FormProps = {
  mode?: Mode
  errors?: IndexedValidationErrors
}

/**
 * Extracts required keys from a request data type.
 * Applies recursively to nested objects, except for the 'body' key.
 */
type PickRequired<T> = { [K in keyof T as (T[K] extends never ? never : (undefined extends T[K] ? never : K))]: 'body' extends K ? T[K] : PickRequired<T[K]> }

export type FormEmits<ItemType> = {
  (evt: 'success', item: ItemType): void
  (evt: 'created', item: ItemType): void
  (evt: 'updated', item: ItemType): void
}

/**
 * Simplified request data model for mutations
 */
export interface RequestData<Input> {
  body: Input
}

/**
 * Defines a mutation for creating a new item,
 * to be used with the [CreateUpdateForm]({@link ../components/toolkit/forms/CreateUpdateForm.vue }) component.
 */
export type FormCreateMutation<
  Item,
  ItemInput,
  InputModel = ItemInput,
  InputSchema extends Schema = Schema,
  RData extends RequestData<ItemInput> = RequestData<ItemInput>
> = {
  mutation: UseMutationOptions<Item, ErrorModel, RData, any>
  schema: InputSchema,
  initial: () => InputModel,
  requestData: (model: InputModel) => RData
}

/**
 * Defines a mutation for updating an existing item,
 * to be used with the [CreateUpdateForm]({@link ../components/toolkit/forms/CreateUpdateForm.vue }) component.
 */
export type FormUpdateMutation<
  Item,
  ItemUpdate,
  UpdateModel,
  UpdateSchema extends Schema,
  ItemID,
  RData extends RequestData<ItemUpdate> & { path: ItemID }
> = {
  mutation: UseMutationOptions<
    Item,
    ErrorModel,
    RData,
    any
  >
  schema: UpdateSchema
  itemToModel(item: Item): UpdateModel
  requestData: (item: Item, model: UpdateModel) => RData
}

/**
 * Defines a mutation for creating a new item, to be used with the [CreateUpdateForm]({@link ../components/toolkit/forms/CreateUpdateForm.vue }) component.
 * This provides a declarative way to specify how to handle item creation in the UI, including:
 * - form validation using the OpenAPI schema,
 * - specifying a custom model for the form
 * - transforming form data model to request body if necessary
 * @param mutation - Vue Query mutation options for creating an item, as generated by HeyAPI OpenAPI TS
 * @param opts - Form model and request data configuration
 * @returns Form mutation configuration to be used with the [CreateUpdateForm]({@link ../components/toolkit/forms/CreateUpdateForm.vue }) component
 */
export function defineFormCreate<
  Item extends {},
  ItemInput extends {},
  S extends Schema,
  RData extends RequestData<ItemInput>,
  InputModel extends {} = ItemInput,
>(mutation: UseMutationOptions<Item, ErrorModel, RData & RequestData<ItemInput>, any>,
  opts: {
    /**
     * Initial form model, which is used to populate the form with default values.
     * It may differ from the request data model,
     * in which case a transformation must be applied in `requestData`.
     */
    initial: () => InputModel,
    /**
     * OpenAPI JSON schema for input model.
     * Used for form validation and fields configuration
     */
    schema: S,
  } &
    (
      Equal<PickRequired<Omit<RData, 'url'>>, { body: InputModel }> extends true
      ? {
        /**
         * Form model matches request data model and request does not require additional parameters:
         * a transformer can optionally be provided to modify the request data.
         * If not provided, the input model is sent in the request body as is.
         */
        requestData?: (model: InputModel) => RData
      }
      : {
        /**
         * Form model differs from request data model or request expects additional parameters:
         * a transformer must be provided to create the request data from the input model.
         */
        requestData: (model: InputModel) => RData
      }
    )
): FormCreateMutation<Item, ItemInput, InputModel, S, RData> {
  return {
    mutation,
    ...opts,
    requestData: (
      opts.requestData ?? ((model: InputModel) => ({
        // `model` has the same shape as `ItemInput`
        // since requestData was allowed to be omitted
        body: model as unknown as ItemInput
      }) as RData)
    )
  }
}

/**
 * Defines a mutation for updating an existing item, to be used with the [CreateUpdateForm]({@link ../components/toolkit/forms/CreateUpdateForm.vue }) component.
 * This provides a declarative way to specify how to handle item updates in the UI, including:
 * - form validation using the OpenAPI schema,
 * - generating a form model from an existing item,
 * - specifying the path to the item in the API request
 * - transforming form data model to request data if necessary
 * @param mutation - Vue Query mutation options for updating an item, as generated by HeyAPI OpenAPI TS
 * @param opts - Form model and request data configuration
 * @returns Form mutation configuration to be used with the [CreateUpdateForm]({@link ../components/toolkit/forms/CreateUpdateForm.vue }) component
 */
export function defineFormUpdate<
  Item extends {},
  ItemUpdate extends {},
  S extends Schema,
  RData extends RequestData<ItemUpdate> & { path: ItemID },
  UpdateModel extends {} = ItemUpdate,
  ItemID = any,
>(mutation: UseMutationOptions<Item, ErrorModel, RData & RequestData<ItemUpdate> & { path: ItemID }, any>,
  opts: {
    schema: S,
    /**
     * Generate form model from existing item.
     * This is used to populate the form with the item's current values.
     * If the form model does not match the request data model, a body transformation must be applied in `requestData`.
     */
    itemToModel(item: Item): UpdateModel,
  } & ({
    /**
     * Generate request data from item and update model.
     * If the form model exactly matches the request data model,
     * `body` key can be omitted and the form model is added to the request body as is,
     *  e.g. when `initToModel` generates a model of the same shape as `ItemUpdate`.
     */
    requestData(item: Item, model: UpdateModel):
      Equal<UpdateModel, ItemUpdate> extends true ? Optional<RData, 'body'> : RData
  })
): FormUpdateMutation<Item, ItemUpdate, UpdateModel, S, ItemID, RData> {
  return {
    mutation,
    ...opts,
    requestData: (item: Item, model: UpdateModel) => {
      const data = opts.requestData(item, model)
      return {
        ...data,
        body: data.body ?? model
      } as RData
    }
  }
}

/**
 * Represents errors returned by the API, indexed by their location.
 * The `rest` key is used for errors that are not related to a specific field.
 */
export type IndexedValidationErrors = Record<'rest' | (string & {}), string[]>

export function useMutationForm<
  Item,
  ItemInput,
  ItemUpdate,
  ItemID,
  InputSchema extends Schema,
  UpdateSchema extends Schema,
  InputRequestData extends RequestData<ItemInput>,
  UpdateRequestData extends RequestData<ItemUpdate> & { path: ItemID },
  InputModel = ItemInput,
  UpdateModel = ItemUpdate
>(
  item: ModelRef<Item | undefined>,
  { create, update, onSuccess }: {
    create: FormCreateMutation<Item, ItemInput, InputModel, InputSchema, InputRequestData>,
    update: FormUpdateMutation<Item, ItemUpdate, UpdateModel, UpdateSchema, ItemID, UpdateRequestData>,
    onSuccess?: (item: Item, mode: Mode) => any
  }
) {

  const model = ref<InputModel | UpdateModel>(initModel(item.value))
  watch(item, (item) => (model.value = initModel(item)), { immediate: true })

  function initModel(item?: Item) {
    return item ? update.itemToModel(item) : create.initial()
  }

  const mode = computed<Mode>(() => (item.value ? 'Edit' : 'Create'))

  // Schema bindings
  const schemaBindings = reactiveComputed(() =>
    useSchema(mode.value === 'Create' ? create.schema : update.schema)
  )

  const createMutation = useMutation({
    ...create.mutation,
    onSuccess(data) {
      onSuccess?.(data, 'Create')
      reset()
    },
    onError
  })
  const updateMutation = useMutation({
    ...update.mutation,
    onSuccess(data) {
      onSuccess?.(data, 'Edit')
      reset()
    },
    onError
  })

  const activeMutation = computed(() => (mode.value === 'Create' ? createMutation : updateMutation))

  async function submit() {
    if (mode.value === 'Create')
      return await createMutation.mutateAsync(create.requestData(model.value))
    else {
      return await updateMutation.mutateAsync(update.requestData(item.value!, model.value))
    }
  }

  function reset() {
    initModel(item.value)
  }

  function onError(err: ErrorModel) {
    if (err.status && err.status !== StatusCodes.UNPROCESSABLE_ENTITY) {
      schemaBindings.dispatchErrors(err)
    }
  }

  const errors = computed(() => {
    return activeMutation.value.error.value?.errors?.reduce<IndexedValidationErrors>((acc, error) => {
      if (error.location && error.location.startsWith('body.')) {
        const loc = error.location.replace('body.', '')
        acc[loc] = (acc[loc] ?? []).concat(error.message ?? 'Invalid value')
      } else {
        acc['rest'].push(error.message ?? 'Invalid value')
      }
      return acc
    }, { rest: [] })
  })

  function errorsWithPrefix(prefix: PathPrefix<typeof create.schema>) {
    const pref = joinPath<typeof create.schema>(prefix)
    return computed(() => {
      return Object.entries(errors.value ?? {}).reduce((acc, [key, value]) => {
        if (key.startsWith(pref)) {
          const newKey = key.replace(pref, '')
          acc[newKey] = value
        }
        return acc
      },
        {} as IndexedValidationErrors)
    })
  }

  return {
    model, mode,
    schemaBindings,
    activeMutation,
    submit,
    reset,
    errors,
  }
}