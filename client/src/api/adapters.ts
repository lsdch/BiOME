// NOT generated by openapi-ts

import { DateTime } from "luxon"
import {
  OccurrenceCategory as TOccurrenceCategory,
  CompositeDate as CompositeDateType,
  DatePrecision,
  DateWithPrecisionInput,
  DateWithPrecision as DateWithPrecisionType,
  Article as TArticle,
  ExtSeqOrigin as TExtSeqOrigin,
  SeqReference as TSeqReference,
  InstitutionKind as TInstitutionKind,
  Taxon as TTaxon,
  TaxonRank as TTaxonRank
} from "./gen/types.gen"
import { $TaxonRank } from "./gen/schemas.gen"

export * from "./gen/types.gen"

export type CompositeDate = CompositeDateType
export namespace CompositeDate {
  export function fromDateWithPrecision({ precision, date }: DateWithPrecision): CompositeDate {
    if (precision === 'Unknown' || !date) return {}
    switch (precision) {
      case 'Year':
        return { year: date.getFullYear() }
      case 'Month':
        // JS months start at 0, because ✨ JS ✨
        return { month: date.getMonth() + 1, year: date.getFullYear() }
      case 'Day':
        return { day: date.getDate(), month: date.getMonth() + 1, year: date?.getFullYear() }
    }
  }
}


export type DateWithPrecision = DateWithPrecisionType
export namespace DateWithPrecision {
  const formats: Record<DatePrecision, string> = {
    Day: 'dd LLL yyyy',
    Month: 'LLL yyyy',
    Year: 'yyyy',
    Unknown: "'Unknown'"
  }
  export function compare(a: DateWithPrecision, b: DateWithPrecision) {
    return (DateWithPrecision.toDateTime(b) ?? 0) > (DateWithPrecision.toDateTime(a) ?? 0)
      ? -1
      : 1
  }

  export function toInput({ date, precision }: DateWithPrecision): DateWithPrecisionInput {
    return { date: CompositeDate.fromDateWithPrecision({ date, precision }), precision }
  }
  export function toDateTime({ date, precision }: DateWithPrecision): DateTime | null {
    if (precision === 'Unknown' || !date) return null
    return DateTime.fromJSDate(date)
  }

  export function format({ date, precision }: DateWithPrecision, format?: string) {
    if (precision === 'Unknown' || !date) return "Unknown"
    return DateTime.fromJSDate(date)
      .setLocale('en-gb')
      .toFormat(format ?? formats[precision])
  }
}

export type OccurrenceCategory = TOccurrenceCategory
export namespace OccurrenceCategory {

  export const props: Record<OccurrenceCategory, { icon: string, color: string, prependIcon: string }> = {
    Internal: {
      icon: 'mdi-cube-scan',
      prependIcon: 'mdi-cube-scan',
      color: 'primary'
    },
    External: {
      icon: 'mdi-arrow-collapse-all',
      prependIcon: 'mdi-arrow-collapse-all',
      color: 'warning'
    }
  }

  export function icon(t: OccurrenceCategory) {
    return props[t].icon
  }
}

export type Article = TArticle
export namespace Article {
  export function shortAuthors(authors: string[]): string {
    return authors.length == 1 ? authors[0] : authors.length == 2 ? authors.join(' & ') : `${authors[0]} et. al`
  }
  export function toString({ authors, year }: Article) {
    return `${shortAuthors(authors)} ${year}`
  }

  export function linkDOI({ doi }: Article) {
    return `https://doi.org/${doi}`
  }
}


export type ExtSeqOrigin = TExtSeqOrigin
export namespace ExtSeqOrigin {
  export const props: Record<ExtSeqOrigin, { icon: string, description: string }> = {
    Lab: { icon: 'mdi-test-tube', description: 'Sequence was produced in the lab, but registered as external due to missing informations' },
    DB: { icon: 'mdi-database-arrow-down', description: 'Sequence was imported from external database' },
    PersCom: { icon: 'mdi-email', description: 'Sequence was provided as personal communication' }
  }

  export function icon(origin: ExtSeqOrigin) {
    return props[origin].icon
  }

  export function description(origin: ExtSeqOrigin) {
    return props[origin].description
  }
}

export type SeqReference = TSeqReference
export namespace SeqReference {
  export function link({ accession, db }: SeqReference) {
    return db.link_template?.replace("{accession}", accession)
  }
}

export type InstitutionKind = TInstitutionKind
export namespace InstitutionKind {
  export const props: Record<InstitutionKind, { icon: string, color: string }> = {
    Lab: { icon: 'mdi-flask', color: 'primary' },
    FundingAgency: { icon: 'mdi-file-certificate', color: 'green' },
    SequencingPlatform: { icon: 'mdi-dna', color: 'orange' },
    Other: { icon: 'mdi-home-modern', color: 'grey' }
  }
  export function icon(kind: InstitutionKind) {
    return props[kind].icon
  }
  export function color(kind: InstitutionKind) {
    return props[kind].color
  }
  export function humanize(kind: InstitutionKind) {
    return kind.replace(/([a-z])([A-Z])/g, '$1 $2').trim()
  }
}

export type TaxonRank = TTaxonRank
export namespace TaxonRank {
  const taxonRankOrder = Object.fromEntries($TaxonRank.enum.map((rank, i) => [rank, i])) as { [k in TaxonRank]: number }

  export function index(rank: TaxonRank) {
    return taxonRankOrder[rank]
  }

  export function isDescendant(rank: TaxonRank, from: TaxonRank) {
    return index(rank) > index(from)
  }

  export function isAscendant(rank: TaxonRank, of: TaxonRank) {
    return index(rank) < index(of)
  }

  export function parentRank(rank: TaxonRank): TaxonRank | undefined {
    return $TaxonRank.enum[index(rank) - 1]
  }

  export function childRank(rank: TaxonRank): TaxonRank | undefined {
    return $TaxonRank.enum[index(rank) + 1]
  }

  export function ranksUpTo(rank: TaxonRank): TaxonRank[] {
    return $TaxonRank.enum.slice(index(rank))
  }

  export function ranksDownTo(rank: TaxonRank): TaxonRank[] {
    return $TaxonRank.enum.slice(0, index(rank) + 1)
  }

}

export type Taxon = TTaxon
export namespace Taxon {
  export function shortName(name: string) {
    const [n, ...rest] = name.split(' ')
    return rest.length ? `${n[0]}. ${rest.join(' ')}` : n
  }
}