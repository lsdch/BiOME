// NOT generated by openapi-ts

import UserRoleIcon from "@/components/icons/UserRoleIcon"
import { DateTime } from "luxon"
import { $TaxonRank, $UserRole } from "./gen/schemas.gen"
import {
  CompositeDate as CompositeDateType,
  DatePrecision,
  DateWithPrecisionInput,
  DateWithPrecision as DateWithPrecisionType,
  Article as TArticle,
  ExtSeqOrigin as TExtSeqOrigin,
  InstitutionKind as TInstitutionKind,
  OccurrenceCategory as TOccurrenceCategory,
  SeqReference as TSeqReference,
  Taxon as TTaxon,
  TaxonRank as TTaxonRank,
  UserRole as TUserRole,
  User as TUser,
  Meta,
  Quantity as TQuantity
} from "./gen/types.gen"
import UserRoleChip from "@/components/people/UserRoleChip"
import QuantityChip from "@/components/occurrence/ExtBioMatQuantityChip"

export * from "./gen/types.gen"

export type CompositeDate = CompositeDateType
export namespace CompositeDate {
  export function fromDateWithPrecision({ precision, date }: DateWithPrecision): CompositeDate {
    if (precision === 'Unknown' || !date) return {}
    switch (precision) {
      case 'Year':
        return { year: date.getFullYear() }
      case 'Month':
        // JS months start at 0, because ✨ JS ✨
        return { month: date.getMonth() + 1, year: date.getFullYear() }
      case 'Day':
        return { day: date.getDate(), month: date.getMonth() + 1, year: date?.getFullYear() }
    }
  }
}


export type DateWithPrecision = DateWithPrecisionType
export namespace DateWithPrecision {
  const formats: Record<DatePrecision, string> = {
    Day: 'dd LLL yyyy',
    Month: 'LLL yyyy',
    Year: 'yyyy',
    Unknown: "'Unknown'"
  }
  export function compare(a: DateWithPrecision, b: DateWithPrecision) {
    return (DateWithPrecision.toDateTime(b) ?? 0) > (DateWithPrecision.toDateTime(a) ?? 0)
      ? -1
      : 1
  }

  export function toInput({ date, precision }: DateWithPrecision): DateWithPrecisionInput {
    return { date: CompositeDate.fromDateWithPrecision({ date, precision }), precision }
  }
  export function toDateTime({ date, precision }: DateWithPrecision): DateTime | null {
    if (precision === 'Unknown' || !date) return null
    return DateTime.fromJSDate(date)
  }

  export function format({ date, precision }: DateWithPrecision, format?: string) {
    if (precision === 'Unknown' || !date) return "Unknown"
    return DateTime.fromJSDate(date)
      .setLocale('en-gb')
      .toFormat(format ?? formats[precision])
  }
}

export type OccurrenceCategory = TOccurrenceCategory
export namespace OccurrenceCategory {

  export const props: Record<OccurrenceCategory, { icon: string, color: string, prependIcon: string }> = {
    Internal: {
      icon: 'mdi-cube-scan',
      prependIcon: 'mdi-cube-scan',
      color: 'primary'
    },
    External: {
      icon: 'mdi-arrow-collapse-all',
      prependIcon: 'mdi-arrow-collapse-all',
      color: 'warning'
    }
  }

  export function icon(t: OccurrenceCategory) {
    return props[t].icon
  }
}

export type Article = TArticle
export namespace Article {
  export function shortAuthors(authors: string[]): string {
    return authors.length == 1 ? authors[0] : authors.length == 2 ? authors.join(' & ') : `${authors[0]} et. al`
  }
  export function toString({ authors, year }: Article) {
    return `${shortAuthors(authors)} ${year}`
  }

  export function linkDOI({ doi }: Article) {
    return `https://doi.org/${doi}`
  }
}


export type ExtSeqOrigin = TExtSeqOrigin
export namespace ExtSeqOrigin {
  export const props: Record<ExtSeqOrigin, { icon: string, description: string }> = {
    Lab: { icon: 'mdi-test-tube', description: 'Sequence was produced in the lab, but registered as external due to missing informations' },
    DB: { icon: 'mdi-database-arrow-down', description: 'Sequence was imported from external database' },
    PersCom: { icon: 'mdi-email', description: 'Sequence was provided as personal communication' }
  }

  export function icon(origin: ExtSeqOrigin) {
    return props[origin].icon
  }

  export function description(origin: ExtSeqOrigin) {
    return props[origin].description
  }
}

export type SeqReference = TSeqReference
export namespace SeqReference {
  export function link({ accession, db }: SeqReference) {
    return db.link_template?.replace("{accession}", accession)
  }
}

export type InstitutionKind = TInstitutionKind
export namespace InstitutionKind {
  export const props: Record<InstitutionKind, { icon: string, color: string }> = {
    Lab: { icon: 'mdi-flask', color: 'primary' },
    FundingAgency: { icon: 'mdi-file-certificate', color: 'green' },
    SequencingPlatform: { icon: 'mdi-dna', color: 'orange' },
    Other: { icon: 'mdi-home-modern', color: 'grey' }
  }
  export function icon(kind: InstitutionKind) {
    return props[kind].icon
  }
  export function color(kind: InstitutionKind) {
    return props[kind].color
  }
  export function humanize(kind: InstitutionKind) {
    return kind.replace(/([a-z])([A-Z])/g, '$1 $2').trim()
  }
}

export type TaxonRank = TTaxonRank
export namespace TaxonRank {
  const taxonRankOrder = Object.fromEntries($TaxonRank.enum.map((rank, i) => [rank, i])) as { [k in TaxonRank]: number }

  export function index(rank: TaxonRank) {
    return taxonRankOrder[rank]
  }

  export function isDescendant(rank: TaxonRank, from: TaxonRank) {
    return index(rank) > index(from)
  }

  export function isAscendant(rank: TaxonRank, of: TaxonRank) {
    return index(rank) < index(of)
  }

  export function parentRank(rank: TaxonRank): TaxonRank | undefined {
    return $TaxonRank.enum[index(rank) - 1]
  }

  export function childRank(rank: TaxonRank): TaxonRank | undefined {
    return $TaxonRank.enum[index(rank) + 1]
  }

  export function ranksUpTo(rank: TaxonRank): TaxonRank[] {
    return $TaxonRank.enum.slice(index(rank))
  }

  export function ranksDownTo(rank: TaxonRank): TaxonRank[] {
    return $TaxonRank.enum.slice(0, index(rank) + 1)
  }

}

export type Taxon = TTaxon
export namespace Taxon {
  export function shortName(name: string) {
    const [n, ...rest] = name.split(' ')
    return rest.length ? `${n[0]}. ${rest.join(' ')}` : n
  }
}

export type UserRole = TUserRole
export namespace UserRole {
  interface UserStatus {
    role: UserRole
  }

  export function isGranted(user: UserStatus, role: UserRole) {
    return $UserRole.enum.indexOf(user.role) >= $UserRole.enum.indexOf(role)
  }

  export function Icon({ role }: { role?: UserRole }, context: { attrs?: object }) {
    return UserRoleIcon({ role }, context)
  }

  export function Chip({ role }: { role?: UserRole }, context: { attrs?: object }) {
    return UserRoleChip({ role }, context)
  }
}


export type Quantity = TQuantity
export namespace Quantity {

  export function Chip({ quantity }: { quantity: Quantity }, context: { attrs?: object }) {
    return QuantityChip({ quantity }, context)
  }
}

export type User = TUser
export namespace User {
  export function isOwner<
    Item extends { meta?: Meta }
  >(user: User, item: Item) {
    return item.meta?.created_by?.id === user.id
  }
}