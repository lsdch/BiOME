// This file is auto-generated by @hey-api/openapi-ts

export type AbioticMeasurement = {
    id: string;
    param: AbioticParameter;
    value: number;
};

export type AbioticParameter = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
    unit: string;
};

export type AbioticParameterInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
    unit: string;
};

export type AuthenticationResponse = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * JSON Web Token
     */
    auth_token: string;
    /**
     * Time at which auth token expires
     */
    auth_token_expiration: Date;
    messages: Array<(string)>;
    /**
     * Session refresh token
     */
    refresh_token: string;
    user: User;
};

export type Coordinates = {
    latitude: number;
    longitude: number;
    /**
     * Where the coordinates point to
     */
    precision: CoordinatesPrecision;
};

export type CoordinatesPrecision = '<100m' | '<1km' | '<10km' | '10-100km' | 'Unknown';

export type Country = {
    code: string;
    id: string;
    name: string;
};

export type CurrentUserResponse = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * JSON Web Token
     */
    auth_token: string;
    /**
     * Time at which auth token expires
     */
    auth_token_expiration: Date;
    /**
     * Session refresh token
     */
    refresh_token: string;
    user: User;
};

export type DatePrecision = 'Year' | 'Month' | 'Day' | 'Unknown';

export type DateWithPrecision = {
    date: Date;
    precision: DatePrecision;
};

export type EmailSettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    from_address: string;
    from_name: string;
    /**
     * SMTP domain that handles email sending
     */
    host: string;
    /**
     * SMTP password
     */
    password: string;
    /**
     * SMTP port
     */
    port: number;
    /**
     * SMTP login
     */
    user: string;
};

export type EmailSettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    from_address: string;
    from_name: string;
    /**
     * SMTP domain that handles email sending
     */
    host: string;
    /**
     * SMTP password
     */
    password: string;
    /**
     * SMTP port
     */
    port: number;
    /**
     * SMTP login
     */
    user: string;
};

export type ErrorDetail = {
    /**
     * Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
     */
    location?: string;
    /**
     * Error message text
     */
    message?: string;
    /**
     * The value at the given location
     */
    value?: unknown;
};

export type ErrorModel = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string;
    /**
     * Optional list of individual error details
     */
    errors?: Array<ErrorDetail>;
    /**
     * A URI reference that identifies the specific occurrence of the problem.
     */
    instance?: string;
    /**
     * HTTP status code
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
     */
    title?: string;
    /**
     * A URI reference to human-readable documentation for the error.
     */
    type?: string;
};

export type Event = {
    abiotic_measurements: Array<AbioticMeasurement>;
    id: string;
    meta: Meta;
    performed_by: Array<PersonUser>;
    performed_on: DateWithPrecision;
    programs?: Array<ProgramInner>;
    samplings: Array<Sampling>;
    site_code: string;
    spotting?: OptionalSpotting;
};

export type Fixative = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
};

export type FixativeInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
};

export type Gene = {
    code: string;
    description?: string;
    id: string;
    is_delimiter_MOTU: boolean;
    label: string;
    meta: Meta;
};

export type Habitat = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
    meta: Meta;
};

export type HabitatGroup = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    depends: OptionalHabitatRecord;
    elements: Array<HabitatRecord>;
    exclusive_elements: boolean;
    id: string;
    /**
     * Name for the group of habitat tags
     */
    label: string;
    meta: Meta;
};

export type HabitatGroupInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Habitat tag that this group is a refinement of
     */
    depends?: string;
    elements?: Array<HabitatInput>;
    exclusive_elements?: boolean;
    /**
     * Name for the group of habitat tags
     */
    label: string;
};

export type HabitatGroupUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    depends: (string) | null;
    exclusive_elements?: boolean;
    label?: string;
};

export type HabitatInput = {
    /**
     * Optional habitat description
     */
    description?: string;
    /**
     * List of habitat labels this habitat is incompatible with.
     */
    incompatible?: Array<(string)>;
    /**
     * A short label for the habitat.
     */
    label: string;
};

export type HabitatRecord = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
};

export type ImportProcess = {
    GBIF_ID: number;
    done: boolean;
    error: unknown;
    expected: number;
    imported: number;
    name: string;
    rank: TaxonRank;
    started: Date;
};

export type ImportRequestGbif = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Import whole clade, including the taxon descendants
     */
    children: boolean;
    /**
     * Target GBIF taxon key
     */
    key: number;
};

export type InstanceSettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Whether requests to contribute to the database can be made.
     */
    allow_contributor_signup: boolean;
    description: string;
    /**
     * The name of this database platform
     */
    name: string;
    /**
     * Whether the platform is accessible to unauthenticated users
     */
    public: boolean;
};

export type InstanceSettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Whether requests to contribute to the database can be made.
     */
    allow_contributor_signup: boolean;
    description?: (string) | null;
    /**
     * The name of this database platform
     */
    name: string;
    /**
     * Whether the platform is accessible to unauthenticated users
     */
    public: boolean;
};

export type Institution = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    kind: InstitutionKind;
    meta: Meta;
    name: string;
    /**
     * Known members of this institution
     */
    people?: Array<PersonUser>;
};

export type InstitutionInner = {
    code: string;
    description?: string;
    id: string;
    kind: InstitutionKind;
    name: string;
};

export type InstitutionInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    kind: InstitutionKind;
    name: string;
};

export type InstitutionKind = 'Lab' | 'FundingAgency' | 'SequencingPlatform' | 'Other';

export type InstitutionUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    kind?: (InstitutionKind) | null;
    name?: string;
};

export type InvitationInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * E-mail address of the recipient of the invitation
     */
    email: string;
    /**
     * A URL template with a {token} parameter, which implements the UI to validate the invitation token and fill a registration form.
     */
    handler?: Url;
    role: UserRole;
};

export type InvitationLink = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * The generated URL containing a registration token that can be shared to the invitee.
     */
    invitation_link: Url;
};

export type Lineage = {
    class?: OptionalTaxon;
    family?: OptionalTaxon;
    genus?: OptionalTaxon;
    kingdom?: OptionalTaxon;
    order?: OptionalTaxon;
    phylum?: OptionalTaxon;
    species?: OptionalTaxon;
    subspecies?: OptionalTaxon;
};

export type LogoutInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    refresh_token?: string;
};

export type Meta = {
    created: Date;
    created_by?: UserShortIdentity;
    last_updated: Date;
    modified?: Date;
    updated_by?: UserShortIdentity;
};

export type OptionalHabitatRecord = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
} | null;

export type OptionalPerson = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
};

export type OptionalSpotting = {
    comments?: string;
    id: string;
    target_taxa: Array<Taxon>;
} | null;

export type OptionalTaxon = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    rank: TaxonRank;
    status: TaxonStatus;
} | null;

export type OptionalUserInner = {
    email: string;
    email_confirmed: boolean;
    id: string;
    login: string;
    role: UserRole;
} | null;

export type PasswordInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Your new password
     */
    password: string;
    /**
     * New password confirmation
     */
    password_confirmation: string;
};

export type PasswordResetRequest = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    /**
     * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
     */
    handler?: string;
};

export type PendingUserRequest = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    created_on: Date;
    email: string;
    email_verified: boolean;
    first_name: string;
    full_name: string;
    id: string;
    institution?: string;
    last_name: string;
    motive?: string;
};

export type PendingUserRequestInput = {
    email: string;
    first_name: string;
    institution?: string;
    last_name: string;
    motive?: string;
};

export type Person = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    institutions: Array<InstitutionInner>;
    last_name: string;
    meta: Meta;
    role?: UserRole;
    user: OptionalUserInner;
};

export type PersonInner = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
};

export type PersonInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias?: string;
    comment?: string;
    contact?: string;
    first_name: string;
    institutions: Array<(string)>;
    last_name: string;
};

export type PersonUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias?: string;
    comment?: (string) | null;
    contact?: (string) | null;
    first_name?: string;
    institutions?: Array<(string)>;
    last_name?: string;
};

export type PersonUser = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
    user: OptionalUserInner;
};

export type Program = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    end_year?: number;
    funding_agencies: Array<InstitutionInner>;
    id: string;
    label: string;
    managers: Array<PersonInner>;
    meta: Meta;
    start_year?: number;
};

export type ProgramInner = {
    code: string;
    description?: string;
    end_year?: number;
    id: string;
    label: string;
    start_year?: number;
};

export type ProgramInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    end_year?: number;
    funding_agencies?: Array<(string)>;
    label: string;
    managers: Array<(string)>;
    start_year?: number;
};

export type ProgramUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    end_year?: (number) | null;
    funding_agencies?: Array<(string)> | null;
    label?: string;
    managers?: Array<(string)> | null;
    start_year?: (number) | null;
};

export type RefreshTokenBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    refresh_token: string;
};

export type RegisterInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    data: PendingUserRequestInput;
    verification_path: string;
};

export type ResendEmailVerificationInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    /**
     * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
     */
    verification_url: string;
};

export type Sampling = {
    access_points: Array<(string)>;
    comments?: string;
    /**
     * Sampling duration in minutes
     */
    duration?: number;
    fixatives: Array<Fixative>;
    habitats: Array<Habitat>;
    id: string;
    methods?: Array<SamplingMethod>;
    target: SamplingTarget;
};

export type SamplingMethod = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
};

export type SamplingMethodInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
};

export type SamplingTarget = {
    kind: SamplingTargetKind;
    target_taxa: Array<Taxon>;
};

export type SamplingTargetKind = 'Community' | 'Unknown' | 'Taxa';

export type SecuritySettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Invitation token lifetime in days
     */
    invitation_token_lifetime: number;
    /**
     * The level of complexity required for account passwords.
     */
    min_password_strength: number;
    /**
     * User session lifetime in hours
     */
    refresh_token_lifetime: number;
};

export type SecuritySettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Invitation token lifetime in days
     */
    invitation_token_lifetime: number;
    /**
     * The level of complexity required for account passwords.
     */
    min_password_strength: number;
    /**
     * User session lifetime in hours
     */
    refresh_token_lifetime: number;
};

export type Site = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    access_point?: string;
    altitude?: number;
    code: string;
    coordinates: Coordinates;
    country: Country;
    datasets: Array<SiteDatasetInner>;
    description: string;
    events: Array<Event>;
    id: string;
    locality?: string;
    meta: Meta;
    name: string;
};

export type SiteDataset = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description: string;
    id: string;
    label: string;
    maintainers: Array<PersonUser>;
    meta: Meta;
    sites: Array<SiteItem>;
    slug: string;
};

export type SiteDatasetInner = {
    description: string;
    id: string;
    label: string;
    slug: string;
};

export type SiteDatasetInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description?: string;
    label: string;
    /**
     * Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.
     */
    maintainers: Array<(string)>;
    /**
     * New sites to include in the dataset
     */
    new_sites?: Array<SiteInput>;
    /**
     * Existing site codes to include in the dataset
     */
    sites?: Array<(string)>;
};

export type SiteDatasetUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description?: (string) | null;
    label?: string;
    /**
     * Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.
     */
    maintainers?: Array<(string)>;
};

export type SiteInput = {
    /**
     * Site altitude in meters
     */
    altitude?: number;
    /**
     * A short unique uppercase alphanumeric identifier
     */
    code: string;
    /**
     * Site coordinates in decimal degrees
     */
    coordinates: Coordinates;
    country_code: string;
    description?: string;
    /**
     * Nearest populated place
     */
    locality?: string;
    name: string;
};

export type SiteItem = {
    access_point?: string;
    altitude?: number;
    code: string;
    coordinates: Coordinates;
    country: Country;
    description: string;
    id: string;
    locality?: string;
    name: string;
};

export type SiteUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Site altitude in meters
     */
    altitude?: (number) | null;
    /**
     * A short unique uppercase alphanumeric identifier
     */
    code: string;
    /**
     * Site coordinates in decimal degrees
     */
    coordinates: Coordinates;
    country_code: string;
    description?: (string) | null;
    /**
     * Nearest populated place
     */
    locality?: (string) | null;
    name: string;
};

export type Spotting = {
    comments?: string;
    id: string;
    target_taxa: Array<Taxon>;
};

export type Taxon = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authorship?: string;
    code?: string;
    comment?: string;
    name: string;
    parent: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonRank = 'Kingdom' | 'Phylum' | 'Class' | 'Order' | 'Family' | 'Genus' | 'Species' | 'Subspecies';

export type TaxonStatus = 'Accepted' | 'Unreferenced' | 'Unclassified';

export type TaxonUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authorship?: (string) | null;
    code?: string;
    name?: string;
    parent?: string;
    rank?: TaxonRank;
    status?: TaxonStatus;
};

export type TaxonWithLineage = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxon>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    lineage: Lineage;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonWithParentRef = {
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonWithRelatives = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxon>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type Taxonomy = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxonomy>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

/**
 * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
 */
export type Url = string;

export type UpdatePasswordInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    new_password: PasswordInput;
    /**
     * Your current password
     */
    password: string;
};

export type User = {
    email: string;
    email_confirmed: boolean;
    id: string;
    identity: OptionalPerson;
    login: string;
    role: UserRole;
};

export type UserCredentials = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    identifier: string;
    password: string;
};

export type UserInner = {
    email: string;
    email_confirmed: boolean;
    id: string;
    login: string;
    role: UserRole;
};

export type UserInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    login: string;
    /**
     * Your new password
     */
    password: string;
    /**
     * New password confirmation
     */
    password_confirmation: string;
};

export type UserRole = 'Visitor' | 'Contributor' | 'Maintainer' | 'Admin';

export type UserShortIdentity = {
    alias: string;
    id: string;
    login: string;
    name: string;
};

export type ListAbioticParametersData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListAbioticParametersResponse = (Array<AbioticParameter>);

export type ListAbioticParametersError = (ErrorModel);

export type CreateAbioticParameterData = {
    body: AbioticParameterInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateAbioticParameterResponse = (AbioticParameter);

export type CreateAbioticParameterError = (ErrorModel);

export type ListFixativesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListFixativesResponse = (Array<Fixative>);

export type ListFixativesError = (ErrorModel);

export type CreateFixativeData = {
    body: FixativeInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateFixativeResponse = (Fixative);

export type CreateFixativeError = (ErrorModel);

export type ListSamplingMethodsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSamplingMethodsResponse = (Array<SamplingMethod>);

export type ListSamplingMethodsError = (ErrorModel);

export type CreateSamplingMethodData = {
    body: SamplingMethodInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSamplingMethodResponse = (SamplingMethod);

export type CreateSamplingMethodError = (ErrorModel);

export type GetAccessPointsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type GetAccessPointsResponse = (Array<(string)>);

export type GetAccessPointsError = (ErrorModel);

export type ListSiteDatasetsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSiteDatasetsResponse = (Array<SiteDataset>);

export type ListSiteDatasetsError = (ErrorModel);

export type CreateSiteDatasetData = {
    body: SiteDatasetInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSiteDatasetResponse = (SiteDataset);

export type CreateSiteDatasetError = (ErrorModel);

export type UpdateSiteDatasetData = {
    body: SiteDatasetUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        slug: string;
    };
};

export type UpdateSiteDatasetResponse = (SiteDataset);

export type UpdateSiteDatasetError = (ErrorModel);

export type GetSiteDatasetData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        slug: string;
    };
};

export type GetSiteDatasetResponse = (SiteDataset);

export type GetSiteDatasetError = (ErrorModel);

export type ListHabitatGroupsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListHabitatGroupsResponse = (Array<HabitatGroup>);

export type ListHabitatGroupsError = (ErrorModel);

export type CreateHabitatGroupData = {
    body: HabitatGroupInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateHabitatGroupResponse = (HabitatGroup);

export type CreateHabitatGroupError = (ErrorModel);

export type DeleteHabitatGroupData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteHabitatGroupResponse = (HabitatGroup);

export type DeleteHabitatGroupError = (ErrorModel);

export type UpdateHabitatGroupData = {
    body: HabitatGroupUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateHabitatGroupResponse = (HabitatGroup);

export type UpdateHabitatGroupError = (ErrorModel);

export type ListCountriesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListCountriesResponse = (Array<Country>);

export type ListCountriesError = (ErrorModel);

export type ListSitesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSitesResponse = (Array<Site>);

export type ListSitesError = (ErrorModel);

export type GetSiteData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type GetSiteResponse = (Site);

export type GetSiteError = (ErrorModel);

export type UpdateSiteData = {
    body: SiteUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateSiteResponse = (Site);

export type UpdateSiteError = (ErrorModel);

export type CurrentUserData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CurrentUserResponse2 = (CurrentUserResponse | void);

export type CurrentUserError = (ErrorModel);

export type ConfirmEmailData = {
    query?: {
        token?: string;
    };
};

export type ConfirmEmailResponse = (string);

export type ConfirmEmailError = (ErrorModel);

export type ResendEmailVerificationData = {
    body: ResendEmailVerificationInputBody;
};

export type ResendEmailVerificationResponse = (void);

export type ResendEmailVerificationError = (ErrorModel);

export type RequestPasswordResetData = {
    body: PasswordResetRequest;
};

export type RequestPasswordResetResponse = (void);

export type RequestPasswordResetError = (ErrorModel);

export type LoginData = {
    body: UserCredentials;
};

export type LoginResponse = (AuthenticationResponse);

export type LoginError = (ErrorModel);

export type LogoutData = {
    body: LogoutInputBody;
};

export type LogoutResponse = (string);

export type LogoutError = (ErrorModel);

export type UpdatePasswordData = {
    body: UpdatePasswordInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdatePasswordResponse = (void);

export type UpdatePasswordError = (ErrorModel);

export type ValidatePasswordTokenData = {
    query: {
        token: string;
    };
};

export type ValidatePasswordTokenResponse = (void);

export type ValidatePasswordTokenError = (ErrorModel);

export type ResetPasswordData = {
    body: PasswordInput;
    query: {
        token: string;
    };
};

export type ResetPasswordResponse = (void);

export type ResetPasswordError = (ErrorModel);

export type ListPendingUserRequestsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListPendingUserRequestsResponse = (Array<PendingUserRequest>);

export type ListPendingUserRequestsError = (ErrorModel);

export type DeletePendingUserRequestData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type DeletePendingUserRequestResponse = (PendingUserRequest);

export type DeletePendingUserRequestError = (ErrorModel);

export type GetPendingUserRequestData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type GetPendingUserRequestResponse = (PendingUserRequest);

export type GetPendingUserRequestError = (ErrorModel);

export type RefreshSessionData = {
    body: RefreshTokenBody;
};

export type RefreshSessionResponse = (AuthenticationResponse);

export type RefreshSessionError = (ErrorModel);

export type RegisterData = {
    body: RegisterInputBody;
};

export type RegisterResponse = (string);

export type RegisterError = (ErrorModel);

export type ClaimInvitationData = {
    body: UserInput;
    path: {
        token: string;
    };
};

export type ClaimInvitationResponse = (AuthenticationResponse);

export type ClaimInvitationError = (ErrorModel);

export type ListAnchorsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListAnchorsResponse = (Array<TaxonWithParentRef>);

export type ListAnchorsError = (ErrorModel);

export type ImportGbifData = {
    body: ImportRequestGbif;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ImportGbifResponse = (void);

export type ImportGbifError = (ErrorModel);

export type MonitorGbifResponse = (Array<({
    data: {
        [key: string]: ImportProcess;
    };
    /**
     * The event name.
     */
    event: "state";
    /**
     * The event ID.
     */
    id?: number;
    /**
     * The retry time in milliseconds.
     */
    retry?: number;
})>);

export type MonitorGbifError = (ErrorModel);

export type ListGenesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListGenesResponse = (Array<Gene>);

export type ListGenesError = (ErrorModel);

export type ListInstitutionsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListInstitutionsResponse = (Array<Institution>);

export type ListInstitutionsError = (ErrorModel);

export type CreateInstitutionData = {
    body: InstitutionInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateInstitutionResponse = (Institution);

export type CreateInstitutionError = (ErrorModel);

export type DeleteInstitutionData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteInstitutionResponse = (Institution);

export type DeleteInstitutionError = (ErrorModel);

export type UpdateInstitutionData = {
    body: InstitutionUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateInstitutionResponse = (Institution);

export type UpdateInstitutionError = (ErrorModel);

export type ListPersonsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListPersonsResponse = (Array<Person>);

export type ListPersonsError = (ErrorModel);

export type CreatePersonData = {
    body: PersonInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreatePersonResponse = (Person);

export type CreatePersonError = (ErrorModel);

export type DeletePersonData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type DeletePersonResponse = (Person);

export type DeletePersonError = (ErrorModel);

export type UpdatePersonData = {
    body: PersonUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type UpdatePersonResponse = (Person);

export type UpdatePersonError = (ErrorModel);

export type InvitePersonData = {
    body: InvitationInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type InvitePersonResponse = (InvitationLink);

export type InvitePersonError = (ErrorModel);

export type ListProgramsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListProgramsResponse = (Array<Program>);

export type ListProgramsError = (ErrorModel);

export type CreateProgramData = {
    body: ProgramInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateProgramResponse = (Program);

export type CreateProgramError = (ErrorModel);

export type DeleteProgramData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteProgramResponse = (Program);

export type DeleteProgramError = (ErrorModel);

export type UpdateProgramData = {
    body: ProgramUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateProgramResponse = (Program);

export type UpdateProgramError = (ErrorModel);

export type EmailSettingsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type EmailSettingsResponse = (EmailSettings);

export type EmailSettingsError = (ErrorModel);

export type UpdateEmailSettingsData = {
    body: EmailSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateEmailSettingsResponse = (EmailSettings);

export type UpdateEmailSettingsError = (ErrorModel);

export type TestSmtpData = {
    body: EmailSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type TestSmtpResponse = (boolean);

export type TestSmtpError = (ErrorModel);

export type SetAppIconData = {
    body?: {
        icon: (Blob | File);
    };
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type SetAppIconResponse = (string);

export type SetAppIconError = (ErrorModel);

export type InstanceSettingsResponse = (InstanceSettings);

export type InstanceSettingsError = (ErrorModel);

export type UpdateInstanceSettingsData = {
    body: InstanceSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateInstanceSettingsResponse = (InstanceSettings);

export type UpdateInstanceSettingsError = (ErrorModel);

export type SecuritySettingsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type SecuritySettingsResponse = (SecuritySettings);

export type SecuritySettingsError = (ErrorModel);

export type UpdateSecuritySettingsData = {
    body: SecuritySettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateSecuritySettingsResponse = (SecuritySettings);

export type UpdateSecuritySettingsError = (ErrorModel);

export type GetTaxonomyData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    query?: {
        /**
         * Taxon code or UUID
         */
        identifier?: string;
        'max-depth'?: TaxonRank;
    };
};

export type GetTaxonomyResponse = (Taxonomy);

export type GetTaxonomyError = (ErrorModel);

export type ListTaxaData = {
    query?: {
        anchor?: boolean;
        limit?: number;
        parent?: string;
        pattern?: string;
        rank?: TaxonRank;
        status?: TaxonStatus;
    };
};

export type ListTaxaResponse = (Array<TaxonWithParentRef>);

export type ListTaxaError = (ErrorModel);

export type CreateTaxonData = {
    body: TaxonInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateTaxonResponse = (TaxonWithRelatives);

export type CreateTaxonError = (ErrorModel);

export type DeleteTaxonData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteTaxonResponse = (TaxonWithRelatives);

export type DeleteTaxonError = (ErrorModel);

export type GetTaxonData = {
    path: {
        code: string;
    };
};

export type GetTaxonResponse = (TaxonWithLineage);

export type GetTaxonError = (ErrorModel);

export type UpdateTaxonData = {
    body: TaxonUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateTaxonResponse = (Taxon);

export type UpdateTaxonError = (ErrorModel);