// This file is auto-generated by @hey-api/openapi-ts

export type AbioticMeasurement = {
    id: string;
    param: AbioticParameter;
    value: number;
};

export type AbioticParameter = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
    unit: string;
};

export type AbioticParameterInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
    unit: string;
};

export type AuthenticationResponse = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * JSON Web Token
     */
    auth_token: string;
    /**
     * Time at which auth token expires
     */
    auth_token_expiration: Date;
    messages: Array<(string)>;
    /**
     * Session refresh token
     */
    refresh_token: string;
    user: User;
};

export type Coordinates = {
    latitude: number;
    longitude: number;
    /**
     * Where the coordinates point to
     */
    precision: CoordinatesPrecision;
};

export type CoordinatesPrecision = '<100m' | '<1km' | '<10km' | '10-100km' | 'Unknown';

export type Country = {
    code: string;
    id: string;
    name: string;
};

export type CurrentUserResponse = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * JSON Web Token
     */
    auth_token: string;
    /**
     * Time at which auth token expires
     */
    auth_token_expiration: Date;
    /**
     * Session refresh token
     */
    refresh_token: string;
    user: User;
};

export type Dataset = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description: string;
    id: string;
    label: string;
    maintainers: Array<PersonUser>;
    meta: Meta;
    sites: Array<SiteItem>;
    slug: string;
};

export type DatasetInner = {
    description: string;
    id: string;
    label: string;
    slug: string;
};

export type DatasetInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description?: string;
    label: string;
    /**
     * Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.
     */
    maintainers: Array<(string)>;
    /**
     * New sites to include in the dataset
     */
    new_sites?: Array<SiteInput>;
    /**
     * Existing site codes to include in the dataset
     */
    sites?: Array<(string)>;
};

export type DatasetUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description?: (string) | null;
    label?: string;
    /**
     * Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.
     */
    maintainers?: Array<(string)>;
};

export type DatePrecision = 'Year' | 'Month' | 'Day' | 'Unknown';

export type DateWithPrecision = {
    date: Date;
    precision: DatePrecision;
};

export type EmailSettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    from_address: string;
    from_name: string;
    /**
     * SMTP domain that handles email sending
     */
    host: string;
    /**
     * SMTP password
     */
    password: string;
    /**
     * SMTP port
     */
    port: number;
    /**
     * SMTP login
     */
    user: string;
};

export type EmailSettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    from_address: string;
    from_name: string;
    /**
     * SMTP domain that handles email sending
     */
    host: string;
    /**
     * SMTP password
     */
    password: string;
    /**
     * SMTP port
     */
    port: number;
    /**
     * SMTP login
     */
    user: string;
};

export type ErrorDetail = {
    /**
     * Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
     */
    location?: string;
    /**
     * Error message text
     */
    message?: string;
    /**
     * The value at the given location
     */
    value?: unknown;
};

export type ErrorModel = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string;
    /**
     * Optional list of individual error details
     */
    errors?: Array<ErrorDetail>;
    /**
     * A URI reference that identifies the specific occurrence of the problem.
     */
    instance?: string;
    /**
     * HTTP status code
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
     */
    title?: string;
    /**
     * A URI reference to human-readable documentation for the error.
     */
    type?: string;
};

export type Event = {
    abiotic_measurements: Array<AbioticMeasurement>;
    id: string;
    meta: Meta;
    performed_by: Array<PersonUser>;
    performed_on: DateWithPrecision;
    programs?: Array<ProgramInner>;
    samplings: Array<Sampling>;
    site_code: string;
    spotting?: OptionalSpotting;
};

export type Fixative = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
};

export type FixativeInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
};

export type Gene = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    is_MOTU_delimiter: boolean;
    label: string;
    meta: Meta;
};

export type GeneInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    is_MOTU_delimiter?: boolean;
    label: string;
};

export type Habitat = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
    meta: Meta;
};

export type HabitatGroup = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    depends: OptionalHabitatRecord;
    elements: Array<HabitatRecord>;
    exclusive_elements: boolean;
    id: string;
    /**
     * Name for the group of habitat tags
     */
    label: string;
    meta: Meta;
};

export type HabitatGroupInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Habitat tag that this group is a refinement of
     */
    depends?: string;
    elements: Array<HabitatInput>;
    exclusive_elements?: boolean;
    /**
     * Name for the group of habitat tags
     */
    label: string;
};

export type HabitatGroupUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    create_tags?: Array<HabitatInput>;
    delete_tags?: Array<(string)>;
    depends?: (string) | null;
    exclusive_elements?: boolean;
    label?: string;
    update_tags?: {
        [key: string]: HabitatUpdate;
    };
};

export type HabitatInput = {
    /**
     * Optional habitat description
     */
    description?: string;
    /**
     * A short label for the habitat.
     */
    label: string;
};

export type HabitatRecord = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
};

export type HabitatUpdate = {
    description?: (string) | null;
    label?: string;
};

export type ImportProcess = {
    GBIF_ID: number;
    done: boolean;
    error: unknown;
    expected: number;
    imported: number;
    name: string;
    rank: TaxonRank;
    started: Date;
};

export type ImportRequestGbif = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Import whole clade, including the taxon descendants
     */
    children: boolean;
    /**
     * Target GBIF taxon key
     */
    key: number;
};

export type InstanceSettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Whether requests to contribute to the database can be made.
     */
    allow_contributor_signup: boolean;
    description: string;
    /**
     * The name of this database platform
     */
    name: string;
    /**
     * Whether the platform is accessible to unauthenticated users
     */
    public: boolean;
};

export type InstanceSettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Whether requests to contribute to the database can be made.
     */
    allow_contributor_signup: boolean;
    description?: (string) | null;
    /**
     * The name of this database platform
     */
    name: string;
    /**
     * Whether the platform is accessible to unauthenticated users
     */
    public: boolean;
};

export type Institution = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    kind: InstitutionKind;
    meta: Meta;
    name: string;
    /**
     * Known members of this institution
     */
    people?: Array<PersonUser>;
};

export type InstitutionInner = {
    code: string;
    description?: string;
    id: string;
    kind: InstitutionKind;
    name: string;
};

export type InstitutionInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    kind: InstitutionKind;
    name: string;
};

export type InstitutionKind = 'Lab' | 'FundingAgency' | 'SequencingPlatform' | 'Other';

export type InstitutionUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    kind?: (InstitutionKind) | null;
    name?: string;
};

export type InvitationInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * E-mail address of the recipient of the invitation
     */
    email: string;
    /**
     * A URL template with a {token} parameter, which implements the UI to validate the invitation token and fill a registration form.
     */
    handler?: Url;
    role: UserRole;
};

export type InvitationLink = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * The generated URL containing a registration token that can be shared to the invitee.
     */
    invitation_link: Url;
};

export type Lineage = {
    class?: OptionalTaxon;
    family?: OptionalTaxon;
    genus?: OptionalTaxon;
    kingdom?: OptionalTaxon;
    order?: OptionalTaxon;
    phylum?: OptionalTaxon;
    species?: OptionalTaxon;
    subspecies?: OptionalTaxon;
};

export type LogoutInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    refresh_token?: string;
};

export type Meta = {
    created: Date;
    created_by?: UserShortIdentity;
    last_updated: Date;
    modified?: Date;
    updated_by?: UserShortIdentity;
};

export type OptionalHabitatRecord = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
} | null;

export type OptionalPerson = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
};

export type OptionalSpotting = {
    comments?: string;
    id: string;
    target_taxa: Array<Taxon>;
} | null;

export type OptionalTaxon = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    rank: TaxonRank;
    status: TaxonStatus;
} | null;

export type OptionalUserInner = {
    email: string;
    email_confirmed: boolean;
    id: string;
    login: string;
    role: UserRole;
} | null;

export type PasswordInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Your new password
     */
    password: string;
    /**
     * New password confirmation
     */
    password_confirmation: string;
};

export type PasswordResetRequest = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    /**
     * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
     */
    handler?: string;
};

export type PendingUserRequest = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    created_on: Date;
    email: string;
    email_verified: boolean;
    first_name: string;
    full_name: string;
    id: string;
    institution?: string;
    last_name: string;
    motive?: string;
};

export type PendingUserRequestInput = {
    email: string;
    first_name: string;
    institution?: string;
    last_name: string;
    motive?: string;
};

export type Person = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    institutions: Array<InstitutionInner>;
    last_name: string;
    meta: Meta;
    role?: UserRole;
    user: OptionalUserInner;
};

export type PersonInner = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
};

export type PersonInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias?: string;
    comment?: string;
    contact?: string;
    first_name: string;
    institutions: Array<(string)>;
    last_name: string;
};

export type PersonUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias?: string;
    comment?: (string) | null;
    contact?: (string) | null;
    first_name?: string;
    institutions?: Array<(string)>;
    last_name?: string;
};

export type PersonUser = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
    user: OptionalUserInner;
};

export type Program = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    end_year?: number;
    funding_agencies: Array<InstitutionInner>;
    id: string;
    label: string;
    managers: Array<PersonInner>;
    meta: Meta;
    start_year?: number;
};

export type ProgramInner = {
    code: string;
    description?: string;
    end_year?: number;
    id: string;
    label: string;
    start_year?: number;
};

export type ProgramInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    end_year?: number;
    funding_agencies?: Array<(string)>;
    label: string;
    managers: Array<(string)>;
    start_year?: number;
};

export type ProgramUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    end_year?: (number) | null;
    funding_agencies?: Array<(string)> | null;
    label?: string;
    managers?: Array<(string)> | null;
    start_year?: (number) | null;
};

export type RefreshTokenBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    refresh_token: string;
};

export type RegisterInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    data: PendingUserRequestInput;
    verification_path: string;
};

export type ResendEmailVerificationInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    /**
     * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
     */
    verification_url: string;
};

export type Sampling = {
    access_points: Array<(string)>;
    comments?: string;
    /**
     * Sampling duration in minutes
     */
    duration?: number;
    fixatives: Array<Fixative>;
    habitats: Array<Habitat>;
    id: string;
    methods?: Array<SamplingMethod>;
    target: SamplingTarget;
};

export type SamplingMethod = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
};

export type SamplingMethodInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
};

export type SamplingTarget = {
    kind: SamplingTargetKind;
    target_taxa: Array<Taxon>;
};

export type SamplingTargetKind = 'Community' | 'Unknown' | 'Taxa';

export type SecuritySettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Invitation token lifetime in days
     */
    invitation_token_lifetime: number;
    /**
     * The level of complexity required for account passwords.
     */
    min_password_strength: number;
    /**
     * User session lifetime in hours
     */
    refresh_token_lifetime: number;
};

export type SecuritySettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Invitation token lifetime in days
     */
    invitation_token_lifetime: number;
    /**
     * The level of complexity required for account passwords.
     */
    min_password_strength: number;
    /**
     * User session lifetime in hours
     */
    refresh_token_lifetime: number;
};

export type Site = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    access_point?: string;
    altitude?: number;
    code: string;
    coordinates: Coordinates;
    country: Country;
    datasets: Array<DatasetInner>;
    description: string;
    events: Array<Event>;
    id: string;
    locality?: string;
    meta: Meta;
    name: string;
};

export type SiteInput = {
    /**
     * Site altitude in meters
     */
    altitude?: number;
    /**
     * A short unique uppercase alphanumeric identifier
     */
    code: string;
    /**
     * Site coordinates in decimal degrees
     */
    coordinates: Coordinates;
    country_code: string;
    description?: string;
    /**
     * Nearest populated place
     */
    locality?: string;
    name: string;
};

export type SiteItem = {
    access_point?: string;
    altitude?: number;
    code: string;
    coordinates: Coordinates;
    country: Country;
    description: string;
    id: string;
    locality?: string;
    name: string;
};

export type SiteUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Site altitude in meters
     */
    altitude?: (number) | null;
    /**
     * A short unique uppercase alphanumeric identifier
     */
    code: string;
    /**
     * Site coordinates in decimal degrees
     */
    coordinates: Coordinates;
    country_code: string;
    description?: (string) | null;
    /**
     * Nearest populated place
     */
    locality?: (string) | null;
    name: string;
};

export type Spotting = {
    comments?: string;
    id: string;
    target_taxa: Array<Taxon>;
};

export type Taxon = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authorship?: string;
    code?: string;
    comment?: string;
    name: string;
    parent: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type Taxonomy = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxonomy>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonRank = 'Kingdom' | 'Phylum' | 'Class' | 'Order' | 'Family' | 'Genus' | 'Species' | 'Subspecies';

export type TaxonStatus = 'Accepted' | 'Unreferenced' | 'Unclassified';

export type TaxonUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authorship?: (string) | null;
    code?: string;
    name?: string;
    parent?: string;
    rank?: TaxonRank;
    status?: TaxonStatus;
};

export type TaxonWithLineage = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxon>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    lineage: Lineage;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonWithParentRef = {
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonWithRelatives = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxon>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type UpdatePasswordInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    new_password: PasswordInput;
    /**
     * Your current password
     */
    password: string;
};

/**
 * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
 */
export type Url = string;

export type User = {
    email: string;
    email_confirmed: boolean;
    id: string;
    identity: OptionalPerson;
    login: string;
    role: UserRole;
};

export type UserCredentials = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    identifier: string;
    password: string;
};

export type UserInner = {
    email: string;
    email_confirmed: boolean;
    id: string;
    login: string;
    role: UserRole;
};

export type UserInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    login: string;
    /**
     * Your new password
     */
    password: string;
    /**
     * New password confirmation
     */
    password_confirmation: string;
};

export type UserRole = 'Visitor' | 'Contributor' | 'Maintainer' | 'Admin';

export type UserShortIdentity = {
    alias: string;
    id: string;
    login: string;
    name: string;
};

export type CurrentUserData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CurrentUserResponse2 = (CurrentUserResponse | void);

export type CurrentUserError = (ErrorModel);

export type ConfirmEmailData = {
    query?: {
        token?: string;
    };
};

export type ConfirmEmailResponse = (string);

export type ConfirmEmailError = (ErrorModel);

export type ResendEmailVerificationData = {
    body: ResendEmailVerificationInputBody;
};

export type ResendEmailVerificationResponse = (void);

export type ResendEmailVerificationError = (ErrorModel);

export type RequestPasswordResetData = {
    body: PasswordResetRequest;
};

export type RequestPasswordResetResponse = (void);

export type RequestPasswordResetError = (ErrorModel);

export type LoginData = {
    body: UserCredentials;
};

export type LoginResponse = (AuthenticationResponse);

export type LoginError = (ErrorModel);

export type LogoutData = {
    body: LogoutInputBody;
};

export type LogoutResponse = (string);

export type LogoutError = (ErrorModel);

export type UpdatePasswordData = {
    body: UpdatePasswordInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdatePasswordResponse = (void);

export type UpdatePasswordError = (ErrorModel);

export type ValidatePasswordTokenData = {
    query: {
        token: string;
    };
};

export type ValidatePasswordTokenResponse = (void);

export type ValidatePasswordTokenError = (ErrorModel);

export type ResetPasswordData = {
    body: PasswordInput;
    query: {
        token: string;
    };
};

export type ResetPasswordResponse = (void);

export type ResetPasswordError = (ErrorModel);

export type ListPendingUserRequestsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListPendingUserRequestsResponse = (Array<PendingUserRequest>);

export type ListPendingUserRequestsError = (ErrorModel);

export type DeletePendingUserRequestData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type DeletePendingUserRequestResponse = (PendingUserRequest);

export type DeletePendingUserRequestError = (ErrorModel);

export type GetPendingUserRequestData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type GetPendingUserRequestResponse = (PendingUserRequest);

export type GetPendingUserRequestError = (ErrorModel);

export type RefreshSessionData = {
    body: RefreshTokenBody;
};

export type RefreshSessionResponse = (AuthenticationResponse);

export type RefreshSessionError = (ErrorModel);

export type RegisterData = {
    body: RegisterInputBody;
};

export type RegisterResponse = (string);

export type RegisterError = (ErrorModel);

export type ClaimInvitationData = {
    body: UserInput;
    path: {
        token: string;
    };
};

export type ClaimInvitationResponse = (AuthenticationResponse);

export type ClaimInvitationError = (ErrorModel);

export type ListCountriesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListCountriesResponse = (Array<Country>);

export type ListCountriesError = (ErrorModel);

export type ListDatasetsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListDatasetsResponse = (Array<Dataset>);

export type ListDatasetsError = (ErrorModel);

export type CreateDatasetData = {
    body: DatasetInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateDatasetResponse = (Dataset);

export type CreateDatasetError = (ErrorModel);

export type UpdateDatasetData = {
    body: DatasetUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        slug: string;
    };
};

export type UpdateDatasetResponse = (Dataset);

export type UpdateDatasetError = (ErrorModel);

export type GetDatasetData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        slug: string;
    };
};

export type GetDatasetResponse = (Dataset);

export type GetDatasetError = (ErrorModel);

export type ListProgramsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListProgramsResponse = (Array<Program>);

export type ListProgramsError = (ErrorModel);

export type CreateProgramData = {
    body: ProgramInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateProgramResponse = (Program);

export type CreateProgramError = (ErrorModel);

export type DeleteProgramData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteProgramResponse = (Program);

export type DeleteProgramError = (ErrorModel);

export type UpdateProgramData = {
    body: ProgramUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateProgramResponse = (Program);

export type UpdateProgramError = (ErrorModel);

export type ListHabitatGroupsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListHabitatGroupsResponse = (Array<HabitatGroup>);

export type ListHabitatGroupsError = (ErrorModel);

export type CreateHabitatGroupData = {
    body: HabitatGroupInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateHabitatGroupResponse = (HabitatGroup);

export type CreateHabitatGroupError = (ErrorModel);

export type DeleteHabitatGroupData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteHabitatGroupResponse = (HabitatGroup);

export type DeleteHabitatGroupError = (ErrorModel);

export type UpdateHabitatGroupData = {
    body: HabitatGroupUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateHabitatGroupResponse = (HabitatGroup);

export type UpdateHabitatGroupError = (ErrorModel);

export type ListInstitutionsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListInstitutionsResponse = (Array<Institution>);

export type ListInstitutionsError = (ErrorModel);

export type CreateInstitutionData = {
    body: InstitutionInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateInstitutionResponse = (Institution);

export type CreateInstitutionError = (ErrorModel);

export type DeleteInstitutionData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteInstitutionResponse = (Institution);

export type DeleteInstitutionError = (ErrorModel);

export type UpdateInstitutionData = {
    body: InstitutionUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateInstitutionResponse = (Institution);

export type UpdateInstitutionError = (ErrorModel);

export type ListSitesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSitesResponse = (Array<Site>);

export type ListSitesError = (ErrorModel);

export type GetSiteData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type GetSiteResponse = (Site);

export type GetSiteError = (ErrorModel);

export type UpdateSiteData = {
    body: SiteUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateSiteResponse = (Site);

export type UpdateSiteError = (ErrorModel);

export type ListPersonsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListPersonsResponse = (Array<Person>);

export type ListPersonsError = (ErrorModel);

export type CreatePersonData = {
    body: PersonInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreatePersonResponse = (Person);

export type CreatePersonError = (ErrorModel);

export type DeletePersonData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type DeletePersonResponse = (Person);

export type DeletePersonError = (ErrorModel);

export type UpdatePersonData = {
    body: PersonUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type UpdatePersonResponse = (Person);

export type UpdatePersonError = (ErrorModel);

export type InvitePersonData = {
    body: InvitationInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type InvitePersonResponse = (InvitationLink);

export type InvitePersonError = (ErrorModel);

export type ListAbioticParametersData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListAbioticParametersResponse = (Array<AbioticParameter>);

export type ListAbioticParametersError = (ErrorModel);

export type CreateAbioticParameterData = {
    body: AbioticParameterInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateAbioticParameterResponse = (AbioticParameter);

export type CreateAbioticParameterError = (ErrorModel);

export type GetAccessPointsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type GetAccessPointsResponse = (Array<(string)>);

export type GetAccessPointsError = (ErrorModel);

export type ListFixativesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListFixativesResponse = (Array<Fixative>);

export type ListFixativesError = (ErrorModel);

export type CreateFixativeData = {
    body: FixativeInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateFixativeResponse = (Fixative);

export type CreateFixativeError = (ErrorModel);

export type ListSamplingMethodsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSamplingMethodsResponse = (Array<SamplingMethod>);

export type ListSamplingMethodsError = (ErrorModel);

export type CreateSamplingMethodData = {
    body: SamplingMethodInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSamplingMethodResponse = (SamplingMethod);

export type CreateSamplingMethodError = (ErrorModel);

export type ListGenesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListGenesResponse = (Array<Gene>);

export type ListGenesError = (ErrorModel);

export type CreateGeneData = {
    body: GeneInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateGeneResponse = (Gene);

export type CreateGeneError = (ErrorModel);

export type EmailSettingsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type EmailSettingsResponse = (EmailSettings);

export type EmailSettingsError = (ErrorModel);

export type UpdateEmailSettingsData = {
    body: EmailSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateEmailSettingsResponse = (EmailSettings);

export type UpdateEmailSettingsError = (ErrorModel);

export type TestSmtpData = {
    body: EmailSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type TestSmtpResponse = (boolean);

export type TestSmtpError = (ErrorModel);

export type SetAppIconData = {
    body?: {
        icon: (Blob | File);
    };
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type SetAppIconResponse = (string);

export type SetAppIconError = (ErrorModel);

export type InstanceSettingsResponse = (InstanceSettings);

export type InstanceSettingsError = (ErrorModel);

export type UpdateInstanceSettingsData = {
    body: InstanceSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateInstanceSettingsResponse = (InstanceSettings);

export type UpdateInstanceSettingsError = (ErrorModel);

export type SecuritySettingsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type SecuritySettingsResponse = (SecuritySettings);

export type SecuritySettingsError = (ErrorModel);

export type UpdateSecuritySettingsData = {
    body: SecuritySettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateSecuritySettingsResponse = (SecuritySettings);

export type UpdateSecuritySettingsError = (ErrorModel);

export type GetTaxonomyData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    query?: {
        /**
         * Taxon code or UUID
         */
        identifier?: string;
        'max-depth'?: TaxonRank;
    };
};

export type GetTaxonomyResponse = (Taxonomy);

export type GetTaxonomyError = (ErrorModel);

export type ListTaxaData = {
    query?: {
        anchor?: boolean;
        limit?: number;
        parent?: string;
        pattern?: string;
        rank?: TaxonRank;
        status?: TaxonStatus;
    };
};

export type ListTaxaResponse = (Array<TaxonWithParentRef>);

export type ListTaxaError = (ErrorModel);

export type CreateTaxonData = {
    body: TaxonInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateTaxonResponse = (TaxonWithRelatives);

export type CreateTaxonError = (ErrorModel);

export type DeleteTaxonData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteTaxonResponse = (TaxonWithRelatives);

export type DeleteTaxonError = (ErrorModel);

export type GetTaxonData = {
    path: {
        code: string;
    };
};

export type GetTaxonResponse = (TaxonWithLineage);

export type GetTaxonError = (ErrorModel);

export type UpdateTaxonData = {
    body: TaxonUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateTaxonResponse = (Taxon);

export type UpdateTaxonError = (ErrorModel);

export type ListAnchorsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListAnchorsResponse = (Array<TaxonWithParentRef>);

export type ListAnchorsError = (ErrorModel);

export type ImportGbifData = {
    body: ImportRequestGbif;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ImportGbifResponse = (void);

export type ImportGbifError = (ErrorModel);

export type MonitorGbifResponse = (Array<({
    data: {
        [key: string]: ImportProcess;
    };
    /**
     * The event name.
     */
    event: "state";
    /**
     * The event ID.
     */
    id?: number;
    /**
     * The retry time in milliseconds.
     */
    retry?: number;
})>);

export type MonitorGbifError = (ErrorModel);

export type LoginResponseTransformer = (data: any) => Promise<LoginResponse>;

export type AuthenticationResponseModelResponseTransformer = (data: any) => AuthenticationResponse;

export const AuthenticationResponseModelResponseTransformer: AuthenticationResponseModelResponseTransformer = data => {
    if (data?.auth_token_expiration) {
        data.auth_token_expiration = new Date(data.auth_token_expiration);
    }
    return data;
};

export const LoginResponseTransformer: LoginResponseTransformer = async (data) => {
    AuthenticationResponseModelResponseTransformer(data);
    return data;
};

export type ListPendingUserRequestsResponseTransformer = (data: any) => Promise<ListPendingUserRequestsResponse>;

export type PendingUserRequestModelResponseTransformer = (data: any) => PendingUserRequest;

export const PendingUserRequestModelResponseTransformer: PendingUserRequestModelResponseTransformer = data => {
    if (data?.created_on) {
        data.created_on = new Date(data.created_on);
    }
    return data;
};

export const ListPendingUserRequestsResponseTransformer: ListPendingUserRequestsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(PendingUserRequestModelResponseTransformer);
    }
    return data;
};

export type DeletePendingUserRequestResponseTransformer = (data: any) => Promise<DeletePendingUserRequestResponse>;

export const DeletePendingUserRequestResponseTransformer: DeletePendingUserRequestResponseTransformer = async (data) => {
    PendingUserRequestModelResponseTransformer(data);
    return data;
};

export type GetPendingUserRequestResponseTransformer = (data: any) => Promise<GetPendingUserRequestResponse>;

export const GetPendingUserRequestResponseTransformer: GetPendingUserRequestResponseTransformer = async (data) => {
    PendingUserRequestModelResponseTransformer(data);
    return data;
};

export type RefreshSessionResponseTransformer = (data: any) => Promise<RefreshSessionResponse>;

export const RefreshSessionResponseTransformer: RefreshSessionResponseTransformer = async (data) => {
    AuthenticationResponseModelResponseTransformer(data);
    return data;
};

export type ClaimInvitationResponseTransformer = (data: any) => Promise<ClaimInvitationResponse>;

export const ClaimInvitationResponseTransformer: ClaimInvitationResponseTransformer = async (data) => {
    AuthenticationResponseModelResponseTransformer(data);
    return data;
};

export type ListDatasetsResponseTransformer = (data: any) => Promise<ListDatasetsResponse>;

export type DatasetModelResponseTransformer = (data: any) => Dataset;

export type MetaModelResponseTransformer = (data: any) => Meta;

export const MetaModelResponseTransformer: MetaModelResponseTransformer = data => {
    if (data?.created) {
        data.created = new Date(data.created);
    }
    if (data?.last_updated) {
        data.last_updated = new Date(data.last_updated);
    }
    if (data?.modified) {
        data.modified = new Date(data.modified);
    }
    return data;
};

export const DatasetModelResponseTransformer: DatasetModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListDatasetsResponseTransformer: ListDatasetsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(DatasetModelResponseTransformer);
    }
    return data;
};

export type CreateDatasetResponseTransformer = (data: any) => Promise<CreateDatasetResponse>;

export const CreateDatasetResponseTransformer: CreateDatasetResponseTransformer = async (data) => {
    DatasetModelResponseTransformer(data);
    return data;
};

export type UpdateDatasetResponseTransformer = (data: any) => Promise<UpdateDatasetResponse>;

export const UpdateDatasetResponseTransformer: UpdateDatasetResponseTransformer = async (data) => {
    DatasetModelResponseTransformer(data);
    return data;
};

export type GetDatasetResponseTransformer = (data: any) => Promise<GetDatasetResponse>;

export const GetDatasetResponseTransformer: GetDatasetResponseTransformer = async (data) => {
    DatasetModelResponseTransformer(data);
    return data;
};

export type ListProgramsResponseTransformer = (data: any) => Promise<ListProgramsResponse>;

export type ProgramModelResponseTransformer = (data: any) => Program;

export const ProgramModelResponseTransformer: ProgramModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListProgramsResponseTransformer: ListProgramsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(ProgramModelResponseTransformer);
    }
    return data;
};

export type CreateProgramResponseTransformer = (data: any) => Promise<CreateProgramResponse>;

export const CreateProgramResponseTransformer: CreateProgramResponseTransformer = async (data) => {
    ProgramModelResponseTransformer(data);
    return data;
};

export type DeleteProgramResponseTransformer = (data: any) => Promise<DeleteProgramResponse>;

export const DeleteProgramResponseTransformer: DeleteProgramResponseTransformer = async (data) => {
    ProgramModelResponseTransformer(data);
    return data;
};

export type UpdateProgramResponseTransformer = (data: any) => Promise<UpdateProgramResponse>;

export const UpdateProgramResponseTransformer: UpdateProgramResponseTransformer = async (data) => {
    ProgramModelResponseTransformer(data);
    return data;
};

export type ListHabitatGroupsResponseTransformer = (data: any) => Promise<ListHabitatGroupsResponse>;

export type HabitatGroupModelResponseTransformer = (data: any) => HabitatGroup;

export type OptionalHabitatRecordModelResponseTransformer = (data: any) => OptionalHabitatRecord;

export type HabitatRecordModelResponseTransformer = (data: any) => HabitatRecord;

export const HabitatRecordModelResponseTransformer: HabitatRecordModelResponseTransformer = data => {
    if (Array.isArray(data?.incompatible)) {
        data.incompatible.forEach(HabitatRecordModelResponseTransformer);
    }
    return data;
};

export const OptionalHabitatRecordModelResponseTransformer: OptionalHabitatRecordModelResponseTransformer = data => {
    if (Array.isArray(data?.incompatible)) {
        data.incompatible.forEach(HabitatRecordModelResponseTransformer);
    }
    return data;
};

export const HabitatGroupModelResponseTransformer: HabitatGroupModelResponseTransformer = data => {
    if (data?.depends) {
        OptionalHabitatRecordModelResponseTransformer(data.depends);
    }
    if (Array.isArray(data?.elements)) {
        data.elements.forEach(HabitatRecordModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListHabitatGroupsResponseTransformer: ListHabitatGroupsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(HabitatGroupModelResponseTransformer);
    }
    return data;
};

export type CreateHabitatGroupResponseTransformer = (data: any) => Promise<CreateHabitatGroupResponse>;

export const CreateHabitatGroupResponseTransformer: CreateHabitatGroupResponseTransformer = async (data) => {
    HabitatGroupModelResponseTransformer(data);
    return data;
};

export type DeleteHabitatGroupResponseTransformer = (data: any) => Promise<DeleteHabitatGroupResponse>;

export const DeleteHabitatGroupResponseTransformer: DeleteHabitatGroupResponseTransformer = async (data) => {
    HabitatGroupModelResponseTransformer(data);
    return data;
};

export type UpdateHabitatGroupResponseTransformer = (data: any) => Promise<UpdateHabitatGroupResponse>;

export const UpdateHabitatGroupResponseTransformer: UpdateHabitatGroupResponseTransformer = async (data) => {
    HabitatGroupModelResponseTransformer(data);
    return data;
};

export type ListInstitutionsResponseTransformer = (data: any) => Promise<ListInstitutionsResponse>;

export type InstitutionModelResponseTransformer = (data: any) => Institution;

export const InstitutionModelResponseTransformer: InstitutionModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListInstitutionsResponseTransformer: ListInstitutionsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(InstitutionModelResponseTransformer);
    }
    return data;
};

export type CreateInstitutionResponseTransformer = (data: any) => Promise<CreateInstitutionResponse>;

export const CreateInstitutionResponseTransformer: CreateInstitutionResponseTransformer = async (data) => {
    InstitutionModelResponseTransformer(data);
    return data;
};

export type DeleteInstitutionResponseTransformer = (data: any) => Promise<DeleteInstitutionResponse>;

export const DeleteInstitutionResponseTransformer: DeleteInstitutionResponseTransformer = async (data) => {
    InstitutionModelResponseTransformer(data);
    return data;
};

export type UpdateInstitutionResponseTransformer = (data: any) => Promise<UpdateInstitutionResponse>;

export const UpdateInstitutionResponseTransformer: UpdateInstitutionResponseTransformer = async (data) => {
    InstitutionModelResponseTransformer(data);
    return data;
};

export type ListSitesResponseTransformer = (data: any) => Promise<ListSitesResponse>;

export type SiteModelResponseTransformer = (data: any) => Site;

export type EventModelResponseTransformer = (data: any) => Event;

export type AbioticMeasurementModelResponseTransformer = (data: any) => AbioticMeasurement;

export type AbioticParameterModelResponseTransformer = (data: any) => AbioticParameter;

export const AbioticParameterModelResponseTransformer: AbioticParameterModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const AbioticMeasurementModelResponseTransformer: AbioticMeasurementModelResponseTransformer = data => {
    if (data?.param) {
        AbioticParameterModelResponseTransformer(data.param);
    }
    return data;
};

export type DateWithPrecisionModelResponseTransformer = (data: any) => DateWithPrecision;

export const DateWithPrecisionModelResponseTransformer: DateWithPrecisionModelResponseTransformer = data => {
    if (data?.date) {
        data.date = new Date(data.date);
    }
    return data;
};

export type SamplingModelResponseTransformer = (data: any) => Sampling;

export type FixativeModelResponseTransformer = (data: any) => Fixative;

export const FixativeModelResponseTransformer: FixativeModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type HabitatModelResponseTransformer = (data: any) => Habitat;

export const HabitatModelResponseTransformer: HabitatModelResponseTransformer = data => {
    if (Array.isArray(data?.incompatible)) {
        data.incompatible.forEach(HabitatRecordModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type SamplingMethodModelResponseTransformer = (data: any) => SamplingMethod;

export const SamplingMethodModelResponseTransformer: SamplingMethodModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type SamplingTargetModelResponseTransformer = (data: any) => SamplingTarget;

export type TaxonModelResponseTransformer = (data: any) => Taxon;

export const TaxonModelResponseTransformer: TaxonModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const SamplingTargetModelResponseTransformer: SamplingTargetModelResponseTransformer = data => {
    if (Array.isArray(data?.target_taxa)) {
        data.target_taxa.forEach(TaxonModelResponseTransformer);
    }
    return data;
};

export const SamplingModelResponseTransformer: SamplingModelResponseTransformer = data => {
    if (Array.isArray(data?.fixatives)) {
        data.fixatives.forEach(FixativeModelResponseTransformer);
    }
    if (Array.isArray(data?.habitats)) {
        data.habitats.forEach(HabitatModelResponseTransformer);
    }
    if (Array.isArray(data?.methods)) {
        data.methods.forEach(SamplingMethodModelResponseTransformer);
    }
    if (data?.target) {
        SamplingTargetModelResponseTransformer(data.target);
    }
    return data;
};

export type OptionalSpottingModelResponseTransformer = (data: any) => OptionalSpotting;

export const OptionalSpottingModelResponseTransformer: OptionalSpottingModelResponseTransformer = data => {
    if (Array.isArray(data?.target_taxa)) {
        data.target_taxa.forEach(TaxonModelResponseTransformer);
    }
    return data;
};

export const EventModelResponseTransformer: EventModelResponseTransformer = data => {
    if (Array.isArray(data?.abiotic_measurements)) {
        data.abiotic_measurements.forEach(AbioticMeasurementModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.performed_on) {
        DateWithPrecisionModelResponseTransformer(data.performed_on);
    }
    if (Array.isArray(data?.samplings)) {
        data.samplings.forEach(SamplingModelResponseTransformer);
    }
    if (data?.spotting) {
        OptionalSpottingModelResponseTransformer(data.spotting);
    }
    return data;
};

export const SiteModelResponseTransformer: SiteModelResponseTransformer = data => {
    if (Array.isArray(data?.events)) {
        data.events.forEach(EventModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListSitesResponseTransformer: ListSitesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SiteModelResponseTransformer);
    }
    return data;
};

export type GetSiteResponseTransformer = (data: any) => Promise<GetSiteResponse>;

export const GetSiteResponseTransformer: GetSiteResponseTransformer = async (data) => {
    SiteModelResponseTransformer(data);
    return data;
};

export type UpdateSiteResponseTransformer = (data: any) => Promise<UpdateSiteResponse>;

export const UpdateSiteResponseTransformer: UpdateSiteResponseTransformer = async (data) => {
    SiteModelResponseTransformer(data);
    return data;
};

export type ListPersonsResponseTransformer = (data: any) => Promise<ListPersonsResponse>;

export type PersonModelResponseTransformer = (data: any) => Person;

export const PersonModelResponseTransformer: PersonModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListPersonsResponseTransformer: ListPersonsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(PersonModelResponseTransformer);
    }
    return data;
};

export type CreatePersonResponseTransformer = (data: any) => Promise<CreatePersonResponse>;

export const CreatePersonResponseTransformer: CreatePersonResponseTransformer = async (data) => {
    PersonModelResponseTransformer(data);
    return data;
};

export type DeletePersonResponseTransformer = (data: any) => Promise<DeletePersonResponse>;

export const DeletePersonResponseTransformer: DeletePersonResponseTransformer = async (data) => {
    PersonModelResponseTransformer(data);
    return data;
};

export type UpdatePersonResponseTransformer = (data: any) => Promise<UpdatePersonResponse>;

export const UpdatePersonResponseTransformer: UpdatePersonResponseTransformer = async (data) => {
    PersonModelResponseTransformer(data);
    return data;
};

export type ListAbioticParametersResponseTransformer = (data: any) => Promise<ListAbioticParametersResponse>;

export const ListAbioticParametersResponseTransformer: ListAbioticParametersResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(AbioticParameterModelResponseTransformer);
    }
    return data;
};

export type CreateAbioticParameterResponseTransformer = (data: any) => Promise<CreateAbioticParameterResponse>;

export const CreateAbioticParameterResponseTransformer: CreateAbioticParameterResponseTransformer = async (data) => {
    AbioticParameterModelResponseTransformer(data);
    return data;
};

export type ListFixativesResponseTransformer = (data: any) => Promise<ListFixativesResponse>;

export const ListFixativesResponseTransformer: ListFixativesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(FixativeModelResponseTransformer);
    }
    return data;
};

export type CreateFixativeResponseTransformer = (data: any) => Promise<CreateFixativeResponse>;

export const CreateFixativeResponseTransformer: CreateFixativeResponseTransformer = async (data) => {
    FixativeModelResponseTransformer(data);
    return data;
};

export type ListSamplingMethodsResponseTransformer = (data: any) => Promise<ListSamplingMethodsResponse>;

export const ListSamplingMethodsResponseTransformer: ListSamplingMethodsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SamplingMethodModelResponseTransformer);
    }
    return data;
};

export type CreateSamplingMethodResponseTransformer = (data: any) => Promise<CreateSamplingMethodResponse>;

export const CreateSamplingMethodResponseTransformer: CreateSamplingMethodResponseTransformer = async (data) => {
    SamplingMethodModelResponseTransformer(data);
    return data;
};

export type ListGenesResponseTransformer = (data: any) => Promise<ListGenesResponse>;

export type GeneModelResponseTransformer = (data: any) => Gene;

export const GeneModelResponseTransformer: GeneModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListGenesResponseTransformer: ListGenesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(GeneModelResponseTransformer);
    }
    return data;
};

export type CreateGeneResponseTransformer = (data: any) => Promise<CreateGeneResponse>;

export const CreateGeneResponseTransformer: CreateGeneResponseTransformer = async (data) => {
    GeneModelResponseTransformer(data);
    return data;
};

export type GetTaxonomyResponseTransformer = (data: any) => Promise<GetTaxonomyResponse>;

export type TaxonomyModelResponseTransformer = (data: any) => Taxonomy;

export type OptionalTaxonModelResponseTransformer = (data: any) => OptionalTaxon;

export const OptionalTaxonModelResponseTransformer: OptionalTaxonModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const TaxonomyModelResponseTransformer: TaxonomyModelResponseTransformer = data => {
    if (Array.isArray(data?.children)) {
        data.children.forEach(TaxonomyModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.parent) {
        OptionalTaxonModelResponseTransformer(data.parent);
    }
    return data;
};

export const GetTaxonomyResponseTransformer: GetTaxonomyResponseTransformer = async (data) => {
    TaxonomyModelResponseTransformer(data);
    return data;
};

export type ListTaxaResponseTransformer = (data: any) => Promise<ListTaxaResponse>;

export type TaxonWithParentRefModelResponseTransformer = (data: any) => TaxonWithParentRef;

export const TaxonWithParentRefModelResponseTransformer: TaxonWithParentRefModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListTaxaResponseTransformer: ListTaxaResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaxonWithParentRefModelResponseTransformer);
    }
    return data;
};

export type CreateTaxonResponseTransformer = (data: any) => Promise<CreateTaxonResponse>;

export type TaxonWithRelativesModelResponseTransformer = (data: any) => TaxonWithRelatives;

export const TaxonWithRelativesModelResponseTransformer: TaxonWithRelativesModelResponseTransformer = data => {
    if (Array.isArray(data?.children)) {
        data.children.forEach(TaxonModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.parent) {
        OptionalTaxonModelResponseTransformer(data.parent);
    }
    return data;
};

export const CreateTaxonResponseTransformer: CreateTaxonResponseTransformer = async (data) => {
    TaxonWithRelativesModelResponseTransformer(data);
    return data;
};

export type DeleteTaxonResponseTransformer = (data: any) => Promise<DeleteTaxonResponse>;

export const DeleteTaxonResponseTransformer: DeleteTaxonResponseTransformer = async (data) => {
    TaxonWithRelativesModelResponseTransformer(data);
    return data;
};

export type GetTaxonResponseTransformer = (data: any) => Promise<GetTaxonResponse>;

export type TaxonWithLineageModelResponseTransformer = (data: any) => TaxonWithLineage;

export type LineageModelResponseTransformer = (data: any) => Lineage;

export const LineageModelResponseTransformer: LineageModelResponseTransformer = data => {
    if (data?.class) {
        OptionalTaxonModelResponseTransformer(data.class);
    }
    if (data?.family) {
        OptionalTaxonModelResponseTransformer(data.family);
    }
    if (data?.genus) {
        OptionalTaxonModelResponseTransformer(data.genus);
    }
    if (data?.kingdom) {
        OptionalTaxonModelResponseTransformer(data.kingdom);
    }
    if (data?.order) {
        OptionalTaxonModelResponseTransformer(data.order);
    }
    if (data?.phylum) {
        OptionalTaxonModelResponseTransformer(data.phylum);
    }
    if (data?.species) {
        OptionalTaxonModelResponseTransformer(data.species);
    }
    if (data?.subspecies) {
        OptionalTaxonModelResponseTransformer(data.subspecies);
    }
    return data;
};

export const TaxonWithLineageModelResponseTransformer: TaxonWithLineageModelResponseTransformer = data => {
    if (Array.isArray(data?.children)) {
        data.children.forEach(TaxonModelResponseTransformer);
    }
    if (data?.lineage) {
        LineageModelResponseTransformer(data.lineage);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.parent) {
        OptionalTaxonModelResponseTransformer(data.parent);
    }
    return data;
};

export const GetTaxonResponseTransformer: GetTaxonResponseTransformer = async (data) => {
    TaxonWithLineageModelResponseTransformer(data);
    return data;
};

export type UpdateTaxonResponseTransformer = (data: any) => Promise<UpdateTaxonResponse>;

export const UpdateTaxonResponseTransformer: UpdateTaxonResponseTransformer = async (data) => {
    TaxonModelResponseTransformer(data);
    return data;
};

export type ListAnchorsResponseTransformer = (data: any) => Promise<ListAnchorsResponse>;

export const ListAnchorsResponseTransformer: ListAnchorsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaxonWithParentRefModelResponseTransformer);
    }
    return data;
};