// This file is auto-generated by @hey-api/openapi-ts

export type AuthenticationResponse = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  User: User
  messages: Array<string>
  /**
   * JSON Web Token
   */
  token: string
}

export type Country = {
  code: string
  id: string
  name: string
  nbLocalities: number
}

export type CurrentUserResponse = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  /**
   * JSON Web Token
   */
  token: string
  user: User
}

export type ErrorDetail = {
  /**
   * Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
   */
  location?: string
  /**
   * Error message text
   */
  message?: string
  /**
   * The value at the given location
   */
  value?: unknown
}

export type ErrorModel = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   */
  detail?: string
  /**
   * Optional list of individual error details
   */
  errors?: Array<ErrorDetail>
  /**
   * A URI reference that identifies the specific occurrence of the problem.
   */
  instance?: string
  /**
   * HTTP status code
   */
  status?: number
  /**
   * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
   */
  title?: string
  /**
   * A URI reference to human-readable documentation for the error.
   */
  type?: string
}

export type ImportProcess = {
  GBIF_ID: number
  done: boolean
  error: unknown
  expected: number
  imported: number
  name: string
  rank: TaxonRank
  started: Date
}

export type ImportRequestGbif = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  /**
   * Import whole clade, including the taxon descendants
   */
  children: boolean
  /**
   * Target GBIF taxon key
   */
  key: number
}

export type Institution = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  code: string
  description?: string
  id: string
  kind: InstitutionKind
  meta: Meta
  name: string
  /**
   * Known members of this institution
   */
  people?: Array<PersonInner>
}

export type InstitutionInner = {
  code: string
  description?: string
  id: string
  kind: InstitutionKind
  name: string
}

export type InstitutionInput = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  code: string
  description?: string
  kind: InstitutionKind
  name: string
}

export type InstitutionKind = 'Lab' | 'FundingAgency' | 'SequencingPlatform' | 'Other'

export type InstitutionUpdate = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  code?: string
  description?: string
  kind?: InstitutionKind
  name?: string
}

export type Meta = {
  created: Date
  created_by: UserShortIdentity
  created_by_user: OptionalUser
  last_updated: Date
  modified: Date
  updated_by: UserShortIdentity
  updated_by_user: OptionalUser
}

export type OptionalPerson = {
  alias: string
  comment: string
  contact: string
  first_name: string
  full_name: string
  id: string
  last_name: string
  role: UserRole
}

export type OptionalUser = {
  email: string
  email_confirmed: boolean
  id: string
  identity: OptionalPerson
  is_active: boolean
  login: string
  role: UserRole
}

export type PasswordInput = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  password: string
  password_confirmation: string
}

export type Person = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  alias: string
  comment: string
  contact: string
  first_name: string
  full_name: string
  id: string
  institutions: Array<InstitutionInner>
  last_name: string
  meta: Meta
  role: UserRole
}

export type PersonInner = {
  alias: string
  comment: string
  contact: string
  first_name: string
  full_name: string
  id: string
  last_name: string
  role: UserRole
}

export type PersonInput = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  alias?: string
  comment?: string
  contact?: string
  first_name: string
  institutions: Array<string>
  last_name: string
}

export type PersonStruct = {
  first_name: string
  institution?: string
  last_name: string
}

export type PersonUpdate = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  alias?: string
  comment?: string
  contact?: string
  first_name?: string
  institutions?: Array<string>
  last_name?: string
}

export type RegisterInputBody = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  /**
   * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
   */
  handler?: Url
  identity: PersonStruct
  motive: string
  user: UserInput
}

export type RequestPasswordResetInputBody = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  email: string
  /**
   * A URL where a form to set the new password is available
   */
  handler?: Url
}

export type ResendEmailConfirmationInputBody = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  email: string
  /**
   * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
   */
  handler?: Url
}

export type Taxon = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  GBIF_ID: number
  anchor: boolean
  authorship: string
  code: string
  comment: string
  id: string
  meta: Meta
  name: string
  rank: TaxonRank
  status: TaxonStatus
}

export type TaxonInput = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  authorship?: string
  code?: string
  comment?: string
  name: string
  parent: string
  rank: TaxonRank
  status: TaxonStatus
}

export type TaxonRank =
  | 'Kingdom'
  | 'Phylum'
  | 'Class'
  | 'Family'
  | 'Genus'
  | 'Species'
  | 'Subspecies'

export type TaxonStatus = 'Accepted' | 'Synonym' | 'Unclassified'

export type TaxonUpdate = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  GBIF_ID?: number
  authorship?: string
  code?: string
  name?: string
  parent?: string
  rank?: string
  status?: string
}

export type TaxonWithRelatives = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  GBIF_ID: number
  anchor: boolean
  authorship: string
  children?: Array<Taxon>
  code: string
  comment: string
  id: string
  meta: Meta
  name: string
  parent: TaxonWithRelativesParentStruct
  rank: TaxonRank
  status: TaxonStatus
}

export type TaxonWithRelativesParentStruct = {
  GBIF_ID: number
  anchor: boolean
  authorship: string
  code: string
  comment: string
  id: string
  meta: Meta
  name: string
  rank: TaxonRank
  status: TaxonStatus
}

export type Url = string | null

export type UpdatePasswordInput = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  new_password: PasswordInput
  password: string
}

export type User = {
  email: string
  email_confirmed: boolean
  id: string
  identity: OptionalPerson
  is_active: boolean
  login: string
  role: UserRole
}

export type UserCredentials = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  identifier: string
  password: string
}

export type UserInput = {
  /**
   * A URL to the JSON Schema for this object.
   */
  readonly $schema?: string
  email: string
  login: string
  password: string
  password_confirmation: string
}

export type UserRole = 'Visitor' | 'Contributor' | 'Maintainer' | 'Admin'

export type UserShortIdentity = {
  alias: string
  name: string
}

export type $OpenApiTs = {
  '/account': {
    get: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
      }
      res: {
        /**
         * OK
         */
        200: CurrentUserResponse
        /**
         * Unauthorized
         */
        401: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/email-confirmation': {
    get: {
      req: {
        token?: string
      }
      res: {
        /**
         * OK
         */
        200: AuthenticationResponse
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/email-confirmation/resend': {
    post: {
      req: {
        requestBody: ResendEmailConfirmationInputBody
      }
      res: {
        /**
         * No Content
         */
        204: void
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/forgotten-password': {
    post: {
      req: {
        requestBody: RequestPasswordResetInputBody
      }
      res: {
        /**
         * No Content
         */
        204: void
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/login': {
    post: {
      req: {
        requestBody: UserCredentials
      }
      res: {
        /**
         * OK
         */
        200: AuthenticationResponse
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/logout': {
    post: {
      res: {
        /**
         * No Content
         */
        204: string
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/password': {
    post: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        requestBody: UpdatePasswordInput
      }
      res: {
        /**
         * No Content
         */
        204: void
        /**
         * Unauthorized
         */
        401: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/password-reset/{token}': {
    get: {
      req: {
        token: string
      }
      res: {
        /**
         * No Content
         */
        204: void
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    post: {
      req: {
        requestBody: PasswordInput
        token: string
      }
      res: {
        /**
         * No Content
         */
        204: void
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/register': {
    post: {
      req: {
        requestBody: RegisterInputBody
      }
      res: {
        /**
         * Created
         */
        201: unknown
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/account/register/{token}': {
    post: {
      req: {
        requestBody: UserInput
        token: string
      }
      res: {
        /**
         * OK
         */
        200: AuthenticationResponse
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/anchors/': {
    get: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
      }
      res: {
        /**
         * OK
         */
        200: Array<Taxon>
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/import/taxonomy': {
    put: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        requestBody: ImportRequestGbif
      }
      res: {
        /**
         * Error
         */
        200: ErrorModel
        /**
         * No Content
         */
        204: void
      }
    }
  }
  '/import/taxonomy/monitor': {
    get: {
      res: {
        /**
         * Error
         */
        200: ErrorModel
      }
    }
  }
  '/countries': {
    get: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
      }
      res: {
        /**
         * OK
         */
        200: Array<Country>
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/institutions': {
    get: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
      }
      res: {
        /**
         * OK
         */
        200: Array<Institution>
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    post: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        requestBody: InstitutionInput
      }
      res: {
        /**
         * OK
         */
        200: Institution
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/institutions/{code}': {
    delete: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        code: string
      }
      res: {
        /**
         * OK
         */
        200: Institution
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    patch: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        code: string
        requestBody: InstitutionUpdate
      }
      res: {
        /**
         * OK
         */
        200: Institution
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/persons': {
    get: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
      }
      res: {
        /**
         * OK
         */
        200: Array<Person>
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    post: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        requestBody: PersonInput
      }
      res: {
        /**
         * OK
         */
        200: Person
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/persons/{id}': {
    delete: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        id: string
      }
      res: {
        /**
         * OK
         */
        200: Person
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    patch: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        id: string
        requestBody: PersonUpdate
      }
      res: {
        /**
         * OK
         */
        200: Person
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/taxonomy': {
    get: {
      req: {
        anchor?: boolean
        pattern?: string
        rank?: TaxonRank
        status?: TaxonStatus
      }
      res: {
        /**
         * OK
         */
        200: Array<Taxon>
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    post: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        requestBody: TaxonInput
      }
      res: {
        /**
         * OK
         */
        200: TaxonWithRelatives
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
  '/taxonomy/{code}': {
    delete: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        code: string
      }
      res: {
        /**
         * OK
         */
        200: Taxon
        /**
         * Unauthorized
         */
        401: ErrorModel
        /**
         * Not Found
         */
        404: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    get: {
      req: {
        code: string
      }
      res: {
        /**
         * OK
         */
        200: TaxonWithRelatives
        /**
         * Not Found
         */
        404: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
    patch: {
      req: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        authorization?: string
        /**
         * Session cookie containing JWT
         */
        authToken?: string
        code: string
        requestBody: TaxonUpdate
      }
      res: {
        /**
         * OK
         */
        200: TaxonWithRelatives
        /**
         * Bad Request
         */
        400: ErrorModel
        /**
         * Unauthorized
         */
        401: ErrorModel
        /**
         * Not Found
         */
        404: ErrorModel
        /**
         * Unprocessable Entity
         */
        422: ErrorModel
        /**
         * Internal Server Error
         */
        500: ErrorModel
      }
    }
  }
}
