// This file is auto-generated by @hey-api/openapi-ts

export type AbioticMeasurement = {
    id: string;
    param: AbioticParameter;
    value: number;
};

export type AbioticParameter = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
    unit: string;
};

export type AbioticParameterInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
    unit: string;
};

export type AbioticParameterUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    label?: string;
    unit: string;
};

export type Article = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authors: Array<(string)>;
    code: string;
    comments?: string;
    doi?: string;
    id: string;
    journal?: string;
    meta: Meta;
    original_source: boolean;
    title?: string;
    verbatim?: string;
    year: number;
};

export type ArticleInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authors: Array<(string)>;
    code?: string;
    comments?: string;
    doi?: string;
    journal?: string;
    title?: string;
    verbatim?: string;
    year: number;
};

export type ArticleUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authors?: Array<(string)>;
    code?: string;
    comments?: (string) | null;
    doi?: (string) | null;
    journal?: (string) | null;
    title?: (string) | null;
    verbatim?: (string) | null;
    year?: number;
};

export type Assertion = {
    group?: Group;
    label?: string;
    name?: string;
    value?: string;
};

export type AuthenticationResponse = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * JSON Web Token
     */
    auth_token: string;
    /**
     * Time at which auth token expires
     */
    auth_token_expiration: Date;
    messages: Array<(string)>;
    /**
     * Session refresh token
     */
    refresh_token: string;
    user: User;
};

export type BioMaterial = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    category: OccurrenceCategory;
    code: string;
    code_history?: Array<CodeHistory>;
    comments: string;
    external?: OptionalExternalBioMatSpecific;
    has_sequences: boolean;
    id: string;
    identification: Identification;
    is_congruent: boolean;
    is_homogenous: boolean;
    is_type: boolean;
    meta: Meta;
    published_in: Array<Article>;
    sampling: SamplingInner;
};

export type BioMaterialWithDetails = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    category: OccurrenceCategory;
    code: string;
    code_history?: Array<CodeHistory>;
    comments: string;
    event: EventInner;
    external?: OptionalExternalBioMatSpecific;
    has_sequences: boolean;
    id: string;
    identification: Identification;
    is_congruent: boolean;
    is_homogenous: boolean;
    is_type: boolean;
    meta: Meta;
    published_in: Array<Article>;
    sampling: Sampling;
};

export type ClinicalTrailNumber = {
    'clinical-trail-number'?: string;
    registry?: string;
    type?: string;
};

export type CodeHistory = {
    code: string;
    time: Date;
};

export type CompositeDate = {
    day?: number;
    month?: number;
    year?: number;
};

export type ContentDomain = {
    'crossmark-restriction'?: boolean;
    domain?: Array<(string)>;
};

export type Coordinates = {
    latitude: number;
    longitude: number;
    /**
     * Where the coordinates point to
     */
    precision: CoordinatesPrecision;
};

export type CoordinatesPrecision = '<100m' | '<1km' | '<10km' | '10-100km' | 'Unknown';

export type Country = {
    code: string;
    id: string;
    name: string;
};

export type CrossRefPerson = {
    ORCID?: string;
    affiliation?: Array<Organization>;
    'authenticated-orcid'?: boolean;
    family?: string;
    given?: string;
    name?: string;
    prefix?: string;
    sequence?: string;
    suffix?: string;
};

export type CurrentUserResponse = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * JSON Web Token
     */
    auth_token: string;
    /**
     * Time at which auth token expires
     */
    auth_token_expiration: Date;
    /**
     * Session refresh token
     */
    refresh_token: string;
    user: User;
};

export type Dataset = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description: string;
    id: string;
    label: string;
    maintainers: Array<PersonUser>;
    meta: Meta;
    sites: Array<SiteItem>;
    slug: string;
};

export type DatasetInner = {
    description: string;
    id: string;
    label: string;
    slug: string;
};

export type DatasetInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description?: string;
    label: string;
    /**
     * Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.
     */
    maintainers: Array<(string)>;
    /**
     * New sites to include in the dataset
     */
    new_sites?: Array<SiteInput>;
    /**
     * Existing site codes to include in the dataset
     */
    sites?: Array<(string)>;
};

export type DatasetUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    description?: (string) | null;
    label?: string;
    /**
     * Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.
     */
    maintainers?: Array<(string)>;
};

export type DateObject = {
    'date-parts'?: Array<Array<(number)>>;
    'date-time'?: string;
    timestamp?: number;
};

export type DatePrecision = 'Day' | 'Month' | 'Year' | 'Unknown';

export type DateRange = {
    'end-date'?: DateObject;
    'start-date'?: DateObject;
};

export type DateWithPrecision = {
    date?: Date;
    precision: DatePrecision;
};

export type DateWithPrecisionInput = {
    date: CompositeDate;
    precision: DatePrecision;
};

export type EmailSettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    from_address: string;
    from_name: string;
    /**
     * SMTP domain that handles email sending
     */
    host: string;
    /**
     * SMTP password
     */
    password: string;
    /**
     * SMTP port
     */
    port: number;
    /**
     * SMTP login
     */
    user: string;
};

export type EmailSettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    from_address: string;
    from_name: string;
    /**
     * SMTP domain that handles email sending
     */
    host: string;
    /**
     * SMTP password
     */
    password: string;
    /**
     * SMTP port
     */
    port: number;
    /**
     * SMTP login
     */
    user: string;
};

export type ErrorDetail = {
    /**
     * Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
     */
    location?: string;
    /**
     * Error message text
     */
    message?: string;
    /**
     * The value at the given location
     */
    value?: unknown;
};

export type ErrorModel = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string;
    /**
     * Optional list of individual error details
     */
    errors?: Array<ErrorDetail>;
    /**
     * A URI reference that identifies the specific occurrence of the problem.
     */
    instance?: string;
    /**
     * HTTP status code
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
     */
    title?: string;
    /**
     * A URI reference to human-readable documentation for the error.
     */
    type?: string;
};

export type Event = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    abiotic_measurements: Array<AbioticMeasurement>;
    code: string;
    id: string;
    meta: Meta;
    performed_by: Array<PersonUser>;
    performed_on: DateWithPrecision;
    programs?: Array<ProgramInner>;
    samplings: Array<Sampling>;
    site: SiteInfo;
    spotting: Spotting;
};

export type EventInner = {
    code: string;
    id: string;
    performed_on: DateWithPrecision;
    site: SiteInfo;
};

export type EventInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    performed_by: Array<(string)>;
    performed_on: DateWithPrecisionInput;
    programs?: Array<(string)>;
};

export type EventUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    performed_by?: Array<(string)>;
    performed_on?: DateWithPrecisionInput;
    programs?: Array<(string)> | null;
};

export type ExternalBioMatContent = {
    sequences: Array<ExternalBioMatSequence>;
    specimen: string;
};

export type ExternalBioMatSequence = {
    accession_number: string;
    code: string;
    comments: string;
    gene: Gene;
    id: string;
    identification: Identification;
    label: string;
    legacy: OptionalLegacySeqId;
    origin: ExtSeqOrigin;
    original_taxon: string;
    published_in: Array<Article>;
    referenced_in: Array<SeqReference>;
    sequence: string;
    specimen_identifier: string;
};

export type ExternalBioMatSpecific = {
    archive: SpecimenVoucher;
    comments: string;
    content?: Array<ExternalBioMatContent>;
    content_description?: string;
    original_link?: string;
    original_taxon?: string;
    quantity: Quantity;
};

export type ExtSeqOrigin = 'Lab' | 'DB' | 'PersCom';

export type ExtSeqSpecifics = {
    origin: ExtSeqOrigin;
    original_taxon: string;
    published_in?: OptionalArticle;
    referenced_in?: Array<SeqReference>;
    source_sample: OptionalBioMaterial;
    specimen_identifier: string;
};

export type Fixative = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
};

export type FixativeInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
};

export type FixativeUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    label?: string;
};

export type Funder = {
    DOI?: string;
    award?: Array<(string)>;
    'doi-asserted-by'?: string;
    name?: string;
};

export type Gene = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    is_MOTU_delimiter: boolean;
    label: string;
    meta: Meta;
};

export type GeneInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    is_MOTU_delimiter?: boolean;
    label: string;
};

export type GeneUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    is_MOTU_delimiter?: boolean;
    label?: string;
};

export type Group = {
    label?: string;
    name?: string;
};

export type Habitat = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
    meta: Meta;
};

export type HabitatGroup = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    depends: OptionalHabitatRecord;
    elements: Array<HabitatRecord>;
    exclusive_elements: boolean;
    id: string;
    /**
     * Name for the group of habitat tags
     */
    label: string;
    meta: Meta;
};

export type HabitatGroupInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Habitat tag that this group is a refinement of
     */
    depends?: string;
    elements: Array<HabitatInput>;
    exclusive_elements?: boolean;
    /**
     * Name for the group of habitat tags
     */
    label: string;
};

export type HabitatGroupUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    create_tags?: Array<HabitatInput>;
    delete_tags?: Array<(string)>;
    depends?: (string) | null;
    exclusive_elements?: boolean;
    label?: string;
    update_tags?: {
        [key: string]: HabitatUpdate;
    };
};

export type HabitatInput = {
    /**
     * Optional habitat description
     */
    description?: string;
    /**
     * A short label for the habitat.
     */
    label: string;
};

export type HabitatRecord = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
};

export type HabitatUpdate = {
    description?: (string) | null;
    label?: string;
};

export type Identification = {
    id: string;
    identified_by: OptionalPerson;
    identified_on: DateWithPrecision;
    meta: Meta;
    taxon: Taxon;
};

export type Identifier = {
    'asserted-by'?: string;
    id?: string;
    'id-type'?: string;
    label?: string;
    name?: string;
    type?: string;
    value?: string;
};

export type ImportProcess = {
    GBIF_ID: number;
    done: boolean;
    error: unknown;
    expected: number;
    imported: number;
    name: string;
    rank: TaxonRank;
    started: Date;
};

export type ImportRequestGbif = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Import whole clade, including the taxon descendants
     */
    children: boolean;
    /**
     * Target GBIF taxon key
     */
    key: number;
};

export type InstanceSettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Whether requests to contribute to the database can be made.
     */
    allow_contributor_signup: boolean;
    description: string;
    /**
     * The name of this database platform
     */
    name: string;
    /**
     * Whether the platform is accessible to unauthenticated users
     */
    public: boolean;
};

export type InstanceSettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Whether requests to contribute to the database can be made.
     */
    allow_contributor_signup: boolean;
    description?: (string) | null;
    /**
     * The name of this database platform
     */
    name: string;
    /**
     * Whether the platform is accessible to unauthenticated users
     */
    public: boolean;
};

export type Institution = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    kind: InstitutionKind;
    meta: Meta;
    name: string;
    /**
     * Known members of this institution
     */
    people?: Array<PersonUser>;
};

export type InstitutionInner = {
    code: string;
    description?: string;
    id: string;
    kind: InstitutionKind;
    name: string;
};

export type InstitutionInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    kind: InstitutionKind;
    name: string;
};

export type InstitutionKind = 'Lab' | 'FundingAgency' | 'SequencingPlatform' | 'Other';

export type InstitutionUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    kind?: (InstitutionKind) | null;
    name?: string;
};

export type InvitationInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * E-mail address of the recipient of the invitation
     */
    email: string;
    /**
     * A URL template with a {token} parameter, which implements the UI to validate the invitation token and fill a registration form.
     */
    handler?: Url;
    role: UserRole;
};

export type InvitationLink = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * The generated URL containing a registration token that can be shared to the invitee.
     */
    invitation_link: Url;
};

export type JournalIssue = {
    issue?: string;
};

export type LegacySeqId = {
    alignment_code: string;
    code: string;
    id: number;
};

export type License = {
    URL?: string;
    'content-version'?: string;
    'delay-in-days'?: number;
    start?: DateObject;
};

export type Lineage = {
    class?: OptionalTaxon;
    family?: OptionalTaxon;
    genus?: OptionalTaxon;
    kingdom?: OptionalTaxon;
    order?: OptionalTaxon;
    phylum?: OptionalTaxon;
    species?: OptionalTaxon;
    subspecies?: OptionalTaxon;
};

export type Link = {
    URL?: string;
    'content-type'?: string;
    'content-version'?: string;
    'intended-application'?: string;
};

export type LogoutInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    refresh_token?: string;
};

export type Message = {
    URL?: string;
    abstract?: string;
    accepted?: DateObject;
    'alternative-id'?: Array<(string)>;
    approved?: DateObject;
    archive?: Array<(string)>;
    'article-number'?: string;
    assertion?: Array<Assertion>;
    author?: Array<CrossRefPerson>;
    chair?: Array<CrossRefPerson>;
    'clinical-trail-number'?: ClinicalTrailNumber;
    'component-number'?: string;
    'container-title'?: Array<(string)>;
    'content-created'?: DateObject;
    'content-domain'?: ContentDomain;
    'content-updated'?: DateObject;
    created?: DateObject;
    degree?: string;
    deposited?: DateObject;
    doi?: string;
    'edition-number'?: string;
    editor?: Array<CrossRefPerson>;
    'free-to-read'?: DateRange;
    funder?: Array<Funder>;
    'group-title'?: string;
    indexed?: DateObject;
    institution?: Array<Organization>;
    isbn?: Array<(string)>;
    'isbn-type'?: Array<Identifier>;
    issn?: Array<(string)>;
    'issn-type'?: Array<Identifier>;
    issue?: string;
    issued?: DateObject;
    'journal-issue'?: JournalIssue;
    language?: string;
    license?: Array<License>;
    link?: Array<Link>;
    member?: string;
    'original-title'?: Array<(string)>;
    page?: string;
    'part-number'?: string;
    posted?: DateObject;
    prefix?: string;
    published?: DateObject;
    'published-online'?: DateObject;
    'published-other'?: DateObject;
    'published-print'?: DateObject;
    publisher?: string;
    'publisher-location'?: string;
    reference?: Array<Reference>;
    'reference-count'?: number;
    relation?: {
        [key: string]: Array<Property>;
    };
    review?: Review;
    score?: number;
    'short-container-title'?: Array<(string)>;
    'short-title'?: Array<(string)>;
    source?: string;
    'standards-body'?: Array<Organization>;
    subject?: Array<(string)>;
    subtitle?: Array<(string)>;
    title?: Array<(string)>;
    translator?: Array<CrossRefPerson>;
    type?: string;
    'update-policy'?: string;
    'updated-to'?: Array<Updated>;
    volume?: string;
};

export type Meta = {
    created: Date;
    created_by?: UserShortIdentity;
    last_updated: Date;
    modified?: Date;
    updated_by?: UserShortIdentity;
};

export type OccurrenceCategory = 'Internal' | 'External';

export type OptionalArticle = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authors: Array<(string)>;
    code: string;
    comments?: string;
    doi?: string;
    id: string;
    journal?: string;
    meta: Meta;
    original_source: boolean;
    title?: string;
    verbatim?: string;
    year: number;
} | null;

export type OptionalBioMaterial = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    category: OccurrenceCategory;
    code: string;
    code_history?: Array<CodeHistory>;
    comments: string;
    external?: OptionalExternalBioMatSpecific;
    has_sequences: boolean;
    id: string;
    identification: Identification;
    is_congruent: boolean;
    is_homogenous: boolean;
    is_type: boolean;
    meta: Meta;
    published_in: Array<Article>;
    sampling: SamplingInner;
} | null;

export type OptionalExternalBioMatSpecific = {
    archive: SpecimenVoucher;
    comments: string;
    content?: Array<ExternalBioMatContent>;
    content_description?: string;
    original_link?: string;
    original_taxon?: string;
    quantity: Quantity;
} | null;

export type OptionalExtSeqSpecifics = {
    origin: ExtSeqOrigin;
    original_taxon: string;
    published_in?: OptionalArticle;
    referenced_in?: Array<SeqReference>;
    source_sample: OptionalBioMaterial;
    specimen_identifier: string;
} | null;

export type OptionalHabitatRecord = {
    /**
     * Optional habitat description
     */
    description?: string;
    id: string;
    incompatible?: Array<HabitatRecord>;
    /**
     * A short label for the habitat.
     */
    label: string;
} | null;

export type OptionalLegacySeqId = {
    alignment_code: string;
    code: string;
    id: number;
} | null;

export type OptionalPerson = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
};

export type OptionalTaxon = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    rank: TaxonRank;
    status: TaxonStatus;
} | null;

export type OptionalUserInner = {
    email: string;
    email_confirmed: boolean;
    id: string;
    login: string;
    role: UserRole;
} | null;

export type Organization = {
    acronym?: Array<(string)>;
    department?: Array<(string)>;
    id?: Array<Identifier>;
    name?: string;
    place?: Array<(string)>;
};

export type PasswordInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Your new password
     */
    password: string;
    /**
     * New password confirmation
     */
    password_confirmation: string;
};

export type PasswordResetRequest = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    /**
     * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
     */
    handler?: string;
};

export type PendingUserRequest = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    created_on: Date;
    email: string;
    email_verified: boolean;
    first_name: string;
    full_name: string;
    id: string;
    institution?: string;
    last_name: string;
    motive?: string;
};

export type PendingUserRequestInput = {
    email: string;
    first_name: string;
    institution?: string;
    last_name: string;
    motive?: string;
};

export type Person = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    institutions: Array<InstitutionInner>;
    last_name: string;
    meta: Meta;
    role?: UserRole;
    user: OptionalUserInner;
};

export type PersonInner = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
};

export type PersonInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias?: string;
    comment?: string;
    contact?: string;
    first_name: string;
    institutions: Array<(string)>;
    last_name: string;
};

export type PersonUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    alias?: string;
    comment?: (string) | null;
    contact?: (string) | null;
    first_name?: string;
    institutions?: Array<(string)>;
    last_name?: string;
};

export type PersonUser = {
    alias: string;
    comment: string;
    contact: string;
    first_name: string;
    full_name: string;
    id: string;
    last_name: string;
    role?: UserRole;
    user: OptionalUserInner;
};

export type Program = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    end_year?: number;
    funding_agencies: Array<InstitutionInner>;
    id: string;
    label: string;
    managers: Array<PersonInner>;
    meta: Meta;
    start_year?: number;
};

export type ProgramInner = {
    code: string;
    description?: string;
    end_year?: number;
    id: string;
    label: string;
    start_year?: number;
};

export type ProgramInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    end_year?: number;
    funding_agencies?: Array<(string)>;
    label: string;
    managers: Array<(string)>;
    start_year?: number;
};

export type ProgramUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    end_year?: (number) | null;
    funding_agencies?: Array<(string)> | null;
    label?: string;
    managers?: Array<(string)> | null;
    start_year?: (number) | null;
};

export type Property = {
    'asserted-by'?: string;
    id?: string;
    'id-type'?: string;
};

export type Quantity = 'Unknown' | 'One' | 'Several' | 'Dozen' | 'Tens' | 'Hundred';

export type Reference = {
    'article-title'?: string;
    author?: string;
    component?: string;
    doi?: string;
    'doi-asserted-by'?: string;
    edition?: string;
    'first-page'?: string;
    isbn?: string;
    'isbn-type'?: string;
    issn?: string;
    'issn-type'?: string;
    issue?: string;
    'journal-title'?: string;
    key?: string;
    'series-title'?: string;
    'standard-designator'?: string;
    'standards-body'?: string;
    unstructured?: string;
    volume?: string;
    'volume-title'?: string;
    year?: string;
};

export type RefreshTokenBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    refresh_token: string;
};

export type RegisterInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    data: PendingUserRequestInput;
    verification_path: string;
};

export type ResendEmailVerificationInputBody = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    /**
     * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
     */
    verification_url: string;
};

export type Review = {
    'competing-interest-statement'?: string;
    language?: string;
    recommendation?: string;
    'revision-round'?: string;
    'running-number'?: string;
    stage?: string;
    type?: string;
};

export type Sampling = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    access_points: Array<(string)>;
    code: string;
    comments?: string;
    /**
     * Sampling duration in minutes
     */
    duration?: number;
    fixatives: Array<Fixative>;
    habitats: Array<Habitat>;
    id: string;
    meta: Meta;
    methods: Array<SamplingMethod>;
    occurring_taxa: Array<Taxon>;
    samples: Array<BioMaterial>;
    target: SamplingTarget;
};

export type SamplingInner = {
    access_points: Array<(string)>;
    code: string;
    comments?: string;
    /**
     * Sampling duration in minutes
     */
    duration?: number;
    fixatives: Array<Fixative>;
    habitats: Array<Habitat>;
    id: string;
    methods: Array<SamplingMethod>;
    target: SamplingTarget;
};

export type SamplingInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    access_points?: Array<(string)>;
    comments?: string;
    /**
     * Sampling duration in minutes
     */
    duration?: number;
    event_id: string;
    fixatives?: Array<(string)>;
    habitats?: Array<(string)>;
    methods?: Array<(string)>;
    target_kind: SamplingTargetKind;
    target_taxa?: Array<(string)>;
};

export type SamplingMethod = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    meta: Meta;
};

export type SamplingMethodInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
};

export type SamplingMethodUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    label?: string;
};

export type SamplingTarget = {
    kind: SamplingTargetKind;
    target_taxa?: Array<Taxon>;
};

export type SamplingTargetKind = 'Community' | 'Unknown' | 'Taxa';

export type SamplingUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    access_points?: Array<(string)> | null;
    comments?: (string) | null;
    /**
     * Sampling duration in minutes
     */
    duration?: (number) | null;
    fixatives?: Array<(string)> | null;
    habitats?: Array<(string)> | null;
    methods?: Array<(string)> | null;
    target_kind?: SamplingTargetKind;
    target_taxa?: Array<(string)> | null;
};

export type SecuritySettings = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Invitation token lifetime in days
     */
    invitation_token_lifetime: number;
    /**
     * The level of complexity required for account passwords.
     */
    min_password_strength: number;
    /**
     * User session lifetime in hours
     */
    refresh_token_lifetime: number;
};

export type SecuritySettingsInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Invitation token lifetime in days
     */
    invitation_token_lifetime: number;
    /**
     * The level of complexity required for account passwords.
     */
    min_password_strength: number;
    /**
     * User session lifetime in hours
     */
    refresh_token_lifetime: number;
};

export type SeqDb = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    id: string;
    label: string;
    link_template: string;
    meta: Meta;
};

export type SeqDbInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code: string;
    description?: string;
    label: string;
    link_template?: string;
};

export type SeqDbUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    code?: string;
    description?: (string) | null;
    label?: string;
    link_template?: (string) | null;
};

export type SeqReference = {
    accession: string;
    db: SeqDb;
    id: string;
    is_origin: boolean;
};

export type Sequence = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    category: OccurrenceCategory;
    code: string;
    comments: string;
    event: EventInner;
    external?: OptionalExtSeqSpecifics;
    gene: Gene;
    id: string;
    identification: Identification;
    label: string;
    legacy: OptionalLegacySeqId;
    meta: Meta;
    sampling: SamplingInner;
    sequence: string;
};

export type Site = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    access_point?: string;
    altitude?: number;
    code: string;
    coordinates: Coordinates;
    country: Country;
    datasets: Array<DatasetInner>;
    description: string;
    events: Array<Event>;
    id: string;
    locality?: string;
    meta: Meta;
    name: string;
};

export type SiteInfo = {
    code: string;
    name: string;
};

export type SiteInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Site altitude in meters
     */
    altitude?: number;
    /**
     * A short unique uppercase alphanumeric identifier
     */
    code: string;
    /**
     * Site coordinates in decimal degrees
     */
    coordinates: Coordinates;
    country_code: string;
    description?: string;
    /**
     * Nearest populated place
     */
    locality?: string;
    name: string;
};

export type SiteItem = {
    access_point?: string;
    altitude?: number;
    code: string;
    coordinates: Coordinates;
    country: Country;
    description: string;
    id: string;
    locality?: string;
    name: string;
};

export type SiteUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    /**
     * Site altitude in meters
     */
    altitude?: (number) | null;
    /**
     * A short unique uppercase alphanumeric identifier
     */
    code?: string;
    /**
     * Site coordinates in decimal degrees
     */
    coordinates?: Coordinates;
    country_code?: string;
    description?: (string) | null;
    /**
     * Nearest populated place
     */
    locality?: (string) | null;
    name?: string;
};

export type SpecimenVoucher = {
    collection: string;
    vouchers: Array<(string)>;
};

export type Spotting = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    comments?: string;
    target_taxa?: Array<Taxon>;
};

export type SpottingUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    comments?: (string) | null;
    target_taxa?: Array<(string)> | null;
};

export type Taxon = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authorship?: string;
    code?: string;
    comment?: string;
    name: string;
    parent: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type Taxonomy = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxonomy>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonRank = 'Kingdom' | 'Phylum' | 'Class' | 'Order' | 'Family' | 'Genus' | 'Species' | 'Subspecies';

export type TaxonStatus = 'Accepted' | 'Unreferenced' | 'Unclassified';

export type TaxonUpdate = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    authorship?: (string) | null;
    code?: string;
    name?: string;
    parent?: string;
    rank?: TaxonRank;
    status?: TaxonStatus;
};

export type TaxonWithLineage = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxon>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    lineage: Lineage;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonWithParentRef = {
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent: string;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type TaxonWithRelatives = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    GBIF_ID?: number;
    anchor: boolean;
    authorship?: string;
    children?: Array<Taxon>;
    children_count: number;
    code: string;
    comment?: string;
    id: string;
    meta: Meta;
    name: string;
    parent?: OptionalTaxon;
    rank: TaxonRank;
    status: TaxonStatus;
};

export type Updated = {
    doi?: string;
    label?: string;
    type?: string;
    updated?: DateObject;
};

export type UpdatePasswordInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    new_password: PasswordInput;
    /**
     * Your current password
     */
    password: string;
};

/**
 * A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.
 */
export type Url = string;

export type User = {
    email: string;
    email_confirmed: boolean;
    id: string;
    identity: OptionalPerson;
    login: string;
    role: UserRole;
};

export type UserCredentials = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    identifier: string;
    password: string;
};

export type UserInner = {
    email: string;
    email_confirmed: boolean;
    id: string;
    login: string;
    role: UserRole;
};

export type UserInput = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    email: string;
    login: string;
    /**
     * Your new password
     */
    password: string;
    /**
     * New password confirmation
     */
    password_confirmation: string;
};

export type UserRole = 'Visitor' | 'Contributor' | 'Maintainer' | 'Admin';

export type UserShortIdentity = {
    alias: string;
    id: string;
    login: string;
    name: string;
} | null;

export type Works = {
    /**
     * A URL to the JSON Schema for this object.
     */
    readonly $schema?: string;
    message?: Message;
    'message-type'?: string;
    'message-version'?: string;
    status?: string;
};

export type CurrentUserData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CurrentUserResponse2 = (CurrentUserResponse | void);

export type CurrentUserError = (ErrorModel);

export type ConfirmEmailData = {
    query?: {
        token?: string;
    };
};

export type ConfirmEmailResponse = (string);

export type ConfirmEmailError = (ErrorModel);

export type ResendEmailVerificationData = {
    body: ResendEmailVerificationInputBody;
};

export type ResendEmailVerificationResponse = (void);

export type ResendEmailVerificationError = (ErrorModel);

export type RequestPasswordResetData = {
    body: PasswordResetRequest;
};

export type RequestPasswordResetResponse = (void);

export type RequestPasswordResetError = (ErrorModel);

export type LoginData = {
    body: UserCredentials;
};

export type LoginResponse = (AuthenticationResponse);

export type LoginError = (ErrorModel);

export type LogoutData = {
    body: LogoutInputBody;
};

export type LogoutResponse = (string);

export type LogoutError = (ErrorModel);

export type UpdatePasswordData = {
    body: UpdatePasswordInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdatePasswordResponse = (void);

export type UpdatePasswordError = (ErrorModel);

export type ValidatePasswordTokenData = {
    query: {
        token: string;
    };
};

export type ValidatePasswordTokenResponse = (void);

export type ValidatePasswordTokenError = (ErrorModel);

export type ResetPasswordData = {
    body: PasswordInput;
    query: {
        token: string;
    };
};

export type ResetPasswordResponse = (void);

export type ResetPasswordError = (ErrorModel);

export type ListPendingUserRequestsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListPendingUserRequestsResponse = (Array<PendingUserRequest>);

export type ListPendingUserRequestsError = (ErrorModel);

export type DeletePendingUserRequestData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type DeletePendingUserRequestResponse = (PendingUserRequest);

export type DeletePendingUserRequestError = (ErrorModel);

export type GetPendingUserRequestData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type GetPendingUserRequestResponse = (PendingUserRequest);

export type GetPendingUserRequestError = (ErrorModel);

export type RefreshSessionData = {
    body: RefreshTokenBody;
};

export type RefreshSessionResponse = (AuthenticationResponse);

export type RefreshSessionError = (ErrorModel);

export type RegisterData = {
    body: RegisterInputBody;
};

export type RegisterResponse = (string);

export type RegisterError = (ErrorModel);

export type ClaimInvitationData = {
    body: UserInput;
    path: {
        token: string;
    };
};

export type ClaimInvitationResponse = (AuthenticationResponse);

export type ClaimInvitationError = (ErrorModel);

export type ListCountriesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListCountriesResponse = (Array<Country>);

export type ListCountriesError = (ErrorModel);

export type ListDatasetsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListDatasetsResponse = (Array<Dataset>);

export type ListDatasetsError = (ErrorModel);

export type CreateDatasetData = {
    body: DatasetInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateDatasetResponse = (Dataset);

export type CreateDatasetError = (ErrorModel);

export type UpdateDatasetData = {
    body: DatasetUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        slug: string;
    };
};

export type UpdateDatasetResponse = (Dataset);

export type UpdateDatasetError = (ErrorModel);

export type GetDatasetData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        slug: string;
    };
};

export type GetDatasetResponse = (Dataset);

export type GetDatasetError = (ErrorModel);

export type DeleteEventData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type DeleteEventResponse = (Event);

export type DeleteEventError = (ErrorModel);

export type UpdateEventData = {
    body: EventUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type UpdateEventResponse = (Event);

export type UpdateEventError = (ErrorModel);

export type UpdateSpottingData = {
    body: SpottingUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type UpdateSpottingResponse = (Spotting);

export type UpdateSpottingError = (ErrorModel);

export type ListProgramsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListProgramsResponse = (Array<Program>);

export type ListProgramsError = (ErrorModel);

export type CreateProgramData = {
    body: ProgramInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateProgramResponse = (Program);

export type CreateProgramError = (ErrorModel);

export type DeleteProgramData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteProgramResponse = (Program);

export type DeleteProgramError = (ErrorModel);

export type UpdateProgramData = {
    body: ProgramUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateProgramResponse = (Program);

export type UpdateProgramError = (ErrorModel);

export type ListHabitatGroupsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListHabitatGroupsResponse = (Array<HabitatGroup>);

export type ListHabitatGroupsError = (ErrorModel);

export type CreateHabitatGroupData = {
    body: HabitatGroupInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateHabitatGroupResponse = (HabitatGroup);

export type CreateHabitatGroupError = (ErrorModel);

export type DeleteHabitatGroupData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteHabitatGroupResponse = (HabitatGroup);

export type DeleteHabitatGroupError = (ErrorModel);

export type UpdateHabitatGroupData = {
    body: HabitatGroupUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateHabitatGroupResponse = (HabitatGroup);

export type UpdateHabitatGroupError = (ErrorModel);

export type ListInstitutionsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListInstitutionsResponse = (Array<Institution>);

export type ListInstitutionsError = (ErrorModel);

export type CreateInstitutionData = {
    body: InstitutionInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateInstitutionResponse = (Institution);

export type CreateInstitutionError = (ErrorModel);

export type DeleteInstitutionData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteInstitutionResponse = (Institution);

export type DeleteInstitutionError = (ErrorModel);

export type UpdateInstitutionData = {
    body: InstitutionUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateInstitutionResponse = (Institution);

export type UpdateInstitutionError = (ErrorModel);

export type ListSitesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSitesResponse = (Array<Site>);

export type ListSitesError = (ErrorModel);

export type CreateSiteData = {
    body: SiteInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSiteResponse = (Site);

export type CreateSiteError = (ErrorModel);

export type GetSiteData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type GetSiteResponse = (Site);

export type GetSiteError = (ErrorModel);

export type UpdateSiteData = {
    body: SiteUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateSiteResponse = (Site);

export type UpdateSiteError = (ErrorModel);

export type CreateEventData = {
    body: EventInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type CreateEventResponse = (Event);

export type CreateEventError = (ErrorModel);

export type ListPersonsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListPersonsResponse = (Array<Person>);

export type ListPersonsError = (ErrorModel);

export type CreatePersonData = {
    body: PersonInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreatePersonResponse = (Person);

export type CreatePersonError = (ErrorModel);

export type DeletePersonData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type DeletePersonResponse = (Person);

export type DeletePersonError = (ErrorModel);

export type UpdatePersonData = {
    body: PersonUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type UpdatePersonResponse = (Person);

export type UpdatePersonError = (ErrorModel);

export type InvitePersonData = {
    body: InvitationInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type InvitePersonResponse = (InvitationLink);

export type InvitePersonError = (ErrorModel);

export type CrossrefData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    query: {
        doi: string;
    };
};

export type CrossrefResponse = (Works);

export type CrossrefError = (ErrorModel);

export type ListArticlesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListArticlesResponse = (Array<Article>);

export type ListArticlesError = (ErrorModel);

export type CreateArticleData = {
    body: ArticleInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateArticleResponse = (Article);

export type CreateArticleError = (ErrorModel);

export type DeleteArticleData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteArticleResponse = (Article);

export type DeleteArticleError = (ErrorModel);

export type UpdateArticleData = {
    body: ArticleUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateArticleResponse = (Article);

export type UpdateArticleError = (ErrorModel);

export type ListBioMaterialData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListBioMaterialResponse = (Array<BioMaterialWithDetails>);

export type ListBioMaterialError = (ErrorModel);

export type DeleteBioMaterialData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteBioMaterialResponse = (BioMaterial);

export type DeleteBioMaterialError = (ErrorModel);

export type GetBioMaterialData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type GetBioMaterialResponse = (BioMaterialWithDetails);

export type GetBioMaterialError = (ErrorModel);

export type ListAbioticParametersData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListAbioticParametersResponse = (Array<AbioticParameter>);

export type ListAbioticParametersError = (ErrorModel);

export type CreateAbioticParameterData = {
    body: AbioticParameterInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateAbioticParameterResponse = (AbioticParameter);

export type CreateAbioticParameterError = (ErrorModel);

export type DeleteAbioticParameterData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteAbioticParameterResponse = (AbioticParameter);

export type DeleteAbioticParameterError = (ErrorModel);

export type UpdateAbioticParameterData = {
    body: AbioticParameterUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateAbioticParameterResponse = (AbioticParameter);

export type UpdateAbioticParameterError = (ErrorModel);

export type GetAccessPointsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type GetAccessPointsResponse = (Array<(string)>);

export type GetAccessPointsError = (ErrorModel);

export type ListFixativesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListFixativesResponse = (Array<Fixative>);

export type ListFixativesError = (ErrorModel);

export type CreateFixativeData = {
    body: FixativeInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateFixativeResponse = (Fixative);

export type CreateFixativeError = (ErrorModel);

export type DeleteFixativeData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteFixativeResponse = (Fixative);

export type DeleteFixativeError = (ErrorModel);

export type UpdateFixativeData = {
    body: FixativeUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateFixativeResponse = (Fixative);

export type UpdateFixativeError = (ErrorModel);

export type ListSamplingMethodsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSamplingMethodsResponse = (Array<SamplingMethod>);

export type ListSamplingMethodsError = (ErrorModel);

export type CreateSamplingMethodData = {
    body: SamplingMethodInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSamplingMethodResponse = (SamplingMethod);

export type CreateSamplingMethodError = (ErrorModel);

export type DeleteSamplingMethodData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteSamplingMethodResponse = (SamplingMethod);

export type DeleteSamplingMethodError = (ErrorModel);

export type UpdateSamplingMethodData = {
    body: SamplingMethodUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateSamplingMethodResponse = (SamplingMethod);

export type UpdateSamplingMethodError = (ErrorModel);

export type CreateSamplingData = {
    body: SamplingInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSamplingResponse = (Sampling);

export type CreateSamplingError = (ErrorModel);

export type DeleteSamplingData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type DeleteSamplingResponse = (Sampling);

export type DeleteSamplingError = (ErrorModel);

export type UpdateSamplingData = {
    body: SamplingUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        id: string;
    };
};

export type UpdateSamplingResponse = (Sampling);

export type UpdateSamplingError = (ErrorModel);

export type ListGenesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListGenesResponse = (Array<Gene>);

export type ListGenesError = (ErrorModel);

export type CreateGeneData = {
    body: GeneInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateGeneResponse = (Gene);

export type CreateGeneError = (ErrorModel);

export type DeleteGeneData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteGeneResponse = (Gene);

export type DeleteGeneError = (ErrorModel);

export type UpdateGeneData = {
    body: GeneUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateGeneResponse = (Gene);

export type UpdateGeneError = (ErrorModel);

export type ListSeqDbsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSeqDbsResponse = (Array<SeqDb>);

export type ListSeqDbsError = (ErrorModel);

export type CreateSeqDbData = {
    body: SeqDbInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateSeqDbResponse = (SeqDb);

export type CreateSeqDbError = (ErrorModel);

export type DeleteSeqDbData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteSeqDbResponse = (SeqDb);

export type DeleteSeqDbError = (ErrorModel);

export type UpdateSeqDbData = {
    body: SeqDbUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateSeqDbResponse = (SeqDb);

export type UpdateSeqDbError = (ErrorModel);

export type ListSequencesData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListSequencesResponse = (Array<Sequence>);

export type ListSequencesError = (ErrorModel);

export type DeleteSequenceData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteSequenceResponse = (Sequence);

export type DeleteSequenceError = (ErrorModel);

export type EmailSettingsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type EmailSettingsResponse = (EmailSettings);

export type EmailSettingsError = (ErrorModel);

export type UpdateEmailSettingsData = {
    body: EmailSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateEmailSettingsResponse = (EmailSettings);

export type UpdateEmailSettingsError = (ErrorModel);

export type TestSmtpData = {
    body: EmailSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type TestSmtpResponse = (boolean);

export type TestSmtpError = (ErrorModel);

export type SetAppIconData = {
    body?: {
        icon: (Blob | File);
    };
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type SetAppIconResponse = (string);

export type SetAppIconError = (ErrorModel);

export type InstanceSettingsResponse = (InstanceSettings);

export type InstanceSettingsError = (ErrorModel);

export type UpdateInstanceSettingsData = {
    body: InstanceSettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateInstanceSettingsResponse = (InstanceSettings);

export type UpdateInstanceSettingsError = (ErrorModel);

export type SecuritySettingsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type SecuritySettingsResponse = (SecuritySettings);

export type SecuritySettingsError = (ErrorModel);

export type UpdateSecuritySettingsData = {
    body: SecuritySettingsInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type UpdateSecuritySettingsResponse = (SecuritySettings);

export type UpdateSecuritySettingsError = (ErrorModel);

export type GetTaxonomyData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    query?: {
        /**
         * Taxon code or UUID
         */
        identifier?: string;
        'max-depth'?: TaxonRank;
    };
};

export type GetTaxonomyResponse = (Taxonomy);

export type GetTaxonomyError = (ErrorModel);

export type ListTaxaData = {
    query?: {
        anchor?: boolean;
        limit?: number;
        parent?: string;
        pattern?: string;
        rank?: TaxonRank;
        status?: TaxonStatus;
    };
};

export type ListTaxaResponse = (Array<TaxonWithParentRef>);

export type ListTaxaError = (ErrorModel);

export type CreateTaxonData = {
    body: TaxonInput;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type CreateTaxonResponse = (TaxonWithRelatives);

export type CreateTaxonError = (ErrorModel);

export type DeleteTaxonData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type DeleteTaxonResponse = (TaxonWithRelatives);

export type DeleteTaxonError = (ErrorModel);

export type GetTaxonData = {
    path: {
        code: string;
    };
};

export type GetTaxonResponse = (TaxonWithLineage);

export type GetTaxonError = (ErrorModel);

export type UpdateTaxonData = {
    body: TaxonUpdate;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
    path: {
        code: string;
    };
};

export type UpdateTaxonResponse = (Taxon);

export type UpdateTaxonError = (ErrorModel);

export type ListAnchorsData = {
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ListAnchorsResponse = (Array<TaxonWithParentRef>);

export type ListAnchorsError = (ErrorModel);

export type ImportGbifData = {
    body: ImportRequestGbif;
    headers?: {
        /**
         * Authorization header formatted as "Bearer auth_token". Takes precedence over session cookie if set.
         */
        Authorization?: string;
    };
};

export type ImportGbifResponse = (void);

export type ImportGbifError = (ErrorModel);

export type MonitorGbifResponse = (Array<({
    data: {
        [key: string]: ImportProcess;
    };
    /**
     * The event name.
     */
    event: "state";
    /**
     * The event ID.
     */
    id?: number;
    /**
     * The retry time in milliseconds.
     */
    retry?: number;
})>);

export type MonitorGbifError = (ErrorModel);

export type LoginResponseTransformer = (data: any) => Promise<LoginResponse>;

export type AuthenticationResponseModelResponseTransformer = (data: any) => AuthenticationResponse;

export const AuthenticationResponseModelResponseTransformer: AuthenticationResponseModelResponseTransformer = data => {
    if (data?.auth_token_expiration) {
        data.auth_token_expiration = new Date(data.auth_token_expiration);
    }
    return data;
};

export const LoginResponseTransformer: LoginResponseTransformer = async (data) => {
    AuthenticationResponseModelResponseTransformer(data);
    return data;
};

export type ListPendingUserRequestsResponseTransformer = (data: any) => Promise<ListPendingUserRequestsResponse>;

export type PendingUserRequestModelResponseTransformer = (data: any) => PendingUserRequest;

export const PendingUserRequestModelResponseTransformer: PendingUserRequestModelResponseTransformer = data => {
    if (data?.created_on) {
        data.created_on = new Date(data.created_on);
    }
    return data;
};

export const ListPendingUserRequestsResponseTransformer: ListPendingUserRequestsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(PendingUserRequestModelResponseTransformer);
    }
    return data;
};

export type DeletePendingUserRequestResponseTransformer = (data: any) => Promise<DeletePendingUserRequestResponse>;

export const DeletePendingUserRequestResponseTransformer: DeletePendingUserRequestResponseTransformer = async (data) => {
    PendingUserRequestModelResponseTransformer(data);
    return data;
};

export type GetPendingUserRequestResponseTransformer = (data: any) => Promise<GetPendingUserRequestResponse>;

export const GetPendingUserRequestResponseTransformer: GetPendingUserRequestResponseTransformer = async (data) => {
    PendingUserRequestModelResponseTransformer(data);
    return data;
};

export type RefreshSessionResponseTransformer = (data: any) => Promise<RefreshSessionResponse>;

export const RefreshSessionResponseTransformer: RefreshSessionResponseTransformer = async (data) => {
    AuthenticationResponseModelResponseTransformer(data);
    return data;
};

export type ClaimInvitationResponseTransformer = (data: any) => Promise<ClaimInvitationResponse>;

export const ClaimInvitationResponseTransformer: ClaimInvitationResponseTransformer = async (data) => {
    AuthenticationResponseModelResponseTransformer(data);
    return data;
};

export type ListDatasetsResponseTransformer = (data: any) => Promise<ListDatasetsResponse>;

export type DatasetModelResponseTransformer = (data: any) => Dataset;

export type MetaModelResponseTransformer = (data: any) => Meta;

export const MetaModelResponseTransformer: MetaModelResponseTransformer = data => {
    if (data?.created) {
        data.created = new Date(data.created);
    }
    if (data?.last_updated) {
        data.last_updated = new Date(data.last_updated);
    }
    if (data?.modified) {
        data.modified = new Date(data.modified);
    }
    return data;
};

export const DatasetModelResponseTransformer: DatasetModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListDatasetsResponseTransformer: ListDatasetsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(DatasetModelResponseTransformer);
    }
    return data;
};

export type CreateDatasetResponseTransformer = (data: any) => Promise<CreateDatasetResponse>;

export const CreateDatasetResponseTransformer: CreateDatasetResponseTransformer = async (data) => {
    DatasetModelResponseTransformer(data);
    return data;
};

export type UpdateDatasetResponseTransformer = (data: any) => Promise<UpdateDatasetResponse>;

export const UpdateDatasetResponseTransformer: UpdateDatasetResponseTransformer = async (data) => {
    DatasetModelResponseTransformer(data);
    return data;
};

export type GetDatasetResponseTransformer = (data: any) => Promise<GetDatasetResponse>;

export const GetDatasetResponseTransformer: GetDatasetResponseTransformer = async (data) => {
    DatasetModelResponseTransformer(data);
    return data;
};

export type DeleteEventResponseTransformer = (data: any) => Promise<DeleteEventResponse>;

export type EventModelResponseTransformer = (data: any) => Event;

export type AbioticMeasurementModelResponseTransformer = (data: any) => AbioticMeasurement;

export type AbioticParameterModelResponseTransformer = (data: any) => AbioticParameter;

export const AbioticParameterModelResponseTransformer: AbioticParameterModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const AbioticMeasurementModelResponseTransformer: AbioticMeasurementModelResponseTransformer = data => {
    if (data?.param) {
        AbioticParameterModelResponseTransformer(data.param);
    }
    return data;
};

export type DateWithPrecisionModelResponseTransformer = (data: any) => DateWithPrecision;

export const DateWithPrecisionModelResponseTransformer: DateWithPrecisionModelResponseTransformer = data => {
    if (data?.date) {
        data.date = new Date(data.date);
    }
    return data;
};

export type SamplingModelResponseTransformer = (data: any) => Sampling;

export type FixativeModelResponseTransformer = (data: any) => Fixative;

export const FixativeModelResponseTransformer: FixativeModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type HabitatModelResponseTransformer = (data: any) => Habitat;

export type HabitatRecordModelResponseTransformer = (data: any) => HabitatRecord;

export const HabitatRecordModelResponseTransformer: HabitatRecordModelResponseTransformer = data => {
    if (Array.isArray(data?.incompatible)) {
        data.incompatible.forEach(HabitatRecordModelResponseTransformer);
    }
    return data;
};

export const HabitatModelResponseTransformer: HabitatModelResponseTransformer = data => {
    if (Array.isArray(data?.incompatible)) {
        data.incompatible.forEach(HabitatRecordModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type SamplingMethodModelResponseTransformer = (data: any) => SamplingMethod;

export const SamplingMethodModelResponseTransformer: SamplingMethodModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type TaxonModelResponseTransformer = (data: any) => Taxon;

export const TaxonModelResponseTransformer: TaxonModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type BioMaterialModelResponseTransformer = (data: any) => BioMaterial;

export type CodeHistoryModelResponseTransformer = (data: any) => CodeHistory;

export const CodeHistoryModelResponseTransformer: CodeHistoryModelResponseTransformer = data => {
    if (data?.time) {
        data.time = new Date(data.time);
    }
    return data;
};

export type OptionalExternalBioMatSpecificModelResponseTransformer = (data: any) => OptionalExternalBioMatSpecific;

export type ExternalBioMatContentModelResponseTransformer = (data: any) => ExternalBioMatContent;

export type ExternalBioMatSequenceModelResponseTransformer = (data: any) => ExternalBioMatSequence;

export type GeneModelResponseTransformer = (data: any) => Gene;

export const GeneModelResponseTransformer: GeneModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type IdentificationModelResponseTransformer = (data: any) => Identification;

export const IdentificationModelResponseTransformer: IdentificationModelResponseTransformer = data => {
    if (data?.identified_on) {
        DateWithPrecisionModelResponseTransformer(data.identified_on);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.taxon) {
        TaxonModelResponseTransformer(data.taxon);
    }
    return data;
};

export type ArticleModelResponseTransformer = (data: any) => Article;

export const ArticleModelResponseTransformer: ArticleModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type SeqReferenceModelResponseTransformer = (data: any) => SeqReference;

export type SeqDbModelResponseTransformer = (data: any) => SeqDb;

export const SeqDbModelResponseTransformer: SeqDbModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const SeqReferenceModelResponseTransformer: SeqReferenceModelResponseTransformer = data => {
    if (data?.db) {
        SeqDbModelResponseTransformer(data.db);
    }
    return data;
};

export const ExternalBioMatSequenceModelResponseTransformer: ExternalBioMatSequenceModelResponseTransformer = data => {
    if (data?.gene) {
        GeneModelResponseTransformer(data.gene);
    }
    if (data?.identification) {
        IdentificationModelResponseTransformer(data.identification);
    }
    if (Array.isArray(data?.published_in)) {
        data.published_in.forEach(ArticleModelResponseTransformer);
    }
    if (Array.isArray(data?.referenced_in)) {
        data.referenced_in.forEach(SeqReferenceModelResponseTransformer);
    }
    return data;
};

export const ExternalBioMatContentModelResponseTransformer: ExternalBioMatContentModelResponseTransformer = data => {
    if (Array.isArray(data?.sequences)) {
        data.sequences.forEach(ExternalBioMatSequenceModelResponseTransformer);
    }
    return data;
};

export const OptionalExternalBioMatSpecificModelResponseTransformer: OptionalExternalBioMatSpecificModelResponseTransformer = data => {
    if (Array.isArray(data?.content)) {
        data.content.forEach(ExternalBioMatContentModelResponseTransformer);
    }
    return data;
};

export type SamplingInnerModelResponseTransformer = (data: any) => SamplingInner;

export type SamplingTargetModelResponseTransformer = (data: any) => SamplingTarget;

export const SamplingTargetModelResponseTransformer: SamplingTargetModelResponseTransformer = data => {
    if (Array.isArray(data?.target_taxa)) {
        data.target_taxa.forEach(TaxonModelResponseTransformer);
    }
    return data;
};

export const SamplingInnerModelResponseTransformer: SamplingInnerModelResponseTransformer = data => {
    if (Array.isArray(data?.fixatives)) {
        data.fixatives.forEach(FixativeModelResponseTransformer);
    }
    if (Array.isArray(data?.habitats)) {
        data.habitats.forEach(HabitatModelResponseTransformer);
    }
    if (Array.isArray(data?.methods)) {
        data.methods.forEach(SamplingMethodModelResponseTransformer);
    }
    if (data?.target) {
        SamplingTargetModelResponseTransformer(data.target);
    }
    return data;
};

export const BioMaterialModelResponseTransformer: BioMaterialModelResponseTransformer = data => {
    if (Array.isArray(data?.code_history)) {
        data.code_history.forEach(CodeHistoryModelResponseTransformer);
    }
    if (data?.external) {
        OptionalExternalBioMatSpecificModelResponseTransformer(data.external);
    }
    if (data?.identification) {
        IdentificationModelResponseTransformer(data.identification);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (Array.isArray(data?.published_in)) {
        data.published_in.forEach(ArticleModelResponseTransformer);
    }
    if (data?.sampling) {
        SamplingInnerModelResponseTransformer(data.sampling);
    }
    return data;
};

export const SamplingModelResponseTransformer: SamplingModelResponseTransformer = data => {
    if (Array.isArray(data?.fixatives)) {
        data.fixatives.forEach(FixativeModelResponseTransformer);
    }
    if (Array.isArray(data?.habitats)) {
        data.habitats.forEach(HabitatModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (Array.isArray(data?.methods)) {
        data.methods.forEach(SamplingMethodModelResponseTransformer);
    }
    if (Array.isArray(data?.occurring_taxa)) {
        data.occurring_taxa.forEach(TaxonModelResponseTransformer);
    }
    if (Array.isArray(data?.samples)) {
        data.samples.forEach(BioMaterialModelResponseTransformer);
    }
    if (data?.target) {
        SamplingTargetModelResponseTransformer(data.target);
    }
    return data;
};

export type SpottingModelResponseTransformer = (data: any) => Spotting;

export const SpottingModelResponseTransformer: SpottingModelResponseTransformer = data => {
    if (Array.isArray(data?.target_taxa)) {
        data.target_taxa.forEach(TaxonModelResponseTransformer);
    }
    return data;
};

export const EventModelResponseTransformer: EventModelResponseTransformer = data => {
    if (Array.isArray(data?.abiotic_measurements)) {
        data.abiotic_measurements.forEach(AbioticMeasurementModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.performed_on) {
        DateWithPrecisionModelResponseTransformer(data.performed_on);
    }
    if (Array.isArray(data?.samplings)) {
        data.samplings.forEach(SamplingModelResponseTransformer);
    }
    if (data?.spotting) {
        SpottingModelResponseTransformer(data.spotting);
    }
    return data;
};

export const DeleteEventResponseTransformer: DeleteEventResponseTransformer = async (data) => {
    EventModelResponseTransformer(data);
    return data;
};

export type UpdateEventResponseTransformer = (data: any) => Promise<UpdateEventResponse>;

export const UpdateEventResponseTransformer: UpdateEventResponseTransformer = async (data) => {
    EventModelResponseTransformer(data);
    return data;
};

export type UpdateSpottingResponseTransformer = (data: any) => Promise<UpdateSpottingResponse>;

export const UpdateSpottingResponseTransformer: UpdateSpottingResponseTransformer = async (data) => {
    SpottingModelResponseTransformer(data);
    return data;
};

export type ListProgramsResponseTransformer = (data: any) => Promise<ListProgramsResponse>;

export type ProgramModelResponseTransformer = (data: any) => Program;

export const ProgramModelResponseTransformer: ProgramModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListProgramsResponseTransformer: ListProgramsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(ProgramModelResponseTransformer);
    }
    return data;
};

export type CreateProgramResponseTransformer = (data: any) => Promise<CreateProgramResponse>;

export const CreateProgramResponseTransformer: CreateProgramResponseTransformer = async (data) => {
    ProgramModelResponseTransformer(data);
    return data;
};

export type DeleteProgramResponseTransformer = (data: any) => Promise<DeleteProgramResponse>;

export const DeleteProgramResponseTransformer: DeleteProgramResponseTransformer = async (data) => {
    ProgramModelResponseTransformer(data);
    return data;
};

export type UpdateProgramResponseTransformer = (data: any) => Promise<UpdateProgramResponse>;

export const UpdateProgramResponseTransformer: UpdateProgramResponseTransformer = async (data) => {
    ProgramModelResponseTransformer(data);
    return data;
};

export type ListHabitatGroupsResponseTransformer = (data: any) => Promise<ListHabitatGroupsResponse>;

export type HabitatGroupModelResponseTransformer = (data: any) => HabitatGroup;

export type OptionalHabitatRecordModelResponseTransformer = (data: any) => OptionalHabitatRecord;

export const OptionalHabitatRecordModelResponseTransformer: OptionalHabitatRecordModelResponseTransformer = data => {
    if (Array.isArray(data?.incompatible)) {
        data.incompatible.forEach(HabitatRecordModelResponseTransformer);
    }
    return data;
};

export const HabitatGroupModelResponseTransformer: HabitatGroupModelResponseTransformer = data => {
    if (data?.depends) {
        OptionalHabitatRecordModelResponseTransformer(data.depends);
    }
    if (Array.isArray(data?.elements)) {
        data.elements.forEach(HabitatRecordModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListHabitatGroupsResponseTransformer: ListHabitatGroupsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(HabitatGroupModelResponseTransformer);
    }
    return data;
};

export type CreateHabitatGroupResponseTransformer = (data: any) => Promise<CreateHabitatGroupResponse>;

export const CreateHabitatGroupResponseTransformer: CreateHabitatGroupResponseTransformer = async (data) => {
    HabitatGroupModelResponseTransformer(data);
    return data;
};

export type DeleteHabitatGroupResponseTransformer = (data: any) => Promise<DeleteHabitatGroupResponse>;

export const DeleteHabitatGroupResponseTransformer: DeleteHabitatGroupResponseTransformer = async (data) => {
    HabitatGroupModelResponseTransformer(data);
    return data;
};

export type UpdateHabitatGroupResponseTransformer = (data: any) => Promise<UpdateHabitatGroupResponse>;

export const UpdateHabitatGroupResponseTransformer: UpdateHabitatGroupResponseTransformer = async (data) => {
    HabitatGroupModelResponseTransformer(data);
    return data;
};

export type ListInstitutionsResponseTransformer = (data: any) => Promise<ListInstitutionsResponse>;

export type InstitutionModelResponseTransformer = (data: any) => Institution;

export const InstitutionModelResponseTransformer: InstitutionModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListInstitutionsResponseTransformer: ListInstitutionsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(InstitutionModelResponseTransformer);
    }
    return data;
};

export type CreateInstitutionResponseTransformer = (data: any) => Promise<CreateInstitutionResponse>;

export const CreateInstitutionResponseTransformer: CreateInstitutionResponseTransformer = async (data) => {
    InstitutionModelResponseTransformer(data);
    return data;
};

export type DeleteInstitutionResponseTransformer = (data: any) => Promise<DeleteInstitutionResponse>;

export const DeleteInstitutionResponseTransformer: DeleteInstitutionResponseTransformer = async (data) => {
    InstitutionModelResponseTransformer(data);
    return data;
};

export type UpdateInstitutionResponseTransformer = (data: any) => Promise<UpdateInstitutionResponse>;

export const UpdateInstitutionResponseTransformer: UpdateInstitutionResponseTransformer = async (data) => {
    InstitutionModelResponseTransformer(data);
    return data;
};

export type ListSitesResponseTransformer = (data: any) => Promise<ListSitesResponse>;

export type SiteModelResponseTransformer = (data: any) => Site;

export const SiteModelResponseTransformer: SiteModelResponseTransformer = data => {
    if (Array.isArray(data?.events)) {
        data.events.forEach(EventModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListSitesResponseTransformer: ListSitesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SiteModelResponseTransformer);
    }
    return data;
};

export type CreateSiteResponseTransformer = (data: any) => Promise<CreateSiteResponse>;

export const CreateSiteResponseTransformer: CreateSiteResponseTransformer = async (data) => {
    SiteModelResponseTransformer(data);
    return data;
};

export type GetSiteResponseTransformer = (data: any) => Promise<GetSiteResponse>;

export const GetSiteResponseTransformer: GetSiteResponseTransformer = async (data) => {
    SiteModelResponseTransformer(data);
    return data;
};

export type UpdateSiteResponseTransformer = (data: any) => Promise<UpdateSiteResponse>;

export const UpdateSiteResponseTransformer: UpdateSiteResponseTransformer = async (data) => {
    SiteModelResponseTransformer(data);
    return data;
};

export type CreateEventResponseTransformer = (data: any) => Promise<CreateEventResponse>;

export const CreateEventResponseTransformer: CreateEventResponseTransformer = async (data) => {
    EventModelResponseTransformer(data);
    return data;
};

export type ListPersonsResponseTransformer = (data: any) => Promise<ListPersonsResponse>;

export type PersonModelResponseTransformer = (data: any) => Person;

export const PersonModelResponseTransformer: PersonModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListPersonsResponseTransformer: ListPersonsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(PersonModelResponseTransformer);
    }
    return data;
};

export type CreatePersonResponseTransformer = (data: any) => Promise<CreatePersonResponse>;

export const CreatePersonResponseTransformer: CreatePersonResponseTransformer = async (data) => {
    PersonModelResponseTransformer(data);
    return data;
};

export type DeletePersonResponseTransformer = (data: any) => Promise<DeletePersonResponse>;

export const DeletePersonResponseTransformer: DeletePersonResponseTransformer = async (data) => {
    PersonModelResponseTransformer(data);
    return data;
};

export type UpdatePersonResponseTransformer = (data: any) => Promise<UpdatePersonResponse>;

export const UpdatePersonResponseTransformer: UpdatePersonResponseTransformer = async (data) => {
    PersonModelResponseTransformer(data);
    return data;
};

export type ListArticlesResponseTransformer = (data: any) => Promise<ListArticlesResponse>;

export const ListArticlesResponseTransformer: ListArticlesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(ArticleModelResponseTransformer);
    }
    return data;
};

export type CreateArticleResponseTransformer = (data: any) => Promise<CreateArticleResponse>;

export const CreateArticleResponseTransformer: CreateArticleResponseTransformer = async (data) => {
    ArticleModelResponseTransformer(data);
    return data;
};

export type DeleteArticleResponseTransformer = (data: any) => Promise<DeleteArticleResponse>;

export const DeleteArticleResponseTransformer: DeleteArticleResponseTransformer = async (data) => {
    ArticleModelResponseTransformer(data);
    return data;
};

export type UpdateArticleResponseTransformer = (data: any) => Promise<UpdateArticleResponse>;

export const UpdateArticleResponseTransformer: UpdateArticleResponseTransformer = async (data) => {
    ArticleModelResponseTransformer(data);
    return data;
};

export type ListBioMaterialResponseTransformer = (data: any) => Promise<ListBioMaterialResponse>;

export type BioMaterialWithDetailsModelResponseTransformer = (data: any) => BioMaterialWithDetails;

export type EventInnerModelResponseTransformer = (data: any) => EventInner;

export const EventInnerModelResponseTransformer: EventInnerModelResponseTransformer = data => {
    if (data?.performed_on) {
        DateWithPrecisionModelResponseTransformer(data.performed_on);
    }
    return data;
};

export const BioMaterialWithDetailsModelResponseTransformer: BioMaterialWithDetailsModelResponseTransformer = data => {
    if (Array.isArray(data?.code_history)) {
        data.code_history.forEach(CodeHistoryModelResponseTransformer);
    }
    if (data?.event) {
        EventInnerModelResponseTransformer(data.event);
    }
    if (data?.external) {
        OptionalExternalBioMatSpecificModelResponseTransformer(data.external);
    }
    if (data?.identification) {
        IdentificationModelResponseTransformer(data.identification);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (Array.isArray(data?.published_in)) {
        data.published_in.forEach(ArticleModelResponseTransformer);
    }
    if (data?.sampling) {
        SamplingModelResponseTransformer(data.sampling);
    }
    return data;
};

export const ListBioMaterialResponseTransformer: ListBioMaterialResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(BioMaterialWithDetailsModelResponseTransformer);
    }
    return data;
};

export type DeleteBioMaterialResponseTransformer = (data: any) => Promise<DeleteBioMaterialResponse>;

export const DeleteBioMaterialResponseTransformer: DeleteBioMaterialResponseTransformer = async (data) => {
    BioMaterialModelResponseTransformer(data);
    return data;
};

export type GetBioMaterialResponseTransformer = (data: any) => Promise<GetBioMaterialResponse>;

export const GetBioMaterialResponseTransformer: GetBioMaterialResponseTransformer = async (data) => {
    BioMaterialWithDetailsModelResponseTransformer(data);
    return data;
};

export type ListAbioticParametersResponseTransformer = (data: any) => Promise<ListAbioticParametersResponse>;

export const ListAbioticParametersResponseTransformer: ListAbioticParametersResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(AbioticParameterModelResponseTransformer);
    }
    return data;
};

export type CreateAbioticParameterResponseTransformer = (data: any) => Promise<CreateAbioticParameterResponse>;

export const CreateAbioticParameterResponseTransformer: CreateAbioticParameterResponseTransformer = async (data) => {
    AbioticParameterModelResponseTransformer(data);
    return data;
};

export type DeleteAbioticParameterResponseTransformer = (data: any) => Promise<DeleteAbioticParameterResponse>;

export const DeleteAbioticParameterResponseTransformer: DeleteAbioticParameterResponseTransformer = async (data) => {
    AbioticParameterModelResponseTransformer(data);
    return data;
};

export type UpdateAbioticParameterResponseTransformer = (data: any) => Promise<UpdateAbioticParameterResponse>;

export const UpdateAbioticParameterResponseTransformer: UpdateAbioticParameterResponseTransformer = async (data) => {
    AbioticParameterModelResponseTransformer(data);
    return data;
};

export type ListFixativesResponseTransformer = (data: any) => Promise<ListFixativesResponse>;

export const ListFixativesResponseTransformer: ListFixativesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(FixativeModelResponseTransformer);
    }
    return data;
};

export type CreateFixativeResponseTransformer = (data: any) => Promise<CreateFixativeResponse>;

export const CreateFixativeResponseTransformer: CreateFixativeResponseTransformer = async (data) => {
    FixativeModelResponseTransformer(data);
    return data;
};

export type DeleteFixativeResponseTransformer = (data: any) => Promise<DeleteFixativeResponse>;

export const DeleteFixativeResponseTransformer: DeleteFixativeResponseTransformer = async (data) => {
    FixativeModelResponseTransformer(data);
    return data;
};

export type UpdateFixativeResponseTransformer = (data: any) => Promise<UpdateFixativeResponse>;

export const UpdateFixativeResponseTransformer: UpdateFixativeResponseTransformer = async (data) => {
    FixativeModelResponseTransformer(data);
    return data;
};

export type ListSamplingMethodsResponseTransformer = (data: any) => Promise<ListSamplingMethodsResponse>;

export const ListSamplingMethodsResponseTransformer: ListSamplingMethodsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SamplingMethodModelResponseTransformer);
    }
    return data;
};

export type CreateSamplingMethodResponseTransformer = (data: any) => Promise<CreateSamplingMethodResponse>;

export const CreateSamplingMethodResponseTransformer: CreateSamplingMethodResponseTransformer = async (data) => {
    SamplingMethodModelResponseTransformer(data);
    return data;
};

export type DeleteSamplingMethodResponseTransformer = (data: any) => Promise<DeleteSamplingMethodResponse>;

export const DeleteSamplingMethodResponseTransformer: DeleteSamplingMethodResponseTransformer = async (data) => {
    SamplingMethodModelResponseTransformer(data);
    return data;
};

export type UpdateSamplingMethodResponseTransformer = (data: any) => Promise<UpdateSamplingMethodResponse>;

export const UpdateSamplingMethodResponseTransformer: UpdateSamplingMethodResponseTransformer = async (data) => {
    SamplingMethodModelResponseTransformer(data);
    return data;
};

export type CreateSamplingResponseTransformer = (data: any) => Promise<CreateSamplingResponse>;

export const CreateSamplingResponseTransformer: CreateSamplingResponseTransformer = async (data) => {
    SamplingModelResponseTransformer(data);
    return data;
};

export type DeleteSamplingResponseTransformer = (data: any) => Promise<DeleteSamplingResponse>;

export const DeleteSamplingResponseTransformer: DeleteSamplingResponseTransformer = async (data) => {
    SamplingModelResponseTransformer(data);
    return data;
};

export type UpdateSamplingResponseTransformer = (data: any) => Promise<UpdateSamplingResponse>;

export const UpdateSamplingResponseTransformer: UpdateSamplingResponseTransformer = async (data) => {
    SamplingModelResponseTransformer(data);
    return data;
};

export type ListGenesResponseTransformer = (data: any) => Promise<ListGenesResponse>;

export const ListGenesResponseTransformer: ListGenesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(GeneModelResponseTransformer);
    }
    return data;
};

export type CreateGeneResponseTransformer = (data: any) => Promise<CreateGeneResponse>;

export const CreateGeneResponseTransformer: CreateGeneResponseTransformer = async (data) => {
    GeneModelResponseTransformer(data);
    return data;
};

export type DeleteGeneResponseTransformer = (data: any) => Promise<DeleteGeneResponse>;

export const DeleteGeneResponseTransformer: DeleteGeneResponseTransformer = async (data) => {
    GeneModelResponseTransformer(data);
    return data;
};

export type UpdateGeneResponseTransformer = (data: any) => Promise<UpdateGeneResponse>;

export const UpdateGeneResponseTransformer: UpdateGeneResponseTransformer = async (data) => {
    GeneModelResponseTransformer(data);
    return data;
};

export type ListSeqDbsResponseTransformer = (data: any) => Promise<ListSeqDbsResponse>;

export const ListSeqDbsResponseTransformer: ListSeqDbsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SeqDbModelResponseTransformer);
    }
    return data;
};

export type CreateSeqDbResponseTransformer = (data: any) => Promise<CreateSeqDbResponse>;

export const CreateSeqDbResponseTransformer: CreateSeqDbResponseTransformer = async (data) => {
    SeqDbModelResponseTransformer(data);
    return data;
};

export type DeleteSeqDbResponseTransformer = (data: any) => Promise<DeleteSeqDbResponse>;

export const DeleteSeqDbResponseTransformer: DeleteSeqDbResponseTransformer = async (data) => {
    SeqDbModelResponseTransformer(data);
    return data;
};

export type UpdateSeqDbResponseTransformer = (data: any) => Promise<UpdateSeqDbResponse>;

export const UpdateSeqDbResponseTransformer: UpdateSeqDbResponseTransformer = async (data) => {
    SeqDbModelResponseTransformer(data);
    return data;
};

export type ListSequencesResponseTransformer = (data: any) => Promise<ListSequencesResponse>;

export type SequenceModelResponseTransformer = (data: any) => Sequence;

export type OptionalExtSeqSpecificsModelResponseTransformer = (data: any) => OptionalExtSeqSpecifics;

export type OptionalArticleModelResponseTransformer = (data: any) => OptionalArticle;

export const OptionalArticleModelResponseTransformer: OptionalArticleModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export type OptionalBioMaterialModelResponseTransformer = (data: any) => OptionalBioMaterial;

export const OptionalBioMaterialModelResponseTransformer: OptionalBioMaterialModelResponseTransformer = data => {
    if (Array.isArray(data?.code_history)) {
        data.code_history.forEach(CodeHistoryModelResponseTransformer);
    }
    if (data?.external) {
        OptionalExternalBioMatSpecificModelResponseTransformer(data.external);
    }
    if (data?.identification) {
        IdentificationModelResponseTransformer(data.identification);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (Array.isArray(data?.published_in)) {
        data.published_in.forEach(ArticleModelResponseTransformer);
    }
    if (data?.sampling) {
        SamplingInnerModelResponseTransformer(data.sampling);
    }
    return data;
};

export const OptionalExtSeqSpecificsModelResponseTransformer: OptionalExtSeqSpecificsModelResponseTransformer = data => {
    if (data?.published_in) {
        OptionalArticleModelResponseTransformer(data.published_in);
    }
    if (Array.isArray(data?.referenced_in)) {
        data.referenced_in.forEach(SeqReferenceModelResponseTransformer);
    }
    if (data?.source_sample) {
        OptionalBioMaterialModelResponseTransformer(data.source_sample);
    }
    return data;
};

export const SequenceModelResponseTransformer: SequenceModelResponseTransformer = data => {
    if (data?.event) {
        EventInnerModelResponseTransformer(data.event);
    }
    if (data?.external) {
        OptionalExtSeqSpecificsModelResponseTransformer(data.external);
    }
    if (data?.gene) {
        GeneModelResponseTransformer(data.gene);
    }
    if (data?.identification) {
        IdentificationModelResponseTransformer(data.identification);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.sampling) {
        SamplingInnerModelResponseTransformer(data.sampling);
    }
    return data;
};

export const ListSequencesResponseTransformer: ListSequencesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SequenceModelResponseTransformer);
    }
    return data;
};

export type DeleteSequenceResponseTransformer = (data: any) => Promise<DeleteSequenceResponse>;

export const DeleteSequenceResponseTransformer: DeleteSequenceResponseTransformer = async (data) => {
    SequenceModelResponseTransformer(data);
    return data;
};

export type GetTaxonomyResponseTransformer = (data: any) => Promise<GetTaxonomyResponse>;

export type TaxonomyModelResponseTransformer = (data: any) => Taxonomy;

export type OptionalTaxonModelResponseTransformer = (data: any) => OptionalTaxon;

export const OptionalTaxonModelResponseTransformer: OptionalTaxonModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const TaxonomyModelResponseTransformer: TaxonomyModelResponseTransformer = data => {
    if (Array.isArray(data?.children)) {
        data.children.forEach(TaxonomyModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.parent) {
        OptionalTaxonModelResponseTransformer(data.parent);
    }
    return data;
};

export const GetTaxonomyResponseTransformer: GetTaxonomyResponseTransformer = async (data) => {
    TaxonomyModelResponseTransformer(data);
    return data;
};

export type ListTaxaResponseTransformer = (data: any) => Promise<ListTaxaResponse>;

export type TaxonWithParentRefModelResponseTransformer = (data: any) => TaxonWithParentRef;

export const TaxonWithParentRefModelResponseTransformer: TaxonWithParentRefModelResponseTransformer = data => {
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    return data;
};

export const ListTaxaResponseTransformer: ListTaxaResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaxonWithParentRefModelResponseTransformer);
    }
    return data;
};

export type CreateTaxonResponseTransformer = (data: any) => Promise<CreateTaxonResponse>;

export type TaxonWithRelativesModelResponseTransformer = (data: any) => TaxonWithRelatives;

export const TaxonWithRelativesModelResponseTransformer: TaxonWithRelativesModelResponseTransformer = data => {
    if (Array.isArray(data?.children)) {
        data.children.forEach(TaxonModelResponseTransformer);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.parent) {
        OptionalTaxonModelResponseTransformer(data.parent);
    }
    return data;
};

export const CreateTaxonResponseTransformer: CreateTaxonResponseTransformer = async (data) => {
    TaxonWithRelativesModelResponseTransformer(data);
    return data;
};

export type DeleteTaxonResponseTransformer = (data: any) => Promise<DeleteTaxonResponse>;

export const DeleteTaxonResponseTransformer: DeleteTaxonResponseTransformer = async (data) => {
    TaxonWithRelativesModelResponseTransformer(data);
    return data;
};

export type GetTaxonResponseTransformer = (data: any) => Promise<GetTaxonResponse>;

export type TaxonWithLineageModelResponseTransformer = (data: any) => TaxonWithLineage;

export type LineageModelResponseTransformer = (data: any) => Lineage;

export const LineageModelResponseTransformer: LineageModelResponseTransformer = data => {
    if (data?.class) {
        OptionalTaxonModelResponseTransformer(data.class);
    }
    if (data?.family) {
        OptionalTaxonModelResponseTransformer(data.family);
    }
    if (data?.genus) {
        OptionalTaxonModelResponseTransformer(data.genus);
    }
    if (data?.kingdom) {
        OptionalTaxonModelResponseTransformer(data.kingdom);
    }
    if (data?.order) {
        OptionalTaxonModelResponseTransformer(data.order);
    }
    if (data?.phylum) {
        OptionalTaxonModelResponseTransformer(data.phylum);
    }
    if (data?.species) {
        OptionalTaxonModelResponseTransformer(data.species);
    }
    if (data?.subspecies) {
        OptionalTaxonModelResponseTransformer(data.subspecies);
    }
    return data;
};

export const TaxonWithLineageModelResponseTransformer: TaxonWithLineageModelResponseTransformer = data => {
    if (Array.isArray(data?.children)) {
        data.children.forEach(TaxonModelResponseTransformer);
    }
    if (data?.lineage) {
        LineageModelResponseTransformer(data.lineage);
    }
    if (data?.meta) {
        MetaModelResponseTransformer(data.meta);
    }
    if (data?.parent) {
        OptionalTaxonModelResponseTransformer(data.parent);
    }
    return data;
};

export const GetTaxonResponseTransformer: GetTaxonResponseTransformer = async (data) => {
    TaxonWithLineageModelResponseTransformer(data);
    return data;
};

export type UpdateTaxonResponseTransformer = (data: any) => Promise<UpdateTaxonResponse>;

export const UpdateTaxonResponseTransformer: UpdateTaxonResponseTransformer = async (data) => {
    TaxonModelResponseTransformer(data);
    return data;
};

export type ListAnchorsResponseTransformer = (data: any) => Promise<ListAnchorsResponse>;

export const ListAnchorsResponseTransformer: ListAnchorsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaxonWithParentRefModelResponseTransformer);
    }
    return data;
};