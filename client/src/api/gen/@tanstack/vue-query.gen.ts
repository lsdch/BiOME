// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  SamplingService,
  AccountService,
  TaxonomyGbifService,
  OccurrencesService,
  ReferencesService,
  DataSourcesService,
  DatasetsService,
  EventsService,
  SequencesService,
  ServicesService,
  LocationService,
  PeopleService,
  SettingsService,
  TaxonomyService
} from '../sdk.gen'
import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData
} from '@tanstack/vue-query'
import type {
  ListAbioticParametersData,
  CreateAbioticParameterData,
  CreateAbioticParameterError,
  CreateAbioticParameterResponse,
  DeleteAbioticParameterData,
  DeleteAbioticParameterError,
  DeleteAbioticParameterResponse,
  UpdateAbioticParameterData,
  UpdateAbioticParameterError,
  UpdateAbioticParameterResponse,
  GetAccessPointsData,
  CurrentUserData,
  ConfirmEmailData,
  ResendEmailVerificationData,
  ResendEmailVerificationError,
  ResendEmailVerificationResponse,
  RequestPasswordResetData,
  RequestPasswordResetError,
  RequestPasswordResetResponse,
  LoginData,
  LoginError,
  LoginResponse,
  LogoutData,
  LogoutError,
  LogoutResponse,
  UpdatePasswordData,
  UpdatePasswordError,
  UpdatePasswordResponse,
  ValidatePasswordTokenData,
  ResetPasswordData,
  ResetPasswordError,
  ResetPasswordResponse,
  ListPendingUserRequestsData,
  DeletePendingUserRequestData,
  DeletePendingUserRequestError,
  DeletePendingUserRequestResponse,
  GetPendingUserRequestData,
  RefreshSessionData,
  RefreshSessionError,
  RefreshSessionResponse,
  RegisterData,
  RegisterError,
  RegisterResponse,
  ClaimInvitationData,
  ClaimInvitationError,
  ClaimInvitationResponse,
  ListAnchorsData,
  ListBioMaterialData,
  ListBioMaterialError,
  ListBioMaterialResponse,
  UpdateExternalBioMatData,
  UpdateExternalBioMatError,
  UpdateExternalBioMatResponse,
  CreateExternalBioMatData,
  CreateExternalBioMatError,
  CreateExternalBioMatResponse,
  DeleteBioMaterialData,
  DeleteBioMaterialError,
  DeleteBioMaterialResponse,
  GetBioMaterialData,
  CrossRefData,
  CrossRefBibSearchData,
  CrossRefBibSearchError,
  CrossRefBibSearchResponse,
  ListDataSourcesData,
  CreateDataSourceData,
  CreateDataSourceError,
  CreateDataSourceResponse,
  DeleteDataSourceData,
  DeleteDataSourceError,
  DeleteDataSourceResponse,
  UpdateDataSourceData,
  UpdateDataSourceError,
  UpdateDataSourceResponse,
  ListDatasetsData,
  UpdateDatasetData,
  UpdateDatasetError,
  UpdateDatasetResponse,
  ListOccurrenceDatasetsData,
  GetOccurrenceDatasetData,
  TogglePinDatasetData,
  TogglePinDatasetError,
  TogglePinDatasetResponse,
  ListSequenceDatasetsData,
  GetSequenceDatasetData,
  ListSiteDatasetsData,
  CreateSiteDatasetData,
  CreateSiteDatasetError,
  CreateSiteDatasetResponse,
  GetSiteDatasetData,
  GetDatasetData,
  DeleteEventData,
  DeleteEventError,
  DeleteEventResponse,
  UpdateEventData,
  UpdateEventError,
  UpdateEventResponse,
  EventAddExternalOccurrenceData,
  EventAddExternalOccurrenceError,
  EventAddExternalOccurrenceResponse,
  CreateSamplingAtEventData,
  CreateSamplingAtEventError,
  CreateSamplingAtEventResponse,
  UpdateSpottingData,
  UpdateSpottingError,
  UpdateSpottingResponse,
  ListFixativesData,
  CreateFixativeData,
  CreateFixativeError,
  CreateFixativeResponse,
  DeleteFixativeData,
  DeleteFixativeError,
  DeleteFixativeResponse,
  UpdateFixativeData,
  UpdateFixativeError,
  UpdateFixativeResponse,
  ListGenesData,
  CreateGeneData,
  CreateGeneError,
  CreateGeneResponse,
  DeleteGeneData,
  DeleteGeneError,
  DeleteGeneResponse,
  UpdateGeneData,
  UpdateGeneError,
  UpdateGeneResponse,
  ReverseGeocodeData,
  ReverseGeocodeError,
  ReverseGeocodeResponse,
  GetGeoapifyStatusData,
  ListGeoapifyUsageData,
  ListHabitatGroupsData,
  CreateHabitatGroupData,
  CreateHabitatGroupError,
  CreateHabitatGroupResponse,
  DeleteHabitatGroupData,
  DeleteHabitatGroupError,
  DeleteHabitatGroupResponse,
  UpdateHabitatGroupData,
  UpdateHabitatGroupError,
  UpdateHabitatGroupResponse,
  ImportGbifData,
  ImportGbifError,
  ImportGbifResponse,
  MonitorGbifData,
  CoordinatesToCountryData,
  CoordinatesToCountryError,
  CoordinatesToCountryResponse,
  SitesProximityData,
  SitesProximityError,
  SitesProximityResponse,
  ListCountriesData,
  GetSitesCountByCountryData,
  SearchSitesData,
  OccurrencesBySiteData,
  OccurrenceOverviewData,
  ListOrganisationsData,
  CreateOrganisationData,
  CreateOrganisationError,
  CreateOrganisationResponse,
  DeleteOrganisationData,
  DeleteOrganisationError,
  DeleteOrganisationResponse,
  UpdateOrganisationData,
  UpdateOrganisationError,
  UpdateOrganisationResponse,
  ListPersonsData,
  CreatePersonData,
  CreatePersonError,
  CreatePersonResponse,
  DeletePersonData,
  DeletePersonError,
  DeletePersonResponse,
  UpdatePersonData,
  UpdatePersonError,
  UpdatePersonResponse,
  InvitePersonData,
  InvitePersonError,
  InvitePersonResponse,
  ListProgramsData,
  CreateProgramData,
  CreateProgramError,
  CreateProgramResponse,
  DeleteProgramData,
  DeleteProgramError,
  DeleteProgramResponse,
  UpdateProgramData,
  UpdateProgramError,
  UpdateProgramResponse,
  ListArticlesData,
  CreateArticleData,
  CreateArticleError,
  CreateArticleResponse,
  DeleteArticleData,
  DeleteArticleError,
  DeleteArticleResponse,
  UpdateArticleData,
  UpdateArticleError,
  UpdateArticleResponse,
  ListSamplingMethodsData,
  CreateSamplingMethodData,
  CreateSamplingMethodError,
  CreateSamplingMethodResponse,
  DeleteSamplingMethodData,
  DeleteSamplingMethodError,
  DeleteSamplingMethodResponse,
  UpdateSamplingMethodData,
  UpdateSamplingMethodError,
  UpdateSamplingMethodResponse,
  CreateSamplingData,
  CreateSamplingError,
  CreateSamplingResponse,
  DeleteSamplingData,
  DeleteSamplingError,
  DeleteSamplingResponse,
  UpdateSamplingData,
  UpdateSamplingError,
  UpdateSamplingResponse,
  SamplingAddExternalOccurrenceData,
  SamplingAddExternalOccurrenceError,
  SamplingAddExternalOccurrenceResponse,
  ListSequencesData,
  DeleteSequenceData,
  DeleteSequenceError,
  DeleteSequenceResponse,
  GetSequenceData,
  EmailSettingsData,
  UpdateEmailSettingsData,
  UpdateEmailSettingsError,
  UpdateEmailSettingsResponse,
  TestSmtpData,
  TestSmtpError,
  TestSmtpResponse,
  SetAppIconData,
  SetAppIconError,
  SetAppIconResponse,
  InstanceSettingsData,
  UpdateInstanceSettingsData,
  UpdateInstanceSettingsError,
  UpdateInstanceSettingsResponse,
  ListDataFeedsData,
  CreateDataFeedData,
  CreateDataFeedError,
  CreateDataFeedResponse,
  ListMapPresetsData,
  CreateUpdateMapPresetData,
  CreateUpdateMapPresetError,
  CreateUpdateMapPresetResponse,
  DeleteMapPresetData,
  DeleteMapPresetError,
  DeleteMapPresetResponse,
  SecuritySettingsData,
  UpdateSecuritySettingsData,
  UpdateSecuritySettingsError,
  UpdateSecuritySettingsResponse,
  ServiceSettingsData,
  UpdateServiceSettingsData,
  UpdateServiceSettingsError,
  UpdateServiceSettingsResponse,
  ListSitesData,
  CreateSiteData,
  CreateSiteError,
  CreateSiteResponse,
  GetSiteData,
  UpdateSiteData,
  UpdateSiteError,
  UpdateSiteResponse,
  ListSiteEventsData,
  CreateEventData,
  CreateEventError,
  CreateEventResponse,
  SiteAddExternalOccurrenceData,
  SiteAddExternalOccurrenceError,
  SiteAddExternalOccurrenceResponse,
  GetTaxonomyData,
  ListTaxaData,
  CreateTaxonData,
  CreateTaxonError,
  CreateTaxonResponse,
  DeleteTaxonData,
  DeleteTaxonError,
  DeleteTaxonResponse,
  GetTaxonData,
  UpdateTaxonData,
  UpdateTaxonError,
  UpdateTaxonResponse
} from '../types.gen'
import { client as _heyApiClient } from '../client.gen'

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string
    _infinite?: boolean
  }
]

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl
  } as QueryKey<TOptions>[0]
  if (infinite) {
    params._infinite = infinite
  }
  if (options?.body) {
    params.body = options.body
  }
  if (options?.headers) {
    params.headers = options.headers
  }
  if (options?.path) {
    params.path = options.path
  }
  if (options?.query) {
    params.query = options.query
  }
  return [params]
}

export const listAbioticParametersQueryKey = (options?: Options<ListAbioticParametersData>) =>
  createQueryKey('listAbioticParameters', options)

/**
 * List abiotic parameters
 */
export const listAbioticParametersOptions = (options?: Options<ListAbioticParametersData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.listAbioticParameters({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listAbioticParametersQueryKey(options)
  })
}

export const createAbioticParameterQueryKey = (options: Options<CreateAbioticParameterData>) =>
  createQueryKey('createAbioticParameter', options)

/**
 * Create abiotic parameter
 */
export const createAbioticParameterOptions = (options: Options<CreateAbioticParameterData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.createAbioticParameter({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createAbioticParameterQueryKey(options)
  })
}

/**
 * Create abiotic parameter
 */
export const createAbioticParameterMutation = (
  options?: Partial<Options<CreateAbioticParameterData>>
): UseMutationOptions<
  CreateAbioticParameterResponse,
  CreateAbioticParameterError,
  Options<CreateAbioticParameterData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAbioticParameterResponse,
    CreateAbioticParameterError,
    Options<CreateAbioticParameterData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.createAbioticParameter({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete abiotic parameter
 */
export const deleteAbioticParameterMutation = (
  options?: Partial<Options<DeleteAbioticParameterData>>
): UseMutationOptions<
  DeleteAbioticParameterResponse,
  DeleteAbioticParameterError,
  Options<DeleteAbioticParameterData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAbioticParameterResponse,
    DeleteAbioticParameterError,
    Options<DeleteAbioticParameterData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.deleteAbioticParameter({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update abiotic parameter
 */
export const updateAbioticParameterMutation = (
  options?: Partial<Options<UpdateAbioticParameterData>>
): UseMutationOptions<
  UpdateAbioticParameterResponse,
  UpdateAbioticParameterError,
  Options<UpdateAbioticParameterData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAbioticParameterResponse,
    UpdateAbioticParameterError,
    Options<UpdateAbioticParameterData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.updateAbioticParameter({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getAccessPointsQueryKey = (options?: Options<GetAccessPointsData>) =>
  createQueryKey('getAccessPoints', options)

/**
 * List access points
 */
export const getAccessPointsOptions = (options?: Options<GetAccessPointsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.getAccessPoints({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getAccessPointsQueryKey(options)
  })
}

export const currentUserQueryKey = (options?: Options<CurrentUserData>) =>
  createQueryKey('currentUser', options)

/**
 * Current user
 * Get infos of currently authenticated user account
 */
export const currentUserOptions = (options?: Options<CurrentUserData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.currentUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: currentUserQueryKey(options)
  })
}

export const confirmEmailQueryKey = (options?: Options<ConfirmEmailData>) =>
  createQueryKey('confirmEmail', options)

/**
 * Confirm e-mail
 * Confirms the validity of an e-mail address associated to an account, using a token issued at the end of user registration.
 */
export const confirmEmailOptions = (options?: Options<ConfirmEmailData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.confirmEmail({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: confirmEmailQueryKey(options)
  })
}

export const resendEmailVerificationQueryKey = (options: Options<ResendEmailVerificationData>) =>
  createQueryKey('resendEmailVerification', options)

/**
 * Resend e-mail verification link
 * Sends again a verification link for the provided e-mail address, if it matches a currently not verified user account.
 */
export const resendEmailVerificationOptions = (options: Options<ResendEmailVerificationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.resendEmailVerification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: resendEmailVerificationQueryKey(options)
  })
}

/**
 * Resend e-mail verification link
 * Sends again a verification link for the provided e-mail address, if it matches a currently not verified user account.
 */
export const resendEmailVerificationMutation = (
  options?: Partial<Options<ResendEmailVerificationData>>
): UseMutationOptions<
  ResendEmailVerificationResponse,
  ResendEmailVerificationError,
  Options<ResendEmailVerificationData>
> => {
  const mutationOptions: UseMutationOptions<
    ResendEmailVerificationResponse,
    ResendEmailVerificationError,
    Options<ResendEmailVerificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.resendEmailVerification({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const requestPasswordResetQueryKey = (options: Options<RequestPasswordResetData>) =>
  createQueryKey('requestPasswordReset', options)

/**
 * Request password reset
 * Requests sending a link containing a password reset token to your account email address. The link target can be provided by the client in the request body, or defaults to the API endpoint: `/api/v1/account/password-reset`. In this case, setting the new password is expected to be done programatically, e.g. through a curl request.
 */
export const requestPasswordResetOptions = (options: Options<RequestPasswordResetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.requestPasswordReset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: requestPasswordResetQueryKey(options)
  })
}

/**
 * Request password reset
 * Requests sending a link containing a password reset token to your account email address. The link target can be provided by the client in the request body, or defaults to the API endpoint: `/api/v1/account/password-reset`. In this case, setting the new password is expected to be done programatically, e.g. through a curl request.
 */
export const requestPasswordResetMutation = (
  options?: Partial<Options<RequestPasswordResetData>>
): UseMutationOptions<
  RequestPasswordResetResponse,
  RequestPasswordResetError,
  Options<RequestPasswordResetData>
> => {
  const mutationOptions: UseMutationOptions<
    RequestPasswordResetResponse,
    RequestPasswordResetError,
    Options<RequestPasswordResetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.requestPasswordReset({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const loginQueryKey = (options: Options<LoginData>) => createQueryKey('login', options)

/**
 * Login
 * Authenticate using user credentials
 */
export const loginOptions = (options: Options<LoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.login({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: loginQueryKey(options)
  })
}

/**
 * Login
 * Authenticate using user credentials
 */
export const loginMutation = (
  options?: Partial<Options<LoginData>>
): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
  const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.login({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const logoutQueryKey = (options: Options<LogoutData>) => createQueryKey('logout', options)

/**
 * Logout
 * Logout from current user session by revoking session cookies
 */
export const logoutOptions = (options: Options<LogoutData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.logout({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: logoutQueryKey(options)
  })
}

/**
 * Logout
 * Logout from current user session by revoking session cookies
 */
export const logoutMutation = (
  options?: Partial<Options<LogoutData>>
): UseMutationOptions<LogoutResponse, LogoutError, Options<LogoutData>> => {
  const mutationOptions: UseMutationOptions<LogoutResponse, LogoutError, Options<LogoutData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.logout({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const updatePasswordQueryKey = (options: Options<UpdatePasswordData>) =>
  createQueryKey('updatePassword', options)

/**
 * Update password
 * Updates password of currently authenticated user
 */
export const updatePasswordOptions = (options: Options<UpdatePasswordData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.updatePassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: updatePasswordQueryKey(options)
  })
}

/**
 * Update password
 * Updates password of currently authenticated user
 */
export const updatePasswordMutation = (
  options?: Partial<Options<UpdatePasswordData>>
): UseMutationOptions<UpdatePasswordResponse, UpdatePasswordError, Options<UpdatePasswordData>> => {
  const mutationOptions: UseMutationOptions<
    UpdatePasswordResponse,
    UpdatePasswordError,
    Options<UpdatePasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.updatePassword({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const validatePasswordTokenQueryKey = (options: Options<ValidatePasswordTokenData>) =>
  createQueryKey('validatePasswordToken', options)

/**
 * Validate password token
 * Verifies that the password token is valid and can be used to reset a password
 */
export const validatePasswordTokenOptions = (options: Options<ValidatePasswordTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.validatePasswordToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: validatePasswordTokenQueryKey(options)
  })
}

export const resetPasswordQueryKey = (options: Options<ResetPasswordData>) =>
  createQueryKey('resetPassword', options)

/**
 * Reset password
 * Set a new password using a previously issued reset token
 */
export const resetPasswordOptions = (options: Options<ResetPasswordData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.resetPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: resetPasswordQueryKey(options)
  })
}

/**
 * Reset password
 * Set a new password using a previously issued reset token
 */
export const resetPasswordMutation = (
  options?: Partial<Options<ResetPasswordData>>
): UseMutationOptions<ResetPasswordResponse, ResetPasswordError, Options<ResetPasswordData>> => {
  const mutationOptions: UseMutationOptions<
    ResetPasswordResponse,
    ResetPasswordError,
    Options<ResetPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.resetPassword({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listPendingUserRequestsQueryKey = (options?: Options<ListPendingUserRequestsData>) =>
  createQueryKey('listPendingUserRequests', options)

/**
 * List pending user requests
 * Lists all account requests pending validation from an administrator
 */
export const listPendingUserRequestsOptions = (options?: Options<ListPendingUserRequestsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.listPendingUserRequests({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listPendingUserRequestsQueryKey(options)
  })
}

/**
 * Delete pending user request
 * Delete account request pending validation using the associated email
 */
export const deletePendingUserRequestMutation = (
  options?: Partial<Options<DeletePendingUserRequestData>>
): UseMutationOptions<
  DeletePendingUserRequestResponse,
  DeletePendingUserRequestError,
  Options<DeletePendingUserRequestData>
> => {
  const mutationOptions: UseMutationOptions<
    DeletePendingUserRequestResponse,
    DeletePendingUserRequestError,
    Options<DeletePendingUserRequestData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.deletePendingUserRequest({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getPendingUserRequestQueryKey = (options?: Options<GetPendingUserRequestData>) =>
  createQueryKey('getPendingUserRequest', options)

/**
 * Get pending user request
 * Get account request pending validation using the associated email
 */
export const getPendingUserRequestOptions = (options?: Options<GetPendingUserRequestData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.getPendingUserRequest({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getPendingUserRequestQueryKey(options)
  })
}

export const refreshSessionQueryKey = (options: Options<RefreshSessionData>) =>
  createQueryKey('refreshSession', options)

/**
 * Refresh auth token
 * Refresh session using refresh token
 */
export const refreshSessionOptions = (options: Options<RefreshSessionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.refreshSession({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: refreshSessionQueryKey(options)
  })
}

/**
 * Refresh auth token
 * Refresh session using refresh token
 */
export const refreshSessionMutation = (
  options?: Partial<Options<RefreshSessionData>>
): UseMutationOptions<RefreshSessionResponse, RefreshSessionError, Options<RefreshSessionData>> => {
  const mutationOptions: UseMutationOptions<
    RefreshSessionResponse,
    RefreshSessionError,
    Options<RefreshSessionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.refreshSession({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const registerQueryKey = (options: Options<RegisterData>) =>
  createQueryKey('register', options)

/**
 * Register new account
 * Register a new account that is initially pending, and needs to be activated by an administrator. An email is sent to the registered e-mail address with a verification link. The target URL can be set by the client, otherwise it defaults to the API endpoint: `/api/v1/account/email-confirmation`
 */
export const registerOptions = (options: Options<RegisterData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.register({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: registerQueryKey(options)
  })
}

/**
 * Register new account
 * Register a new account that is initially pending, and needs to be activated by an administrator. An email is sent to the registered e-mail address with a verification link. The target URL can be set by the client, otherwise it defaults to the API endpoint: `/api/v1/account/email-confirmation`
 */
export const registerMutation = (
  options?: Partial<Options<RegisterData>>
): UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> => {
  const mutationOptions: UseMutationOptions<
    RegisterResponse,
    RegisterError,
    Options<RegisterData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.register({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const claimInvitationQueryKey = (options: Options<ClaimInvitationData>) =>
  createQueryKey('claimInvitation', options)

/**
 * Claim invitation
 * Register an account with pre-assigned role and identity, using an invitation token
 */
export const claimInvitationOptions = (options: Options<ClaimInvitationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await AccountService.claimInvitation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: claimInvitationQueryKey(options)
  })
}

/**
 * Claim invitation
 * Register an account with pre-assigned role and identity, using an invitation token
 */
export const claimInvitationMutation = (
  options?: Partial<Options<ClaimInvitationData>>
): UseMutationOptions<
  ClaimInvitationResponse,
  ClaimInvitationError,
  Options<ClaimInvitationData>
> => {
  const mutationOptions: UseMutationOptions<
    ClaimInvitationResponse,
    ClaimInvitationError,
    Options<ClaimInvitationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await AccountService.claimInvitation({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listAnchorsQueryKey = (options?: Options<ListAnchorsData>) =>
  createQueryKey('listAnchors', options)

/**
 * List GBIF anchor clades
 */
export const listAnchorsOptions = (options?: Options<ListAnchorsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await TaxonomyGbifService.listAnchors({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listAnchorsQueryKey(options)
  })
}

export const listBioMaterialQueryKey = (options?: Options<ListBioMaterialData>) =>
  createQueryKey('listBioMaterial', options)

/**
 * List bio-material
 * Both internal and external
 */
export const listBioMaterialOptions = (options?: Options<ListBioMaterialData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.listBioMaterial({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listBioMaterialQueryKey(options)
  })
}

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>
>(
  queryKey: QueryKey<Options>,
  page: K
) => {
  const params = {
    ...queryKey[0]
  }
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any)
    }
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers
    }
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any)
    }
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any)
    }
  }
  return params as unknown as typeof page
}

export const listBioMaterialInfiniteQueryKey = (
  options?: Options<ListBioMaterialData>
): QueryKey<Options<ListBioMaterialData>> => createQueryKey('listBioMaterial', options, true)

/**
 * List bio-material
 * Both internal and external
 */
export const listBioMaterialInfiniteOptions = (options?: Options<ListBioMaterialData>) => {
  return infiniteQueryOptions<
    ListBioMaterialResponse,
    ListBioMaterialError,
    InfiniteData<ListBioMaterialResponse>,
    QueryKey<Options<ListBioMaterialData>>,
    number | Pick<QueryKey<Options<ListBioMaterialData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListBioMaterialData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam
                }
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await OccurrencesService.listBioMaterial({
          ...options,
          ...params,
          signal,
          throwOnError: true
        })
        return data
      },
      queryKey: listBioMaterialInfiniteQueryKey(options)
    }
  )
}

/**
 * Update external bio-material
 */
export const updateExternalBioMatMutation = (
  options?: Partial<Options<UpdateExternalBioMatData>>
): UseMutationOptions<
  UpdateExternalBioMatResponse,
  UpdateExternalBioMatError,
  Options<UpdateExternalBioMatData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateExternalBioMatResponse,
    UpdateExternalBioMatError,
    Options<UpdateExternalBioMatData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await OccurrencesService.updateExternalBioMat({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const createExternalBioMatQueryKey = (options: Options<CreateExternalBioMatData>) =>
  createQueryKey('createExternalBioMat', options)

/**
 * Create external bio-material
 */
export const createExternalBioMatOptions = (options: Options<CreateExternalBioMatData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.createExternalBioMat({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createExternalBioMatQueryKey(options)
  })
}

/**
 * Create external bio-material
 */
export const createExternalBioMatMutation = (
  options?: Partial<Options<CreateExternalBioMatData>>
): UseMutationOptions<
  CreateExternalBioMatResponse,
  CreateExternalBioMatError,
  Options<CreateExternalBioMatData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateExternalBioMatResponse,
    CreateExternalBioMatError,
    Options<CreateExternalBioMatData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await OccurrencesService.createExternalBioMat({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete bio-material
 * Delete any (internal/external) bio-material record by its code
 */
export const deleteBioMaterialMutation = (
  options?: Partial<Options<DeleteBioMaterialData>>
): UseMutationOptions<
  DeleteBioMaterialResponse,
  DeleteBioMaterialError,
  Options<DeleteBioMaterialData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteBioMaterialResponse,
    DeleteBioMaterialError,
    Options<DeleteBioMaterialData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await OccurrencesService.deleteBioMaterial({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getBioMaterialQueryKey = (options: Options<GetBioMaterialData>) =>
  createQueryKey('getBioMaterial', options)

/**
 * Get bio-material
 * Both internal and external
 */
export const getBioMaterialOptions = (options: Options<GetBioMaterialData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.getBioMaterial({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getBioMaterialQueryKey(options)
  })
}

export const crossRefQueryKey = (options: Options<CrossRefData>) =>
  createQueryKey('crossRef', options)

/**
 * Retrieve article infos from DOI
 */
export const crossRefOptions = (options: Options<CrossRefData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ReferencesService.crossRef({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: crossRefQueryKey(options)
  })
}

export const crossRefBibSearchQueryKey = (options: Options<CrossRefBibSearchData>) =>
  createQueryKey('crossRefBibSearch', options)

/**
 * Retrieve article infos from query string
 */
export const crossRefBibSearchOptions = (options: Options<CrossRefBibSearchData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ReferencesService.crossRefBibSearch({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: crossRefBibSearchQueryKey(options)
  })
}

/**
 * Retrieve article infos from query string
 */
export const crossRefBibSearchMutation = (
  options?: Partial<Options<CrossRefBibSearchData>>
): UseMutationOptions<
  CrossRefBibSearchResponse,
  CrossRefBibSearchError,
  Options<CrossRefBibSearchData>
> => {
  const mutationOptions: UseMutationOptions<
    CrossRefBibSearchResponse,
    CrossRefBibSearchError,
    Options<CrossRefBibSearchData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ReferencesService.crossRefBibSearch({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listDataSourcesQueryKey = (options?: Options<ListDataSourcesData>) =>
  createQueryKey('listDataSources', options)

/**
 * List external data sources
 */
export const listDataSourcesOptions = (options?: Options<ListDataSourcesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DataSourcesService.listDataSources({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listDataSourcesQueryKey(options)
  })
}

export const createDataSourceQueryKey = (options: Options<CreateDataSourceData>) =>
  createQueryKey('createDataSource', options)

/**
 * Register external data source
 */
export const createDataSourceOptions = (options: Options<CreateDataSourceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DataSourcesService.createDataSource({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createDataSourceQueryKey(options)
  })
}

/**
 * Register external data source
 */
export const createDataSourceMutation = (
  options?: Partial<Options<CreateDataSourceData>>
): UseMutationOptions<
  CreateDataSourceResponse,
  CreateDataSourceError,
  Options<CreateDataSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDataSourceResponse,
    CreateDataSourceError,
    Options<CreateDataSourceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DataSourcesService.createDataSource({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete external data source
 */
export const deleteDataSourceMutation = (
  options?: Partial<Options<DeleteDataSourceData>>
): UseMutationOptions<
  DeleteDataSourceResponse,
  DeleteDataSourceError,
  Options<DeleteDataSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteDataSourceResponse,
    DeleteDataSourceError,
    Options<DeleteDataSourceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DataSourcesService.deleteDataSource({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update external data source
 */
export const updateDataSourceMutation = (
  options?: Partial<Options<UpdateDataSourceData>>
): UseMutationOptions<
  UpdateDataSourceResponse,
  UpdateDataSourceError,
  Options<UpdateDataSourceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateDataSourceResponse,
    UpdateDataSourceError,
    Options<UpdateDataSourceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DataSourcesService.updateDataSource({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listDatasetsQueryKey = (options?: Options<ListDatasetsData>) =>
  createQueryKey('listDatasets', options)

/**
 * List all datasets
 * List all datasets with optional filters and category discriminator
 */
export const listDatasetsOptions = (options?: Options<ListDatasetsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.listDatasets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listDatasetsQueryKey(options)
  })
}

/**
 * Update dataset
 * Update dataset metadata
 */
export const updateDatasetMutation = (
  options?: Partial<Options<UpdateDatasetData>>
): UseMutationOptions<UpdateDatasetResponse, UpdateDatasetError, Options<UpdateDatasetData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateDatasetResponse,
    UpdateDatasetError,
    Options<UpdateDatasetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DatasetsService.updateDataset({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listOccurrenceDatasetsQueryKey = (options?: Options<ListOccurrenceDatasetsData>) =>
  createQueryKey('listOccurrenceDatasets', options)

/**
 * List occurrence datasets
 * List all occurrence datasets
 */
export const listOccurrenceDatasetsOptions = (options?: Options<ListOccurrenceDatasetsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.listOccurrenceDatasets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listOccurrenceDatasetsQueryKey(options)
  })
}

export const getOccurrenceDatasetQueryKey = (options: Options<GetOccurrenceDatasetData>) =>
  createQueryKey('getOccurrenceDataset', options)

/**
 * Get occurrence dataset
 * Get infos for an occurrence dataset
 */
export const getOccurrenceDatasetOptions = (options: Options<GetOccurrenceDatasetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.getOccurrenceDataset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getOccurrenceDatasetQueryKey(options)
  })
}

/**
 * Pin/unpin dataset
 * Pin or unpin dataset from from dashboard priority display
 */
export const togglePinDatasetMutation = (
  options?: Partial<Options<TogglePinDatasetData>>
): UseMutationOptions<
  TogglePinDatasetResponse,
  TogglePinDatasetError,
  Options<TogglePinDatasetData>
> => {
  const mutationOptions: UseMutationOptions<
    TogglePinDatasetResponse,
    TogglePinDatasetError,
    Options<TogglePinDatasetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DatasetsService.togglePinDataset({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listSequenceDatasetsQueryKey = (options?: Options<ListSequenceDatasetsData>) =>
  createQueryKey('listSequenceDatasets', options)

/**
 * List sequence datasets
 * List all sequence datasets
 */
export const listSequenceDatasetsOptions = (options?: Options<ListSequenceDatasetsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.listSequenceDatasets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listSequenceDatasetsQueryKey(options)
  })
}

export const getSequenceDatasetQueryKey = (options: Options<GetSequenceDatasetData>) =>
  createQueryKey('getSequenceDataset', options)

/**
 * Get sequence dataset
 * Get infos for an sequence dataset
 */
export const getSequenceDatasetOptions = (options: Options<GetSequenceDatasetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.getSequenceDataset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getSequenceDatasetQueryKey(options)
  })
}

export const listSiteDatasetsQueryKey = (options?: Options<ListSiteDatasetsData>) =>
  createQueryKey('listSiteDatasets', options)

/**
 * List site datasets
 * List all site datasets
 */
export const listSiteDatasetsOptions = (options?: Options<ListSiteDatasetsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.listSiteDatasets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listSiteDatasetsQueryKey(options)
  })
}

export const createSiteDatasetQueryKey = (options: Options<CreateSiteDatasetData>) =>
  createQueryKey('createSiteDataset', options)

/**
 * Create site dataset
 * Create a new site dataset with new or existing sites
 */
export const createSiteDatasetOptions = (options: Options<CreateSiteDatasetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.createSiteDataset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createSiteDatasetQueryKey(options)
  })
}

/**
 * Create site dataset
 * Create a new site dataset with new or existing sites
 */
export const createSiteDatasetMutation = (
  options?: Partial<Options<CreateSiteDatasetData>>
): UseMutationOptions<
  CreateSiteDatasetResponse,
  CreateSiteDatasetError,
  Options<CreateSiteDatasetData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateSiteDatasetResponse,
    CreateSiteDatasetError,
    Options<CreateSiteDatasetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DatasetsService.createSiteDataset({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getSiteDatasetQueryKey = (options: Options<GetSiteDatasetData>) =>
  createQueryKey('getSiteDataset', options)

/**
 * Get site dataset
 * Get infos for a site dataset
 */
export const getSiteDatasetOptions = (options: Options<GetSiteDatasetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.getSiteDataset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getSiteDatasetQueryKey(options)
  })
}

export const getDatasetQueryKey = (options: Options<GetDatasetData>) =>
  createQueryKey('getDataset', options)

/**
 * Get dataset
 * Retrieve dataset infos by slug
 */
export const getDatasetOptions = (options: Options<GetDatasetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.getDataset({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getDatasetQueryKey(options)
  })
}

/**
 * Delete event
 */
export const deleteEventMutation = (
  options?: Partial<Options<DeleteEventData>>
): UseMutationOptions<DeleteEventResponse, DeleteEventError, Options<DeleteEventData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteEventResponse,
    DeleteEventError,
    Options<DeleteEventData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await EventsService.deleteEvent({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update event
 */
export const updateEventMutation = (
  options?: Partial<Options<UpdateEventData>>
): UseMutationOptions<UpdateEventResponse, UpdateEventError, Options<UpdateEventData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateEventResponse,
    UpdateEventError,
    Options<UpdateEventData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await EventsService.updateEvent({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const eventAddExternalOccurrenceQueryKey = (
  options: Options<EventAddExternalOccurrenceData>
) => createQueryKey('eventAddExternalOccurrence', options)

/**
 * Add occurrence from event
 * Register new occurrence resulting from the event, including sampling specification and biomaterial identification
 */
export const eventAddExternalOccurrenceOptions = (
  options: Options<EventAddExternalOccurrenceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.eventAddExternalOccurrence({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: eventAddExternalOccurrenceQueryKey(options)
  })
}

/**
 * Add occurrence from event
 * Register new occurrence resulting from the event, including sampling specification and biomaterial identification
 */
export const eventAddExternalOccurrenceMutation = (
  options?: Partial<Options<EventAddExternalOccurrenceData>>
): UseMutationOptions<
  EventAddExternalOccurrenceResponse,
  EventAddExternalOccurrenceError,
  Options<EventAddExternalOccurrenceData>
> => {
  const mutationOptions: UseMutationOptions<
    EventAddExternalOccurrenceResponse,
    EventAddExternalOccurrenceError,
    Options<EventAddExternalOccurrenceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await OccurrencesService.eventAddExternalOccurrence({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const createSamplingAtEventQueryKey = (options: Options<CreateSamplingAtEventData>) =>
  createQueryKey('createSamplingAtEvent', options)

/**
 * Create sampling at event
 */
export const createSamplingAtEventOptions = (options: Options<CreateSamplingAtEventData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await EventsService.createSamplingAtEvent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createSamplingAtEventQueryKey(options)
  })
}

/**
 * Create sampling at event
 */
export const createSamplingAtEventMutation = (
  options?: Partial<Options<CreateSamplingAtEventData>>
): UseMutationOptions<
  CreateSamplingAtEventResponse,
  CreateSamplingAtEventError,
  Options<CreateSamplingAtEventData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateSamplingAtEventResponse,
    CreateSamplingAtEventError,
    Options<CreateSamplingAtEventData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await EventsService.createSamplingAtEvent({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update spotting
 */
export const updateSpottingMutation = (
  options?: Partial<Options<UpdateSpottingData>>
): UseMutationOptions<UpdateSpottingResponse, UpdateSpottingError, Options<UpdateSpottingData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateSpottingResponse,
    UpdateSpottingError,
    Options<UpdateSpottingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await EventsService.updateSpotting({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listFixativesQueryKey = (options?: Options<ListFixativesData>) =>
  createQueryKey('listFixatives', options)

/**
 * List fixatives
 */
export const listFixativesOptions = (options?: Options<ListFixativesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.listFixatives({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listFixativesQueryKey(options)
  })
}

export const createFixativeQueryKey = (options: Options<CreateFixativeData>) =>
  createQueryKey('createFixative', options)

/**
 * Create fixative
 */
export const createFixativeOptions = (options: Options<CreateFixativeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.createFixative({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createFixativeQueryKey(options)
  })
}

/**
 * Create fixative
 */
export const createFixativeMutation = (
  options?: Partial<Options<CreateFixativeData>>
): UseMutationOptions<CreateFixativeResponse, CreateFixativeError, Options<CreateFixativeData>> => {
  const mutationOptions: UseMutationOptions<
    CreateFixativeResponse,
    CreateFixativeError,
    Options<CreateFixativeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.createFixative({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete fixative
 */
export const deleteFixativeMutation = (
  options?: Partial<Options<DeleteFixativeData>>
): UseMutationOptions<DeleteFixativeResponse, DeleteFixativeError, Options<DeleteFixativeData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteFixativeResponse,
    DeleteFixativeError,
    Options<DeleteFixativeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.deleteFixative({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update fixative
 */
export const updateFixativeMutation = (
  options?: Partial<Options<UpdateFixativeData>>
): UseMutationOptions<UpdateFixativeResponse, UpdateFixativeError, Options<UpdateFixativeData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateFixativeResponse,
    UpdateFixativeError,
    Options<UpdateFixativeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.updateFixative({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listGenesQueryKey = (options?: Options<ListGenesData>) =>
  createQueryKey('listGenes', options)

/**
 * List genes
 */
export const listGenesOptions = (options?: Options<ListGenesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SequencesService.listGenes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listGenesQueryKey(options)
  })
}

export const createGeneQueryKey = (options: Options<CreateGeneData>) =>
  createQueryKey('createGene', options)

/**
 * Create gene
 */
export const createGeneOptions = (options: Options<CreateGeneData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SequencesService.createGene({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createGeneQueryKey(options)
  })
}

/**
 * Create gene
 */
export const createGeneMutation = (
  options?: Partial<Options<CreateGeneData>>
): UseMutationOptions<CreateGeneResponse, CreateGeneError, Options<CreateGeneData>> => {
  const mutationOptions: UseMutationOptions<
    CreateGeneResponse,
    CreateGeneError,
    Options<CreateGeneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SequencesService.createGene({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete gene
 */
export const deleteGeneMutation = (
  options?: Partial<Options<DeleteGeneData>>
): UseMutationOptions<DeleteGeneResponse, DeleteGeneError, Options<DeleteGeneData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteGeneResponse,
    DeleteGeneError,
    Options<DeleteGeneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SequencesService.deleteGene({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update gene
 */
export const updateGeneMutation = (
  options?: Partial<Options<UpdateGeneData>>
): UseMutationOptions<UpdateGeneResponse, UpdateGeneError, Options<UpdateGeneData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateGeneResponse,
    UpdateGeneError,
    Options<UpdateGeneData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SequencesService.updateGene({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const reverseGeocodeQueryKey = (options: Options<ReverseGeocodeData>) =>
  createQueryKey('reverseGeocode', options)

/**
 * Reverse geocode coordinates using Geoapify API
 */
export const reverseGeocodeOptions = (options: Options<ReverseGeocodeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ServicesService.reverseGeocode({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: reverseGeocodeQueryKey(options)
  })
}

/**
 * Reverse geocode coordinates using Geoapify API
 */
export const reverseGeocodeMutation = (
  options?: Partial<Options<ReverseGeocodeData>>
): UseMutationOptions<ReverseGeocodeResponse, ReverseGeocodeError, Options<ReverseGeocodeData>> => {
  const mutationOptions: UseMutationOptions<
    ReverseGeocodeResponse,
    ReverseGeocodeError,
    Options<ReverseGeocodeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ServicesService.reverseGeocode({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getGeoapifyStatusQueryKey = (options?: Options<GetGeoapifyStatusData>) =>
  createQueryKey('getGeoapifyStatus', options)

/**
 * Get Geoapify API status
 */
export const getGeoapifyStatusOptions = (options?: Options<GetGeoapifyStatusData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ServicesService.getGeoapifyStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getGeoapifyStatusQueryKey(options)
  })
}

export const listGeoapifyUsageQueryKey = (options?: Options<ListGeoapifyUsageData>) =>
  createQueryKey('listGeoapifyUsage', options)

/**
 * List Geoapify usage
 */
export const listGeoapifyUsageOptions = (options?: Options<ListGeoapifyUsageData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ServicesService.listGeoapifyUsage({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listGeoapifyUsageQueryKey(options)
  })
}

export const listHabitatGroupsQueryKey = (options?: Options<ListHabitatGroupsData>) =>
  createQueryKey('listHabitatGroups', options)

/**
 * List habitats
 */
export const listHabitatGroupsOptions = (options?: Options<ListHabitatGroupsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.listHabitatGroups({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listHabitatGroupsQueryKey(options)
  })
}

export const createHabitatGroupQueryKey = (options: Options<CreateHabitatGroupData>) =>
  createQueryKey('createHabitatGroup', options)

/**
 * Create habitat group
 */
export const createHabitatGroupOptions = (options: Options<CreateHabitatGroupData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.createHabitatGroup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createHabitatGroupQueryKey(options)
  })
}

/**
 * Create habitat group
 */
export const createHabitatGroupMutation = (
  options?: Partial<Options<CreateHabitatGroupData>>
): UseMutationOptions<
  CreateHabitatGroupResponse,
  CreateHabitatGroupError,
  Options<CreateHabitatGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateHabitatGroupResponse,
    CreateHabitatGroupError,
    Options<CreateHabitatGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.createHabitatGroup({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete habitat group
 */
export const deleteHabitatGroupMutation = (
  options?: Partial<Options<DeleteHabitatGroupData>>
): UseMutationOptions<
  DeleteHabitatGroupResponse,
  DeleteHabitatGroupError,
  Options<DeleteHabitatGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteHabitatGroupResponse,
    DeleteHabitatGroupError,
    Options<DeleteHabitatGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.deleteHabitatGroup({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update habitat group
 */
export const updateHabitatGroupMutation = (
  options?: Partial<Options<UpdateHabitatGroupData>>
): UseMutationOptions<
  UpdateHabitatGroupResponse,
  UpdateHabitatGroupError,
  Options<UpdateHabitatGroupData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateHabitatGroupResponse,
    UpdateHabitatGroupError,
    Options<UpdateHabitatGroupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.updateHabitatGroup({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Import GBIF clade
 */
export const importGbifMutation = (
  options?: Partial<Options<ImportGbifData>>
): UseMutationOptions<ImportGbifResponse, ImportGbifError, Options<ImportGbifData>> => {
  const mutationOptions: UseMutationOptions<
    ImportGbifResponse,
    ImportGbifError,
    Options<ImportGbifData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await TaxonomyGbifService.importGbif({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const monitorGbifQueryKey = (options?: Options<MonitorGbifData>) =>
  createQueryKey('monitorGbif', options)

/**
 * Monitor GBIF taxonomy imports
 */
export const monitorGbifOptions = (options?: Options<MonitorGbifData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await TaxonomyGbifService.monitorGbif({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: monitorGbifQueryKey(options)
  })
}

export const coordinatesToCountryQueryKey = (options: Options<CoordinatesToCountryData>) =>
  createQueryKey('coordinatesToCountry', options)

/**
 * Get country from WGS84 coordinates
 */
export const coordinatesToCountryOptions = (options: Options<CoordinatesToCountryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.coordinatesToCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: coordinatesToCountryQueryKey(options)
  })
}

/**
 * Get country from WGS84 coordinates
 */
export const coordinatesToCountryMutation = (
  options?: Partial<Options<CoordinatesToCountryData>>
): UseMutationOptions<
  CoordinatesToCountryResponse,
  CoordinatesToCountryError,
  Options<CoordinatesToCountryData>
> => {
  const mutationOptions: UseMutationOptions<
    CoordinatesToCountryResponse,
    CoordinatesToCountryError,
    Options<CoordinatesToCountryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LocationService.coordinatesToCountry({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const sitesProximityQueryKey = (options: Options<SitesProximityData>) =>
  createQueryKey('sitesProximity', options)

/**
 * List sites within a radius of a point
 */
export const sitesProximityOptions = (options: Options<SitesProximityData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.sitesProximity({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: sitesProximityQueryKey(options)
  })
}

/**
 * List sites within a radius of a point
 */
export const sitesProximityMutation = (
  options?: Partial<Options<SitesProximityData>>
): UseMutationOptions<SitesProximityResponse, SitesProximityError, Options<SitesProximityData>> => {
  const mutationOptions: UseMutationOptions<
    SitesProximityResponse,
    SitesProximityError,
    Options<SitesProximityData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LocationService.sitesProximity({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listCountriesQueryKey = (options?: Options<ListCountriesData>) =>
  createQueryKey('listCountries', options)

/**
 * List countries
 */
export const listCountriesOptions = (options?: Options<ListCountriesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.listCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listCountriesQueryKey(options)
  })
}

export const getSitesCountByCountryQueryKey = (options?: Options<GetSitesCountByCountryData>) =>
  createQueryKey('getSitesCountByCountry', options)

/**
 * Get country list with sites count
 */
export const getSitesCountByCountryOptions = (options?: Options<GetSitesCountByCountryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.getSitesCountByCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getSitesCountByCountryQueryKey(options)
  })
}

export const searchSitesQueryKey = (options?: Options<SearchSitesData>) =>
  createQueryKey('searchSites', options)

/**
 * Search sites
 * Search sites by name, code or locality fuzzy matching a query. Returns a list of sites sorted by similarity.
 */
export const searchSitesOptions = (options?: Options<SearchSitesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.searchSites({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: searchSitesQueryKey(options)
  })
}

export const occurrencesBySiteQueryKey = (options?: Options<OccurrencesBySiteData>) =>
  createQueryKey('occurrencesBySite', options)

/**
 * Occurrences by site
 */
export const occurrencesBySiteOptions = (options?: Options<OccurrencesBySiteData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.occurrencesBySite({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: occurrencesBySiteQueryKey(options)
  })
}

export const occurrenceOverviewQueryKey = (options?: Options<OccurrenceOverviewData>) =>
  createQueryKey('occurrenceOverview', options)

/**
 * Occurrences overview
 */
export const occurrenceOverviewOptions = (options?: Options<OccurrenceOverviewData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.occurrenceOverview({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: occurrenceOverviewQueryKey(options)
  })
}

export const listOrganisationsQueryKey = (options?: Options<ListOrganisationsData>) =>
  createQueryKey('listOrganisations', options)

/**
 * List organisations
 */
export const listOrganisationsOptions = (options?: Options<ListOrganisationsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await PeopleService.listOrganisations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listOrganisationsQueryKey(options)
  })
}

export const createOrganisationQueryKey = (options: Options<CreateOrganisationData>) =>
  createQueryKey('createOrganisation', options)

/**
 * Create organisation
 */
export const createOrganisationOptions = (options: Options<CreateOrganisationData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await PeopleService.createOrganisation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createOrganisationQueryKey(options)
  })
}

/**
 * Create organisation
 */
export const createOrganisationMutation = (
  options?: Partial<Options<CreateOrganisationData>>
): UseMutationOptions<
  CreateOrganisationResponse,
  CreateOrganisationError,
  Options<CreateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateOrganisationResponse,
    CreateOrganisationError,
    Options<CreateOrganisationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.createOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete organisation
 */
export const deleteOrganisationMutation = (
  options?: Partial<Options<DeleteOrganisationData>>
): UseMutationOptions<
  DeleteOrganisationResponse,
  DeleteOrganisationError,
  Options<DeleteOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteOrganisationResponse,
    DeleteOrganisationError,
    Options<DeleteOrganisationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.deleteOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update organisation
 */
export const updateOrganisationMutation = (
  options?: Partial<Options<UpdateOrganisationData>>
): UseMutationOptions<
  UpdateOrganisationResponse,
  UpdateOrganisationError,
  Options<UpdateOrganisationData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateOrganisationResponse,
    UpdateOrganisationError,
    Options<UpdateOrganisationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.updateOrganisation({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listPersonsQueryKey = (options?: Options<ListPersonsData>) =>
  createQueryKey('listPersons', options)

/**
 * List persons
 */
export const listPersonsOptions = (options?: Options<ListPersonsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await PeopleService.listPersons({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listPersonsQueryKey(options)
  })
}

export const createPersonQueryKey = (options: Options<CreatePersonData>) =>
  createQueryKey('createPerson', options)

/**
 * Create person
 */
export const createPersonOptions = (options: Options<CreatePersonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await PeopleService.createPerson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createPersonQueryKey(options)
  })
}

/**
 * Create person
 */
export const createPersonMutation = (
  options?: Partial<Options<CreatePersonData>>
): UseMutationOptions<CreatePersonResponse, CreatePersonError, Options<CreatePersonData>> => {
  const mutationOptions: UseMutationOptions<
    CreatePersonResponse,
    CreatePersonError,
    Options<CreatePersonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.createPerson({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete person
 */
export const deletePersonMutation = (
  options?: Partial<Options<DeletePersonData>>
): UseMutationOptions<DeletePersonResponse, DeletePersonError, Options<DeletePersonData>> => {
  const mutationOptions: UseMutationOptions<
    DeletePersonResponse,
    DeletePersonError,
    Options<DeletePersonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.deletePerson({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update person
 */
export const updatePersonMutation = (
  options?: Partial<Options<UpdatePersonData>>
): UseMutationOptions<UpdatePersonResponse, UpdatePersonError, Options<UpdatePersonData>> => {
  const mutationOptions: UseMutationOptions<
    UpdatePersonResponse,
    UpdatePersonError,
    Options<UpdatePersonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.updatePerson({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const invitePersonQueryKey = (options: Options<InvitePersonData>) =>
  createQueryKey('invitePerson', options)

/**
 * Invite person
 * Sends an invitation link to a person at the address provided in `dest`, allowing them to register an account assigned with a specified `role`.
 */
export const invitePersonOptions = (options: Options<InvitePersonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await PeopleService.invitePerson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: invitePersonQueryKey(options)
  })
}

/**
 * Invite person
 * Sends an invitation link to a person at the address provided in `dest`, allowing them to register an account assigned with a specified `role`.
 */
export const invitePersonMutation = (
  options?: Partial<Options<InvitePersonData>>
): UseMutationOptions<InvitePersonResponse, InvitePersonError, Options<InvitePersonData>> => {
  const mutationOptions: UseMutationOptions<
    InvitePersonResponse,
    InvitePersonError,
    Options<InvitePersonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await PeopleService.invitePerson({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listProgramsQueryKey = (options?: Options<ListProgramsData>) =>
  createQueryKey('listPrograms', options)

/**
 * List programs
 */
export const listProgramsOptions = (options?: Options<ListProgramsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.listPrograms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listProgramsQueryKey(options)
  })
}

export const createProgramQueryKey = (options: Options<CreateProgramData>) =>
  createQueryKey('createProgram', options)

/**
 * Create program
 */
export const createProgramOptions = (options: Options<CreateProgramData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await DatasetsService.createProgram({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createProgramQueryKey(options)
  })
}

/**
 * Create program
 */
export const createProgramMutation = (
  options?: Partial<Options<CreateProgramData>>
): UseMutationOptions<CreateProgramResponse, CreateProgramError, Options<CreateProgramData>> => {
  const mutationOptions: UseMutationOptions<
    CreateProgramResponse,
    CreateProgramError,
    Options<CreateProgramData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DatasetsService.createProgram({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete program
 */
export const deleteProgramMutation = (
  options?: Partial<Options<DeleteProgramData>>
): UseMutationOptions<DeleteProgramResponse, DeleteProgramError, Options<DeleteProgramData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteProgramResponse,
    DeleteProgramError,
    Options<DeleteProgramData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DatasetsService.deleteProgram({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update program
 */
export const updateProgramMutation = (
  options?: Partial<Options<UpdateProgramData>>
): UseMutationOptions<UpdateProgramResponse, UpdateProgramError, Options<UpdateProgramData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateProgramResponse,
    UpdateProgramError,
    Options<UpdateProgramData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await DatasetsService.updateProgram({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listArticlesQueryKey = (options?: Options<ListArticlesData>) =>
  createQueryKey('listArticles', options)

/**
 * List articles
 */
export const listArticlesOptions = (options?: Options<ListArticlesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ReferencesService.listArticles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listArticlesQueryKey(options)
  })
}

export const createArticleQueryKey = (options: Options<CreateArticleData>) =>
  createQueryKey('createArticle', options)

/**
 * Create article
 */
export const createArticleOptions = (options: Options<CreateArticleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ReferencesService.createArticle({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createArticleQueryKey(options)
  })
}

/**
 * Create article
 */
export const createArticleMutation = (
  options?: Partial<Options<CreateArticleData>>
): UseMutationOptions<CreateArticleResponse, CreateArticleError, Options<CreateArticleData>> => {
  const mutationOptions: UseMutationOptions<
    CreateArticleResponse,
    CreateArticleError,
    Options<CreateArticleData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ReferencesService.createArticle({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete article
 */
export const deleteArticleMutation = (
  options?: Partial<Options<DeleteArticleData>>
): UseMutationOptions<DeleteArticleResponse, DeleteArticleError, Options<DeleteArticleData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteArticleResponse,
    DeleteArticleError,
    Options<DeleteArticleData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ReferencesService.deleteArticle({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update article
 */
export const updateArticleMutation = (
  options?: Partial<Options<UpdateArticleData>>
): UseMutationOptions<UpdateArticleResponse, UpdateArticleError, Options<UpdateArticleData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateArticleResponse,
    UpdateArticleError,
    Options<UpdateArticleData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ReferencesService.updateArticle({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listSamplingMethodsQueryKey = (options?: Options<ListSamplingMethodsData>) =>
  createQueryKey('listSamplingMethods', options)

/**
 * List sampling methods
 */
export const listSamplingMethodsOptions = (options?: Options<ListSamplingMethodsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.listSamplingMethods({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listSamplingMethodsQueryKey(options)
  })
}

export const createSamplingMethodQueryKey = (options: Options<CreateSamplingMethodData>) =>
  createQueryKey('createSamplingMethod', options)

/**
 * Create sampling method
 */
export const createSamplingMethodOptions = (options: Options<CreateSamplingMethodData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.createSamplingMethod({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createSamplingMethodQueryKey(options)
  })
}

/**
 * Create sampling method
 */
export const createSamplingMethodMutation = (
  options?: Partial<Options<CreateSamplingMethodData>>
): UseMutationOptions<
  CreateSamplingMethodResponse,
  CreateSamplingMethodError,
  Options<CreateSamplingMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateSamplingMethodResponse,
    CreateSamplingMethodError,
    Options<CreateSamplingMethodData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.createSamplingMethod({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete sampling method
 */
export const deleteSamplingMethodMutation = (
  options?: Partial<Options<DeleteSamplingMethodData>>
): UseMutationOptions<
  DeleteSamplingMethodResponse,
  DeleteSamplingMethodError,
  Options<DeleteSamplingMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteSamplingMethodResponse,
    DeleteSamplingMethodError,
    Options<DeleteSamplingMethodData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.deleteSamplingMethod({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update sampling method
 */
export const updateSamplingMethodMutation = (
  options?: Partial<Options<UpdateSamplingMethodData>>
): UseMutationOptions<
  UpdateSamplingMethodResponse,
  UpdateSamplingMethodError,
  Options<UpdateSamplingMethodData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSamplingMethodResponse,
    UpdateSamplingMethodError,
    Options<UpdateSamplingMethodData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.updateSamplingMethod({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const createSamplingQueryKey = (options: Options<CreateSamplingData>) =>
  createQueryKey('createSampling', options)

/**
 * Create sampling action
 */
export const createSamplingOptions = (options: Options<CreateSamplingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SamplingService.createSampling({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createSamplingQueryKey(options)
  })
}

/**
 * Create sampling action
 */
export const createSamplingMutation = (
  options?: Partial<Options<CreateSamplingData>>
): UseMutationOptions<CreateSamplingResponse, CreateSamplingError, Options<CreateSamplingData>> => {
  const mutationOptions: UseMutationOptions<
    CreateSamplingResponse,
    CreateSamplingError,
    Options<CreateSamplingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.createSampling({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete sampling action
 */
export const deleteSamplingMutation = (
  options?: Partial<Options<DeleteSamplingData>>
): UseMutationOptions<DeleteSamplingResponse, DeleteSamplingError, Options<DeleteSamplingData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteSamplingResponse,
    DeleteSamplingError,
    Options<DeleteSamplingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.deleteSampling({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Update sampling action
 */
export const updateSamplingMutation = (
  options?: Partial<Options<UpdateSamplingData>>
): UseMutationOptions<UpdateSamplingResponse, UpdateSamplingError, Options<UpdateSamplingData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateSamplingResponse,
    UpdateSamplingError,
    Options<UpdateSamplingData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SamplingService.updateSampling({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const samplingAddExternalOccurrenceQueryKey = (
  options: Options<SamplingAddExternalOccurrenceData>
) => createQueryKey('samplingAddExternalOccurrence', options)

/**
 * Add occurrence from sampling
 * Register new occurrence resulting from the sampling action
 */
export const samplingAddExternalOccurrenceOptions = (
  options: Options<SamplingAddExternalOccurrenceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.samplingAddExternalOccurrence({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: samplingAddExternalOccurrenceQueryKey(options)
  })
}

/**
 * Add occurrence from sampling
 * Register new occurrence resulting from the sampling action
 */
export const samplingAddExternalOccurrenceMutation = (
  options?: Partial<Options<SamplingAddExternalOccurrenceData>>
): UseMutationOptions<
  SamplingAddExternalOccurrenceResponse,
  SamplingAddExternalOccurrenceError,
  Options<SamplingAddExternalOccurrenceData>
> => {
  const mutationOptions: UseMutationOptions<
    SamplingAddExternalOccurrenceResponse,
    SamplingAddExternalOccurrenceError,
    Options<SamplingAddExternalOccurrenceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await OccurrencesService.samplingAddExternalOccurrence({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listSequencesQueryKey = (options?: Options<ListSequencesData>) =>
  createQueryKey('listSequences', options)

/**
 * List sequences
 */
export const listSequencesOptions = (options?: Options<ListSequencesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SequencesService.listSequences({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listSequencesQueryKey(options)
  })
}

/**
 * Delete sequence
 */
export const deleteSequenceMutation = (
  options?: Partial<Options<DeleteSequenceData>>
): UseMutationOptions<DeleteSequenceResponse, DeleteSequenceError, Options<DeleteSequenceData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteSequenceResponse,
    DeleteSequenceError,
    Options<DeleteSequenceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SequencesService.deleteSequence({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getSequenceQueryKey = (options: Options<GetSequenceData>) =>
  createQueryKey('getSequence', options)

/**
 * Get sequence
 */
export const getSequenceOptions = (options: Options<GetSequenceData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SequencesService.getSequence({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getSequenceQueryKey(options)
  })
}

export const emailSettingsQueryKey = (options?: Options<EmailSettingsData>) =>
  createQueryKey('emailSettings', options)

/**
 * Email settings
 */
export const emailSettingsOptions = (options?: Options<EmailSettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.emailSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: emailSettingsQueryKey(options)
  })
}

export const updateEmailSettingsQueryKey = (options: Options<UpdateEmailSettingsData>) =>
  createQueryKey('updateEmailSettings', options)

/**
 * Update email settings
 */
export const updateEmailSettingsOptions = (options: Options<UpdateEmailSettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.updateEmailSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: updateEmailSettingsQueryKey(options)
  })
}

/**
 * Update email settings
 */
export const updateEmailSettingsMutation = (
  options?: Partial<Options<UpdateEmailSettingsData>>
): UseMutationOptions<
  UpdateEmailSettingsResponse,
  UpdateEmailSettingsError,
  Options<UpdateEmailSettingsData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateEmailSettingsResponse,
    UpdateEmailSettingsError,
    Options<UpdateEmailSettingsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.updateEmailSettings({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const testSmtpQueryKey = (options: Options<TestSmtpData>) =>
  createQueryKey('testSmtp', options)

/**
 * Test SMTP connection
 */
export const testSmtpOptions = (options: Options<TestSmtpData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.testSmtp({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: testSmtpQueryKey(options)
  })
}

/**
 * Test SMTP connection
 */
export const testSmtpMutation = (
  options?: Partial<Options<TestSmtpData>>
): UseMutationOptions<TestSmtpResponse, TestSmtpError, Options<TestSmtpData>> => {
  const mutationOptions: UseMutationOptions<
    TestSmtpResponse,
    TestSmtpError,
    Options<TestSmtpData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.testSmtp({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const setAppIconQueryKey = (options?: Options<SetAppIconData>) =>
  createQueryKey('setAppIcon', options)

/**
 * Set app icon
 */
export const setAppIconOptions = (options?: Options<SetAppIconData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.setAppIcon({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: setAppIconQueryKey(options)
  })
}

/**
 * Set app icon
 */
export const setAppIconMutation = (
  options?: Partial<Options<SetAppIconData>>
): UseMutationOptions<SetAppIconResponse, SetAppIconError, Options<SetAppIconData>> => {
  const mutationOptions: UseMutationOptions<
    SetAppIconResponse,
    SetAppIconError,
    Options<SetAppIconData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.setAppIcon({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const instanceSettingsQueryKey = (options?: Options<InstanceSettingsData>) =>
  createQueryKey('instanceSettings', options)

/**
 * Instance settings
 */
export const instanceSettingsOptions = (options?: Options<InstanceSettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.instanceSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: instanceSettingsQueryKey(options)
  })
}

export const updateInstanceSettingsQueryKey = (options: Options<UpdateInstanceSettingsData>) =>
  createQueryKey('updateInstanceSettings', options)

/**
 * Update instance settings
 */
export const updateInstanceSettingsOptions = (options: Options<UpdateInstanceSettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.updateInstanceSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: updateInstanceSettingsQueryKey(options)
  })
}

/**
 * Update instance settings
 */
export const updateInstanceSettingsMutation = (
  options?: Partial<Options<UpdateInstanceSettingsData>>
): UseMutationOptions<
  UpdateInstanceSettingsResponse,
  UpdateInstanceSettingsError,
  Options<UpdateInstanceSettingsData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateInstanceSettingsResponse,
    UpdateInstanceSettingsError,
    Options<UpdateInstanceSettingsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.updateInstanceSettings({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listDataFeedsQueryKey = (options?: Options<ListDataFeedsData>) =>
  createQueryKey('listDataFeeds', options)

/**
 * List saved data feeds
 */
export const listDataFeedsOptions = (options?: Options<ListDataFeedsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.listDataFeeds({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listDataFeedsQueryKey(options)
  })
}

export const createDataFeedQueryKey = (options: Options<CreateDataFeedData>) =>
  createQueryKey('createDataFeed', options)

/**
 * Save data feed
 */
export const createDataFeedOptions = (options: Options<CreateDataFeedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.createDataFeed({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createDataFeedQueryKey(options)
  })
}

/**
 * Save data feed
 */
export const createDataFeedMutation = (
  options?: Partial<Options<CreateDataFeedData>>
): UseMutationOptions<CreateDataFeedResponse, CreateDataFeedError, Options<CreateDataFeedData>> => {
  const mutationOptions: UseMutationOptions<
    CreateDataFeedResponse,
    CreateDataFeedError,
    Options<CreateDataFeedData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.createDataFeed({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listMapPresetsQueryKey = (options?: Options<ListMapPresetsData>) =>
  createQueryKey('listMapPresets', options)

/**
 * List saved map presets
 */
export const listMapPresetsOptions = (options?: Options<ListMapPresetsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.listMapPresets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listMapPresetsQueryKey(options)
  })
}

/**
 * Save map preset
 * Creates a new map preset or updates an existing one. If the preset already exists and is owned by the current user, it will be updated. Admins can update global presets.
 */
export const createUpdateMapPresetMutation = (
  options?: Partial<Options<CreateUpdateMapPresetData>>
): UseMutationOptions<
  CreateUpdateMapPresetResponse,
  CreateUpdateMapPresetError,
  Options<CreateUpdateMapPresetData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateUpdateMapPresetResponse,
    CreateUpdateMapPresetError,
    Options<CreateUpdateMapPresetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.createUpdateMapPreset({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete map preset
 * Deletes a map preset by name. Only the owner of the preset or an admin can delete it.
 */
export const deleteMapPresetMutation = (
  options?: Partial<Options<DeleteMapPresetData>>
): UseMutationOptions<
  DeleteMapPresetResponse,
  DeleteMapPresetError,
  Options<DeleteMapPresetData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteMapPresetResponse,
    DeleteMapPresetError,
    Options<DeleteMapPresetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.deleteMapPreset({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const securitySettingsQueryKey = (options?: Options<SecuritySettingsData>) =>
  createQueryKey('securitySettings', options)

/**
 * Security settings
 */
export const securitySettingsOptions = (options?: Options<SecuritySettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.securitySettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: securitySettingsQueryKey(options)
  })
}

export const updateSecuritySettingsQueryKey = (options: Options<UpdateSecuritySettingsData>) =>
  createQueryKey('updateSecuritySettings', options)

/**
 * Update security settings
 */
export const updateSecuritySettingsOptions = (options: Options<UpdateSecuritySettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.updateSecuritySettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: updateSecuritySettingsQueryKey(options)
  })
}

/**
 * Update security settings
 */
export const updateSecuritySettingsMutation = (
  options?: Partial<Options<UpdateSecuritySettingsData>>
): UseMutationOptions<
  UpdateSecuritySettingsResponse,
  UpdateSecuritySettingsError,
  Options<UpdateSecuritySettingsData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateSecuritySettingsResponse,
    UpdateSecuritySettingsError,
    Options<UpdateSecuritySettingsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.updateSecuritySettings({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const serviceSettingsQueryKey = (options?: Options<ServiceSettingsData>) =>
  createQueryKey('serviceSettings', options)

/**
 * Service settings
 */
export const serviceSettingsOptions = (options?: Options<ServiceSettingsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await SettingsService.serviceSettings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: serviceSettingsQueryKey(options)
  })
}

/**
 * Update service settings
 */
export const updateServiceSettingsMutation = (
  options?: Partial<Options<UpdateServiceSettingsData>>
): UseMutationOptions<
  UpdateServiceSettingsResponse,
  UpdateServiceSettingsError,
  Options<UpdateServiceSettingsData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateServiceSettingsResponse,
    UpdateServiceSettingsError,
    Options<UpdateServiceSettingsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await SettingsService.updateServiceSettings({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listSitesQueryKey = (options?: Options<ListSitesData>) =>
  createQueryKey('listSites', options)

/**
 * List sites
 * List all registered sites
 */
export const listSitesOptions = (options?: Options<ListSitesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.listSites({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listSitesQueryKey(options)
  })
}

export const createSiteQueryKey = (options: Options<CreateSiteData>) =>
  createQueryKey('createSite', options)

/**
 * Create site
 * Create site infos using its code
 */
export const createSiteOptions = (options: Options<CreateSiteData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.createSite({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createSiteQueryKey(options)
  })
}

/**
 * Create site
 * Create site infos using its code
 */
export const createSiteMutation = (
  options?: Partial<Options<CreateSiteData>>
): UseMutationOptions<CreateSiteResponse, CreateSiteError, Options<CreateSiteData>> => {
  const mutationOptions: UseMutationOptions<
    CreateSiteResponse,
    CreateSiteError,
    Options<CreateSiteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LocationService.createSite({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getSiteQueryKey = (options: Options<GetSiteData>) => createQueryKey('getSite', options)

/**
 * Get site
 * Get site infos using its code
 */
export const getSiteOptions = (options: Options<GetSiteData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.getSite({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getSiteQueryKey(options)
  })
}

/**
 * Update site
 * Update site infos using its code
 */
export const updateSiteMutation = (
  options?: Partial<Options<UpdateSiteData>>
): UseMutationOptions<UpdateSiteResponse, UpdateSiteError, Options<UpdateSiteData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateSiteResponse,
    UpdateSiteError,
    Options<UpdateSiteData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LocationService.updateSite({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const listSiteEventsQueryKey = (options: Options<ListSiteEventsData>) =>
  createQueryKey('listSiteEvents', options)

/**
 * List site events
 */
export const listSiteEventsOptions = (options: Options<ListSiteEventsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.listSiteEvents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listSiteEventsQueryKey(options)
  })
}

export const createEventQueryKey = (options: Options<CreateEventData>) =>
  createQueryKey('createEvent', options)

/**
 * Create event
 * Register event on a site identified by its code
 */
export const createEventOptions = (options: Options<CreateEventData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await LocationService.createEvent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createEventQueryKey(options)
  })
}

/**
 * Create event
 * Register event on a site identified by its code
 */
export const createEventMutation = (
  options?: Partial<Options<CreateEventData>>
): UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> => {
  const mutationOptions: UseMutationOptions<
    CreateEventResponse,
    CreateEventError,
    Options<CreateEventData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await LocationService.createEvent({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const siteAddExternalOccurrenceQueryKey = (
  options: Options<SiteAddExternalOccurrenceData>
) => createQueryKey('siteAddExternalOccurrence', options)

/**
 * Add occurrence at site
 * Register new occurrence at site, including event + sampling specification and biomaterial identification
 */
export const siteAddExternalOccurrenceOptions = (
  options: Options<SiteAddExternalOccurrenceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await OccurrencesService.siteAddExternalOccurrence({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: siteAddExternalOccurrenceQueryKey(options)
  })
}

/**
 * Add occurrence at site
 * Register new occurrence at site, including event + sampling specification and biomaterial identification
 */
export const siteAddExternalOccurrenceMutation = (
  options?: Partial<Options<SiteAddExternalOccurrenceData>>
): UseMutationOptions<
  SiteAddExternalOccurrenceResponse,
  SiteAddExternalOccurrenceError,
  Options<SiteAddExternalOccurrenceData>
> => {
  const mutationOptions: UseMutationOptions<
    SiteAddExternalOccurrenceResponse,
    SiteAddExternalOccurrenceError,
    Options<SiteAddExternalOccurrenceData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await OccurrencesService.siteAddExternalOccurrence({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getTaxonomyQueryKey = (options?: Options<GetTaxonomyData>) =>
  createQueryKey('getTaxonomy', options)

/**
 * Get taxonomy
 */
export const getTaxonomyOptions = (options?: Options<GetTaxonomyData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await TaxonomyService.getTaxonomy({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getTaxonomyQueryKey(options)
  })
}

export const listTaxaQueryKey = (options?: Options<ListTaxaData>) =>
  createQueryKey('listTaxa', options)

/**
 * List taxa
 */
export const listTaxaOptions = (options?: Options<ListTaxaData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await TaxonomyService.listTaxa({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: listTaxaQueryKey(options)
  })
}

export const createTaxonQueryKey = (options: Options<CreateTaxonData>) =>
  createQueryKey('createTaxon', options)

/**
 * Create taxon
 */
export const createTaxonOptions = (options: Options<CreateTaxonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await TaxonomyService.createTaxon({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: createTaxonQueryKey(options)
  })
}

/**
 * Create taxon
 */
export const createTaxonMutation = (
  options?: Partial<Options<CreateTaxonData>>
): UseMutationOptions<CreateTaxonResponse, CreateTaxonError, Options<CreateTaxonData>> => {
  const mutationOptions: UseMutationOptions<
    CreateTaxonResponse,
    CreateTaxonError,
    Options<CreateTaxonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await TaxonomyService.createTaxon({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

/**
 * Delete taxon
 */
export const deleteTaxonMutation = (
  options?: Partial<Options<DeleteTaxonData>>
): UseMutationOptions<DeleteTaxonResponse, DeleteTaxonError, Options<DeleteTaxonData>> => {
  const mutationOptions: UseMutationOptions<
    DeleteTaxonResponse,
    DeleteTaxonError,
    Options<DeleteTaxonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await TaxonomyService.deleteTaxon({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}

export const getTaxonQueryKey = (options: Options<GetTaxonData>) =>
  createQueryKey('getTaxon', options)

/**
 * Get taxon
 */
export const getTaxonOptions = (options: Options<GetTaxonData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await TaxonomyService.getTaxon({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true
      })
      return data
    },
    queryKey: getTaxonQueryKey(options)
  })
}

/**
 * Update taxon
 */
export const updateTaxonMutation = (
  options?: Partial<Options<UpdateTaxonData>>
): UseMutationOptions<UpdateTaxonResponse, UpdateTaxonError, Options<UpdateTaxonData>> => {
  const mutationOptions: UseMutationOptions<
    UpdateTaxonResponse,
    UpdateTaxonError,
    Options<UpdateTaxonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await TaxonomyService.updateTaxon({
        ...options,
        ...localOptions,
        throwOnError: true
      })
      return data
    }
  }
  return mutationOptions
}
