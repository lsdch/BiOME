// This file is auto-generated by @hey-api/openapi-ts

export const $AbioticMeasurement = {
  additionalProperties: false,
  properties: {
    id: {
      format: 'uuid',
      type: 'string'
    },
    param: {
      $ref: '#/components/schemas/AbioticParameter'
    },
    value: {
      format: 'float',
      type: 'number'
    }
  },
  required: ['id', 'param', 'value'],
  type: 'object'
} as const

export const $AbioticParameter = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/AbioticParameter.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    unit: {
      type: 'string'
    }
  },
  required: ['unit', 'meta', 'id', 'label', 'code'],
  type: 'object'
} as const

export const $AbioticParameterInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/AbioticParameterInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    label: {
      type: 'string'
    },
    unit: {
      type: 'string'
    }
  },
  required: ['unit', 'label', 'code'],
  type: 'object'
} as const

export const $AbioticParameterUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/AbioticParameterUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: ['string', 'null']
    },
    label: {
      type: 'string'
    },
    unit: {
      type: 'string'
    }
  },
  required: ['unit'],
  type: 'object'
} as const

export const $Article = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Article.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    authors: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    doi: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    journal: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    original_source: {
      type: 'boolean'
    },
    title: {
      type: 'string'
    },
    verbatim: {
      type: 'string'
    },
    year: {
      format: 'int32',
      type: 'integer'
    }
  },
  required: ['id', 'code', 'authors', 'year', 'original_source', 'meta'],
  type: 'object'
} as const

export const $ArticleInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ArticleInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    authors: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    doi: {
      type: 'string'
    },
    journal: {
      type: 'string'
    },
    title: {
      type: 'string'
    },
    verbatim: {
      type: 'string'
    },
    year: {
      format: 'int32',
      minimum: 1500,
      type: 'integer'
    }
  },
  required: ['authors', 'year'],
  type: 'object'
} as const

export const $ArticleUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ArticleUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    authors: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: ['string', 'null']
    },
    doi: {
      type: ['string', 'null']
    },
    journal: {
      type: ['string', 'null']
    },
    title: {
      type: ['string', 'null']
    },
    verbatim: {
      type: ['string', 'null']
    },
    year: {
      format: 'int32',
      minimum: 1500,
      type: 'integer'
    }
  },
  type: 'object'
} as const

export const $Assertion = {
  additionalProperties: false,
  properties: {
    group: {
      $ref: '#/components/schemas/Group'
    },
    label: {
      type: 'string'
    },
    name: {
      type: 'string'
    },
    value: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $AuthenticationResponse = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/AuthenticationResponse.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    auth_token: {
      description: 'JSON Web Token',
      examples: ['xxxxx.yyyyy.zzzzz'],
      type: 'string'
    },
    auth_token_expiration: {
      description: 'Time at which auth token expires',
      format: 'date-time',
      type: 'string'
    },
    messages: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    refresh_token: {
      description: 'Session refresh token',
      type: 'string'
    },
    user: {
      $ref: '#/components/schemas/User'
    }
  },
  required: ['messages', 'user', 'auth_token', 'refresh_token', 'auth_token_expiration'],
  type: 'object'
} as const

export const $BibSearchResults = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/BibSearchResults.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    items: {
      items: {
        $ref: '#/components/schemas/Message'
      },
      type: 'array'
    },
    total: {
      format: 'int64',
      type: 'integer'
    }
  },
  required: ['total', 'items'],
  type: 'object'
} as const

export const $BioMatSortKey = {
  enum: [
    'code',
    'site',
    'sampling_date',
    'identified_on',
    'taxon',
    'identified_by',
    'last_updated'
  ],
  title: 'BioMatSortKey',
  type: 'string'
} as const

export const $BioMaterial = {
  additionalProperties: false,
  properties: {
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    code_history: {
      items: {
        $ref: '#/components/schemas/CodeHistory'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    external: {
      $ref: '#/components/schemas/OptionalExternalBioMatSpecific'
    },
    has_sequences: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    is_congruent: {
      type: 'boolean'
    },
    is_homogenous: {
      type: 'boolean'
    },
    is_type: {
      type: 'boolean'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInner'
    },
    seq_consensus: {
      $ref: '#/components/schemas/OptionalTaxon'
    }
  },
  required: [
    'has_sequences',
    'is_homogenous',
    'is_congruent',
    'meta',
    'sampling',
    'identification',
    'id',
    'category',
    'is_type',
    'code'
  ],
  type: 'object'
} as const

export const $BioMaterialWithDetails = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/BioMaterialWithDetails.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    code_history: {
      items: {
        $ref: '#/components/schemas/CodeHistory'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    event: {
      $ref: '#/components/schemas/EventWithParticipants'
    },
    external: {
      $ref: '#/components/schemas/OptionalExternalBioMatSpecific'
    },
    has_sequences: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    is_congruent: {
      type: 'boolean'
    },
    is_homogenous: {
      type: 'boolean'
    },
    is_type: {
      type: 'boolean'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    sampling: {
      $ref: '#/components/schemas/Sampling'
    },
    seq_consensus: {
      $ref: '#/components/schemas/OptionalTaxon'
    }
  },
  required: [
    'event',
    'has_sequences',
    'is_homogenous',
    'is_congruent',
    'meta',
    'sampling',
    'identification',
    'id',
    'category',
    'is_type',
    'code'
  ],
  type: 'object'
} as const

export const $ClinicalTrailNumber = {
  additionalProperties: false,
  properties: {
    'clinical-trail-number': {
      type: 'string'
    },
    registry: {
      type: 'string'
    },
    type: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $CodeHistory = {
  additionalProperties: false,
  properties: {
    code: {
      type: 'string'
    },
    time: {
      format: 'date-time',
      type: 'string'
    }
  },
  required: ['code', 'time'],
  type: 'object'
} as const

export const $CompositeDate = {
  additionalProperties: false,
  properties: {
    day: {
      default: 1,
      format: 'int32',
      maximum: 31,
      minimum: 1,
      type: 'integer'
    },
    month: {
      default: 1,
      format: 'int32',
      maximum: 12,
      minimum: 1,
      type: 'integer'
    },
    year: {
      format: 'int32',
      maximum: 3000,
      minimum: 1500,
      type: 'integer'
    }
  },
  type: 'object'
} as const

export const $ContentDomain = {
  additionalProperties: false,
  properties: {
    'crossmark-restriction': {
      type: 'boolean'
    },
    domain: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  type: 'object'
} as const

export const $Coordinates = {
  additionalProperties: false,
  properties: {
    latitude: {
      examples: [43.5684],
      format: 'float',
      maximum: 90,
      minimum: -90,
      type: 'number'
    },
    longitude: {
      examples: [3.5678],
      format: 'float',
      maximum: 180,
      minimum: -180,
      type: 'number'
    },
    precision: {
      $ref: '#/components/schemas/CoordinatesPrecision',
      description: 'Where the coordinates point to'
    }
  },
  required: ['precision', 'latitude', 'longitude'],
  type: 'object'
} as const

export const $CoordinatesPrecision = {
  enum: ['<100m', '<1km', '<10km', '10-100km', 'Unknown'],
  title: 'CoordinatesPrecision',
  type: 'string'
} as const

export const $Country = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Country.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['DE'],
      type: 'string'
    },
    continent: {
      examples: ['Europe'],
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    name: {
      examples: ['Germany'],
      type: 'string'
    },
    subcontinent: {
      examples: ['Western Europe'],
      type: 'string'
    }
  },
  required: ['id', 'name', 'code', 'continent', 'subcontinent'],
  type: 'object'
} as const

export const $CountryWithSitesCount = {
  additionalProperties: false,
  properties: {
    code: {
      examples: ['DE'],
      type: 'string'
    },
    continent: {
      examples: ['Europe'],
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    name: {
      examples: ['Germany'],
      type: 'string'
    },
    sites_count: {
      format: 'int64',
      type: 'integer'
    },
    subcontinent: {
      examples: ['Western Europe'],
      type: 'string'
    }
  },
  required: ['sites_count', 'id', 'name', 'code', 'continent', 'subcontinent'],
  type: 'object'
} as const

export const $CreateExternalBioMatInputBody = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/CreateExternalBioMatInputBody.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    bio_material: {
      $ref: '#/components/schemas/ExternalBioMatInput'
    },
    event: {
      $ref: '#/components/schemas/EventInput'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInput'
    },
    site: {
      $ref: '#/components/schemas/SiteInput'
    }
  },
  required: ['site', 'event', 'sampling', 'bio_material'],
  type: 'object'
} as const

export const $CrossRefPerson = {
  additionalProperties: false,
  properties: {
    ORCID: {
      type: 'string'
    },
    affiliation: {
      items: {
        $ref: '#/components/schemas/Organization'
      },
      type: 'array'
    },
    'authenticated-orcid': {
      type: 'boolean'
    },
    family: {
      type: 'string'
    },
    given: {
      type: 'string'
    },
    name: {
      type: 'string'
    },
    prefix: {
      type: 'string'
    },
    sequence: {
      type: 'string'
    },
    suffix: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $CurrentUserResponse = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/CurrentUserResponse.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    auth_token: {
      description: 'JSON Web Token',
      examples: ['xxxxx.yyyyy.zzzzz'],
      type: 'string'
    },
    auth_token_expiration: {
      description: 'Time at which auth token expires',
      format: 'date-time',
      type: 'string'
    },
    refresh_token: {
      description: 'Session refresh token',
      type: 'string'
    },
    user: {
      $ref: '#/components/schemas/User'
    }
  },
  required: ['user', 'auth_token', 'refresh_token', 'auth_token_expiration'],
  type: 'object'
} as const

export const $DataSource = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/DataSource.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    link_template: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    url: {
      type: 'string'
    }
  },
  required: ['meta', 'id', 'label', 'code'],
  type: 'object'
} as const

export const $DataSourceInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/DataSourceInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    label: {
      type: 'string'
    },
    link_template: {
      type: 'string'
    },
    url: {
      type: 'string'
    }
  },
  required: ['label', 'code'],
  type: 'object'
} as const

export const $DataSourceUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/DataSourceUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: ['string', 'null']
    },
    label: {
      type: 'string'
    },
    link_template: {
      type: ['string', 'null']
    },
    url: {
      type: ['string', 'null']
    }
  },
  type: 'object'
} as const

export const $Dataset = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Dataset.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/DatasetCategory'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    maintainers: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    pinned: {
      type: 'boolean'
    },
    slug: {
      type: 'string'
    }
  },
  required: ['maintainers', 'meta', 'id', 'label', 'slug', 'pinned', 'description', 'category'],
  type: 'object'
} as const

export const $DatasetCategory = {
  enum: ['Site', 'Occurrence', 'Seq'],
  title: 'DatasetCategory',
  type: 'string'
} as const

export const $DatasetInner = {
  additionalProperties: false,
  properties: {
    category: {
      $ref: '#/components/schemas/DatasetCategory'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    pinned: {
      type: 'boolean'
    },
    slug: {
      type: 'string'
    }
  },
  required: ['id', 'label', 'slug', 'pinned', 'description', 'category'],
  type: 'object'
} as const

export const $DatasetUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/DatasetUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    description: {
      type: ['string', 'null']
    },
    label: {
      maxLength: 32,
      minLength: 4,
      type: 'string'
    },
    maintainers: {
      description:
        'Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    pinned: {
      type: ['boolean', 'null']
    }
  },
  type: 'object'
} as const

export const $DateObject = {
  additionalProperties: false,
  properties: {
    'date-parts': {
      items: {
        items: {
          format: 'int64',
          type: 'integer'
        },
        type: 'array'
      },
      type: 'array'
    },
    'date-time': {
      type: 'string'
    },
    timestamp: {
      format: 'int64',
      type: 'integer'
    }
  },
  type: 'object'
} as const

export const $DatePrecision = {
  enum: ['Day', 'Month', 'Year', 'Unknown'],
  title: 'DatePrecision',
  type: 'string'
} as const

export const $DateRange = {
  additionalProperties: false,
  properties: {
    'end-date': {
      $ref: '#/components/schemas/DateObject'
    },
    'start-date': {
      $ref: '#/components/schemas/DateObject'
    }
  },
  type: 'object'
} as const

export const $DateWithPrecision = {
  additionalProperties: false,
  properties: {
    date: {
      format: 'date-time',
      type: 'string'
    },
    precision: {
      $ref: '#/components/schemas/DatePrecision'
    }
  },
  required: ['precision'],
  type: 'object'
} as const

export const $DateWithPrecisionInput = {
  additionalProperties: false,
  properties: {
    date: {
      $ref: '#/components/schemas/CompositeDate'
    },
    precision: {
      $ref: '#/components/schemas/DatePrecision'
    }
  },
  required: ['date', 'precision'],
  type: 'object'
} as const

export const $EmailSettings = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/EmailSettings.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    from_address: {
      format: 'email',
      type: 'string'
    },
    from_name: {
      type: 'string'
    },
    host: {
      description: 'SMTP domain that handles email sending',
      format: 'hostname',
      type: 'string'
    },
    password: {
      description: 'SMTP password',
      type: 'string'
    },
    port: {
      description: 'SMTP port',
      format: 'int32',
      minimum: 1,
      type: 'integer'
    },
    user: {
      description: 'SMTP login',
      format: 'uri',
      type: 'string'
    }
  },
  required: ['from_name', 'from_address', 'host', 'port', 'user', 'password'],
  type: 'object'
} as const

export const $EmailSettingsInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/EmailSettingsInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    from_address: {
      format: 'email',
      type: 'string'
    },
    from_name: {
      type: 'string'
    },
    host: {
      description: 'SMTP domain that handles email sending',
      format: 'hostname',
      type: 'string'
    },
    password: {
      description: 'SMTP password',
      type: 'string'
    },
    port: {
      description: 'SMTP port',
      format: 'int32',
      minimum: 1,
      type: 'integer'
    },
    user: {
      description: 'SMTP login',
      format: 'uri',
      type: 'string'
    }
  },
  required: ['from_name', 'from_address', 'host', 'port', 'user', 'password'],
  type: 'object'
} as const

export const $ErrorDetail = {
  additionalProperties: false,
  properties: {
    location: {
      description: "Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'",
      type: 'string'
    },
    message: {
      description: 'Error message text',
      type: 'string'
    },
    value: {
      description: 'The value at the given location'
    }
  },
  type: 'object'
} as const

export const $ErrorModel = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ErrorModel.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    detail: {
      description: 'A human-readable explanation specific to this occurrence of the problem.',
      examples: ['Property foo is required but is missing.'],
      type: 'string'
    },
    errors: {
      description: 'Optional list of individual error details',
      items: {
        $ref: '#/components/schemas/ErrorDetail'
      },
      type: 'array'
    },
    instance: {
      description: 'A URI reference that identifies the specific occurrence of the problem.',
      examples: ['https://example.com/error-log/abc123'],
      format: 'uri',
      type: 'string'
    },
    status: {
      description: 'HTTP status code',
      examples: [400],
      format: 'int64',
      type: 'integer'
    },
    title: {
      description:
        'A short, human-readable summary of the problem type. This value should not change between occurrences of the error.',
      examples: ['Bad Request'],
      type: 'string'
    },
    type: {
      default: 'about:blank',
      description: 'A URI reference to human-readable documentation for the error.',
      examples: ['https://example.com/errors/example'],
      format: 'uri',
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Event = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Event.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    abiotic_measurements: {
      items: {
        $ref: '#/components/schemas/AbioticMeasurement'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    performed_by: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    performed_by_groups: {
      items: {
        $ref: '#/components/schemas/OrganisationInner'
      },
      type: 'array'
    },
    performed_on: {
      $ref: '#/components/schemas/DateWithPrecision'
    },
    samplings: {
      items: {
        $ref: '#/components/schemas/Sampling'
      },
      type: 'array'
    },
    site: {
      $ref: '#/components/schemas/SiteItem'
    },
    spottings: {
      items: {
        $ref: '#/components/schemas/Taxon'
      },
      type: 'array'
    }
  },
  required: ['meta', 'id', 'site', 'code', 'performed_on'],
  type: 'object'
} as const

export const $EventInner = {
  additionalProperties: false,
  properties: {
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    performed_on: {
      $ref: '#/components/schemas/DateWithPrecision'
    },
    site: {
      $ref: '#/components/schemas/SiteItem'
    }
  },
  required: ['id', 'site', 'code', 'performed_on'],
  type: 'object'
} as const

export const $EventInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/EventInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    performed_by: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    performed_by_groups: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    performed_on: {
      $ref: '#/components/schemas/DateWithPrecisionInput'
    }
  },
  required: ['performed_on'],
  type: 'object'
} as const

export const $EventUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/EventUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    comments: {
      type: ['string', 'null']
    },
    performed_by: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    performed_by_groups: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    performed_on: {
      $ref: '#/components/schemas/DateWithPrecisionInput'
    },
    spottings: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    }
  },
  type: 'object'
} as const

export const $EventWithParticipants = {
  additionalProperties: false,
  properties: {
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    performed_by: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    performed_by_groups: {
      items: {
        $ref: '#/components/schemas/OrganisationInner'
      },
      type: 'array'
    },
    performed_on: {
      $ref: '#/components/schemas/DateWithPrecision'
    },
    site: {
      $ref: '#/components/schemas/SiteItem'
    }
  },
  required: ['id', 'site', 'code', 'performed_on'],
  type: 'object'
} as const

export const $ExtSeqOrigin = {
  enum: ['Lab', 'DB', 'PersCom'],
  title: 'ExtSeqOrigin',
  type: 'string'
} as const

export const $ExtSeqSpecificsBioMaterial = {
  additionalProperties: false,
  properties: {
    origin: {
      $ref: '#/components/schemas/ExtSeqOrigin'
    },
    original_taxon: {
      type: 'string'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    referenced_in: {
      items: {
        $ref: '#/components/schemas/SeqReference'
      },
      type: 'array'
    },
    source_sample: {
      $ref: '#/components/schemas/OptionalBioMaterial'
    },
    specimen_identifier: {
      type: 'string'
    }
  },
  required: ['origin', 'specimen_identifier'],
  type: 'object'
} as const

export const $ExternalBioMatContent = {
  additionalProperties: false,
  properties: {
    sequences: {
      items: {
        $ref: '#/components/schemas/ExternalBioMatSequence'
      },
      type: 'array'
    },
    specimen: {
      type: 'string'
    }
  },
  required: ['specimen', 'sequences'],
  type: 'object'
} as const

export const $ExternalBioMatInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ExternalBioMatInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      description:
        'Unique code identifier for the bio material. Generated from taxon and sampling if not provided.',
      examples: ['Genus_sp[SITE|2001-01]'],
      type: 'string'
    },
    collection: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    content_description: {
      description: 'Description of the content of the bio material',
      examples: ['2 females, 1 juvenile male'],
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/IdentificationInput',
      description: 'Occurrence identification'
    },
    is_type: {
      description:
        'Flag indicating if the bio material is a type specimen, i.e. the reference specimen used to describe a new species.',
      type: 'boolean'
    },
    original_link: {
      type: 'string'
    },
    original_source: {
      type: 'string'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReferenceInput'
      },
      type: 'array'
    },
    quantity: {
      $ref: '#/components/schemas/Quantity'
    },
    vouchers: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  required: ['quantity', 'identification'],
  type: 'object'
} as const

export const $ExternalBioMatSequence = {
  additionalProperties: false,
  properties: {
    accession_number: {
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    code_history: {
      items: {
        $ref: '#/components/schemas/CodeHistory'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    gene: {
      $ref: '#/components/schemas/Gene'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    label: {
      type: 'string'
    },
    legacy: {
      $ref: '#/components/schemas/OptionalLegacySeqID'
    },
    origin: {
      $ref: '#/components/schemas/ExtSeqOrigin'
    },
    original_taxon: {
      type: 'string'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/Article'
      },
      type: 'array'
    },
    referenced_in: {
      items: {
        $ref: '#/components/schemas/SeqReference'
      },
      type: 'array'
    },
    sequence: {
      type: 'string'
    },
    specimen_identifier: {
      type: 'string'
    }
  },
  required: [
    'id',
    'category',
    'origin',
    'identification',
    'comments',
    'accession_number',
    'specimen_identifier',
    'original_taxon',
    'gene',
    'code'
  ],
  type: 'object'
} as const

export const $ExternalBioMatSpecific = {
  additionalProperties: false,
  properties: {
    archive: {
      $ref: '#/components/schemas/SpecimenVoucher'
    },
    comments: {
      type: 'string'
    },
    content: {
      items: {
        $ref: '#/components/schemas/ExternalBioMatContent'
      },
      type: 'array'
    },
    content_description: {
      type: 'string'
    },
    original_link: {
      type: 'string'
    },
    original_source: {
      $ref: '#/components/schemas/OptionalDataSource'
    },
    original_taxon: {
      type: 'string'
    },
    quantity: {
      $ref: '#/components/schemas/Quantity'
    }
  },
  required: ['quantity', 'archive', 'comments'],
  type: 'object'
} as const

export const $ExternalBioMatUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ExternalBioMatUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    collection: {
      type: ['string', 'null']
    },
    comments: {
      type: ['string', 'null']
    },
    content_description: {
      type: ['string', 'null']
    },
    identification: {
      $ref: '#/components/schemas/IdentificationUpdate'
    },
    is_type: {
      type: 'boolean'
    },
    original_link: {
      type: ['string', 'null']
    },
    original_source: {
      type: ['string', 'null']
    },
    original_taxon: {
      type: ['string', 'null']
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReferenceInput'
      },
      type: ['array', 'null']
    },
    quantity: {
      $ref: '#/components/schemas/Quantity'
    },
    sampling_id: {
      format: 'uuid',
      type: 'string'
    },
    vouchers: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  required: ['published_in', 'sampling_id'],
  type: 'object'
} as const

export const $ExternalOccurrenceAtEventInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ExternalOccurrenceAtEventInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    biomaterial: {
      $ref: '#/components/schemas/ExternalBioMatInput',
      description: 'New occurrence resulting from the sampling action'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInput',
      description: 'New sampling action during referenced event'
    }
  },
  required: ['sampling', 'biomaterial'],
  type: 'object'
} as const

export const $ExternalOccurrenceAtSiteInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ExternalOccurrenceAtSiteInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    biomaterial: {
      $ref: '#/components/schemas/ExternalBioMatInput'
    },
    event: {
      $ref: '#/components/schemas/EventInput'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInput'
    }
  },
  required: ['event', 'sampling', 'biomaterial'],
  type: 'object'
} as const

export const $Fixative = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Fixative.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    }
  },
  required: ['meta', 'id', 'label', 'code'],
  type: 'object'
} as const

export const $FixativeInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/FixativeInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    label: {
      type: 'string'
    }
  },
  required: ['label', 'code'],
  type: 'object'
} as const

export const $FixativeUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/FixativeUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: ['string', 'null']
    },
    label: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Funder = {
  additionalProperties: false,
  properties: {
    DOI: {
      type: 'string'
    },
    award: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    'doi-asserted-by': {
      type: 'string'
    },
    name: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Gene = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Gene.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    is_MOTU_delimiter: {
      type: 'boolean'
    },
    label: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    }
  },
  required: ['is_MOTU_delimiter', 'meta', 'id', 'label', 'code'],
  type: 'object'
} as const

export const $GeneInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/GeneInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    is_MOTU_delimiter: {
      default: false,
      type: 'boolean'
    },
    label: {
      type: 'string'
    }
  },
  required: ['label', 'code'],
  type: 'object'
} as const

export const $GeneUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/GeneUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: ['string', 'null']
    },
    is_MOTU_delimiter: {
      type: 'boolean'
    },
    label: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $GeoapifyResult = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/GeoapifyResult.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    city: {
      type: 'string'
    },
    country: {
      type: 'string'
    },
    country_code: {
      type: 'string'
    },
    county: {
      type: 'string'
    },
    formatted: {
      type: 'string'
    },
    housenumber: {
      type: 'string'
    },
    lat: {
      format: 'double',
      type: 'number'
    },
    lon: {
      format: 'double',
      type: 'number'
    },
    municipality: {
      type: 'string'
    },
    postcode: {
      type: 'string'
    },
    state: {
      type: 'string'
    },
    street: {
      type: 'string'
    },
    suburb: {
      type: 'string'
    }
  },
  required: [
    'formatted',
    'municipality',
    'city',
    'county',
    'state',
    'country',
    'country_code',
    'lat',
    'lon',
    'postcode',
    'street',
    'housenumber',
    'suburb'
  ],
  type: 'object'
} as const

export const $GeoapifyUsage = {
  additionalProperties: false,
  properties: {
    date: {
      type: 'string'
    },
    id: {
      type: 'string'
    },
    requests: {
      format: 'int32',
      type: 'integer'
    }
  },
  required: ['id', 'date', 'requests'],
  type: 'object'
} as const

export const $Group = {
  additionalProperties: false,
  properties: {
    label: {
      type: 'string'
    },
    name: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Habitat = {
  additionalProperties: false,
  properties: {
    description: {
      description: 'Optional habitat description',
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    incompatible: {
      items: {
        $ref: '#/components/schemas/HabitatInner'
      },
      type: 'array'
    },
    label: {
      description: 'A short label for the habitat.',
      examples: ['Lotic'],
      maxLength: 32,
      minLength: 3,
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    }
  },
  required: ['meta', 'incompatible', 'id', 'label'],
  type: 'object'
} as const

export const $HabitatGroup = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/HabitatGroup.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    depends: {
      $ref: '#/components/schemas/OptionalHabitatRecord'
    },
    elements: {
      items: {
        $ref: '#/components/schemas/HabitatRecord'
      },
      type: 'array'
    },
    exclusive_elements: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      description: 'Name for the group of habitat tags',
      examples: ['Water flow'],
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    }
  },
  required: ['id', 'label', 'exclusive_elements', 'elements', 'meta'],
  type: 'object'
} as const

export const $HabitatGroupInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/HabitatGroupInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    depends: {
      description: 'Habitat tag that this group is a refinement of',
      examples: ['Aquatic, Surface'],
      type: 'string'
    },
    elements: {
      items: {
        $ref: '#/components/schemas/HabitatInput'
      },
      minItems: 1,
      type: 'array'
    },
    exclusive_elements: {
      type: 'boolean'
    },
    label: {
      description: 'Name for the group of habitat tags',
      examples: ['Water flow'],
      maxLength: 32,
      minLength: 3,
      type: 'string'
    }
  },
  required: ['label', 'elements'],
  type: 'object'
} as const

export const $HabitatGroupUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/HabitatGroupUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    create_tags: {
      items: {
        $ref: '#/components/schemas/HabitatInput'
      },
      type: 'array'
    },
    delete_tags: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    depends: {
      type: ['string', 'null']
    },
    exclusive_elements: {
      type: 'boolean'
    },
    label: {
      type: 'string'
    },
    update_tags: {
      additionalProperties: {
        $ref: '#/components/schemas/HabitatUpdate'
      },
      type: 'object'
    }
  },
  type: 'object'
} as const

export const $HabitatInner = {
  additionalProperties: false,
  properties: {
    description: {
      description: 'Optional habitat description',
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      description: 'A short label for the habitat.',
      examples: ['Lotic'],
      maxLength: 32,
      minLength: 3,
      type: 'string'
    }
  },
  required: ['id', 'label'],
  type: 'object'
} as const

export const $HabitatInput = {
  additionalProperties: false,
  properties: {
    description: {
      description: 'Optional habitat description',
      type: 'string'
    },
    label: {
      description: 'A short label for the habitat.',
      examples: ['Lotic'],
      maxLength: 32,
      minLength: 3,
      type: 'string'
    }
  },
  required: ['label'],
  type: 'object'
} as const

export const $HabitatRecord = {
  additionalProperties: false,
  properties: {
    description: {
      description: 'Optional habitat description',
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    incompatible: {
      items: {
        $ref: '#/components/schemas/HabitatInner'
      },
      type: 'array'
    },
    label: {
      description: 'A short label for the habitat.',
      examples: ['Lotic'],
      maxLength: 32,
      minLength: 3,
      type: 'string'
    }
  },
  required: ['incompatible', 'id', 'label'],
  type: 'object'
} as const

export const $HabitatUpdate = {
  additionalProperties: false,
  properties: {
    description: {
      type: ['string', 'null']
    },
    label: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Identification = {
  additionalProperties: false,
  properties: {
    id: {
      format: 'uuid',
      type: 'string'
    },
    identified_by: {
      $ref: '#/components/schemas/OptionalPersonInner'
    },
    identified_on: {
      $ref: '#/components/schemas/DateWithPrecision'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    taxon: {
      $ref: '#/components/schemas/Taxon'
    }
  },
  required: ['id', 'taxon', 'identified_on', 'meta'],
  type: 'object'
} as const

export const $IdentificationInput = {
  additionalProperties: false,
  properties: {
    identified_by: {
      type: 'string'
    },
    identified_on: {
      $ref: '#/components/schemas/DateWithPrecisionInput'
    },
    taxon: {
      type: 'string'
    }
  },
  required: ['taxon', 'identified_by', 'identified_on'],
  type: 'object'
} as const

export const $IdentificationUpdate = {
  additionalProperties: false,
  properties: {
    identified_by: {
      type: ['string', 'null']
    },
    identified_on: {
      $ref: '#/components/schemas/DateWithPrecisionInput'
    },
    taxon: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Identifier = {
  additionalProperties: false,
  properties: {
    'asserted-by': {
      type: 'string'
    },
    id: {
      type: 'string'
    },
    'id-type': {
      type: 'string'
    },
    label: {
      type: 'string'
    },
    name: {
      type: 'string'
    },
    type: {
      type: 'string'
    },
    value: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $ImportProcess = {
  additionalProperties: false,
  properties: {
    GBIF_ID: {
      format: 'int64',
      type: 'integer'
    },
    done: {
      type: 'boolean'
    },
    error: {},
    expected: {
      format: 'int64',
      type: 'integer'
    },
    imported: {
      format: 'int64',
      type: 'integer'
    },
    name: {
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank'
    },
    started: {
      format: 'date-time',
      type: 'string'
    }
  },
  required: ['name', 'GBIF_ID', 'expected', 'imported', 'rank', 'started', 'done', 'error'],
  type: 'object'
} as const

export const $ImportRequestGBIF = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ImportRequestGBIF.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    children: {
      description: 'Import whole clade, including the taxon descendants',
      type: 'boolean'
    },
    key: {
      description: 'Target GBIF taxon key',
      format: 'int64',
      type: 'integer'
    }
  },
  required: ['key', 'children'],
  type: 'object'
} as const

export const $InstanceSettings = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/InstanceSettings.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    allow_contributor_signup: {
      description: 'Whether requests to contribute to the database can be made.',
      type: 'boolean'
    },
    description: {
      type: 'string'
    },
    name: {
      description: 'The name of this database platform',
      type: 'string'
    },
    public: {
      description: 'Whether the platform is accessible to unauthenticated users',
      type: 'boolean'
    }
  },
  required: ['description', 'name', 'public', 'allow_contributor_signup'],
  type: 'object'
} as const

export const $InstanceSettingsInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/InstanceSettingsInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    allow_contributor_signup: {
      description: 'Whether requests to contribute to the database can be made.',
      type: 'boolean'
    },
    description: {
      type: ['string', 'null']
    },
    name: {
      description: 'The name of this database platform',
      type: 'string'
    },
    public: {
      description: 'Whether the platform is accessible to unauthenticated users',
      type: 'boolean'
    }
  },
  required: ['name', 'public', 'allow_contributor_signup'],
  type: 'object'
} as const

export const $InvitationInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/InvitationInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    email: {
      description: 'E-mail address of the recipient of the invitation',
      format: 'email',
      type: 'string'
    },
    handler: {
      $ref: '#/components/schemas/URL',
      description:
        'A URL template with a {token} parameter, which implements the UI to validate the invitation token and fill a registration form.',
      examples: ['http://example.com/register/{token}'],
      format: 'uri-template'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    }
  },
  required: ['email', 'role'],
  type: 'object'
} as const

export const $InvitationLink = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/InvitationLink.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    invitation_link: {
      $ref: '#/components/schemas/URL',
      description:
        'The generated URL containing a registration token that can be shared to the invitee.'
    }
  },
  required: ['invitation_link'],
  type: 'object'
} as const

export const $JournalIssue = {
  additionalProperties: false,
  properties: {
    issue: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $LatLongCoords = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/LatLongCoords.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    latitude: {
      examples: [43.5684],
      format: 'float',
      maximum: 90,
      minimum: -90,
      type: 'number'
    },
    longitude: {
      examples: [3.5678],
      format: 'float',
      maximum: 180,
      minimum: -180,
      type: 'number'
    }
  },
  required: ['latitude', 'longitude'],
  type: 'object'
} as const

export const $LegacySeqID = {
  additionalProperties: false,
  properties: {
    alignment_code: {
      type: 'string'
    },
    code: {
      type: 'string'
    },
    id: {
      format: 'int32',
      type: 'integer'
    }
  },
  required: ['id', 'code', 'alignment_code'],
  type: 'object'
} as const

export const $License = {
  additionalProperties: false,
  properties: {
    URL: {
      type: 'string'
    },
    'content-version': {
      type: 'string'
    },
    'delay-in-days': {
      format: 'int64',
      type: 'integer'
    },
    start: {
      $ref: '#/components/schemas/DateObject'
    }
  },
  type: 'object'
} as const

export const $Lineage = {
  additionalProperties: false,
  properties: {
    class: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    family: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    genus: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    kingdom: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    order: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    phylum: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    species: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    subspecies: {
      $ref: '#/components/schemas/OptionalTaxon'
    }
  },
  type: 'object'
} as const

export const $Link = {
  additionalProperties: false,
  properties: {
    URL: {
      type: 'string'
    },
    'content-type': {
      type: 'string'
    },
    'content-version': {
      type: 'string'
    },
    'intended-application': {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $LogoutInputBody = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/LogoutInputBody.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    refresh_token: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Message = {
  additionalProperties: false,
  properties: {
    URL: {
      type: 'string'
    },
    abstract: {
      type: 'string'
    },
    accepted: {
      $ref: '#/components/schemas/DateObject'
    },
    'alternative-id': {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    approved: {
      $ref: '#/components/schemas/DateObject'
    },
    archive: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    'article-number': {
      type: 'string'
    },
    assertion: {
      items: {
        $ref: '#/components/schemas/Assertion'
      },
      type: 'array'
    },
    author: {
      items: {
        $ref: '#/components/schemas/CrossRefPerson'
      },
      type: 'array'
    },
    chair: {
      items: {
        $ref: '#/components/schemas/CrossRefPerson'
      },
      type: 'array'
    },
    'clinical-trail-number': {
      $ref: '#/components/schemas/ClinicalTrailNumber'
    },
    'component-number': {
      type: 'string'
    },
    'container-title': {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    'content-created': {
      $ref: '#/components/schemas/DateObject'
    },
    'content-domain': {
      $ref: '#/components/schemas/ContentDomain'
    },
    'content-updated': {
      $ref: '#/components/schemas/DateObject'
    },
    created: {
      $ref: '#/components/schemas/DateObject'
    },
    degree: {
      type: 'string'
    },
    deposited: {
      $ref: '#/components/schemas/DateObject'
    },
    doi: {
      type: 'string'
    },
    'edition-number': {
      type: 'string'
    },
    editor: {
      items: {
        $ref: '#/components/schemas/CrossRefPerson'
      },
      type: 'array'
    },
    'free-to-read': {
      $ref: '#/components/schemas/DateRange'
    },
    funder: {
      items: {
        $ref: '#/components/schemas/Funder'
      },
      type: 'array'
    },
    'group-title': {
      type: 'string'
    },
    indexed: {
      $ref: '#/components/schemas/DateObject'
    },
    institution: {
      items: {
        $ref: '#/components/schemas/Organization'
      },
      type: 'array'
    },
    isbn: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    'isbn-type': {
      items: {
        $ref: '#/components/schemas/Identifier'
      },
      type: 'array'
    },
    issn: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    'issn-type': {
      items: {
        $ref: '#/components/schemas/Identifier'
      },
      type: 'array'
    },
    issue: {
      type: 'string'
    },
    issued: {
      $ref: '#/components/schemas/DateObject'
    },
    'journal-issue': {
      $ref: '#/components/schemas/JournalIssue'
    },
    language: {
      type: 'string'
    },
    license: {
      items: {
        $ref: '#/components/schemas/License'
      },
      type: 'array'
    },
    link: {
      items: {
        $ref: '#/components/schemas/Link'
      },
      type: 'array'
    },
    member: {
      type: 'string'
    },
    'original-title': {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    page: {
      type: 'string'
    },
    'part-number': {
      type: 'string'
    },
    posted: {
      $ref: '#/components/schemas/DateObject'
    },
    prefix: {
      type: 'string'
    },
    published: {
      $ref: '#/components/schemas/DateObject'
    },
    'published-online': {
      $ref: '#/components/schemas/DateObject'
    },
    'published-other': {
      $ref: '#/components/schemas/DateObject'
    },
    'published-print': {
      $ref: '#/components/schemas/DateObject'
    },
    publisher: {
      type: 'string'
    },
    'publisher-location': {
      type: 'string'
    },
    reference: {
      items: {
        $ref: '#/components/schemas/Reference'
      },
      type: 'array'
    },
    'reference-count': {
      format: 'int64',
      type: 'integer'
    },
    relation: {
      additionalProperties: {
        items: {
          $ref: '#/components/schemas/Property'
        },
        type: 'array'
      },
      type: 'object'
    },
    review: {
      $ref: '#/components/schemas/Review'
    },
    score: {
      format: 'float',
      type: 'number'
    },
    'short-container-title': {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    'short-title': {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    source: {
      type: 'string'
    },
    'standards-body': {
      items: {
        $ref: '#/components/schemas/Organization'
      },
      type: 'array'
    },
    subject: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    subtitle: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    title: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    translator: {
      items: {
        $ref: '#/components/schemas/CrossRefPerson'
      },
      type: 'array'
    },
    type: {
      type: 'string'
    },
    'update-policy': {
      type: 'string'
    },
    'updated-to': {
      items: {
        $ref: '#/components/schemas/Updated'
      },
      type: 'array'
    },
    volume: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Meta = {
  additionalProperties: false,
  properties: {
    created: {
      format: 'date-time',
      type: 'string'
    },
    created_by: {
      $ref: '#/components/schemas/OptionalUserShortIdentity'
    },
    last_updated: {
      format: 'date-time',
      type: 'string'
    },
    modified: {
      format: 'date-time',
      type: 'string'
    },
    updated_by: {
      $ref: '#/components/schemas/OptionalUserShortIdentity'
    }
  },
  required: ['created', 'last_updated'],
  type: 'object'
} as const

export const $OccurrenceAtSite = {
  additionalProperties: false,
  properties: {
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    element: {
      $ref: '#/components/schemas/OccurrenceElement'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    taxon: {
      $ref: '#/components/schemas/TaxonInner'
    }
  },
  required: ['id', 'code', 'taxon', 'category', 'element'],
  type: 'object'
} as const

export const $OccurrenceCategory = {
  enum: ['Internal', 'External'],
  title: 'OccurrenceCategory',
  type: 'string'
} as const

export const $OccurrenceDataset = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/OccurrenceDataset.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/DatasetCategory'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    is_congruent: {
      type: 'boolean'
    },
    label: {
      type: 'string'
    },
    maintainers: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    occurrences: {
      items: {
        $ref: '#/components/schemas/OccurrenceWithCategory'
      },
      type: 'array'
    },
    pinned: {
      type: 'boolean'
    },
    sites: {
      items: {
        $ref: '#/components/schemas/SiteItem'
      },
      type: 'array'
    },
    slug: {
      type: 'string'
    }
  },
  required: [
    'sites',
    'occurrences',
    'is_congruent',
    'maintainers',
    'meta',
    'id',
    'label',
    'slug',
    'pinned',
    'description',
    'category'
  ],
  type: 'object'
} as const

export const $OccurrenceDatasetListItem = {
  additionalProperties: false,
  properties: {
    category: {
      $ref: '#/components/schemas/DatasetCategory'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    is_congruent: {
      type: 'boolean'
    },
    label: {
      type: 'string'
    },
    maintainers: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    occurrences: {
      format: 'int64',
      type: 'integer'
    },
    pinned: {
      type: 'boolean'
    },
    sites: {
      format: 'int64',
      type: 'integer'
    },
    slug: {
      type: 'string'
    }
  },
  required: [
    'sites',
    'occurrences',
    'is_congruent',
    'maintainers',
    'meta',
    'id',
    'label',
    'slug',
    'pinned',
    'description',
    'category'
  ],
  type: 'object'
} as const

export const $OccurrenceElement = {
  enum: ['BioMaterial', 'Sequence'],
  title: 'OccurrenceElement',
  type: 'string'
} as const

export const $OccurrenceOverviewItem = {
  additionalProperties: false,
  properties: {
    name: {
      type: 'string'
    },
    occurrences: {
      format: 'int32',
      type: 'integer'
    },
    parent_name: {
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank'
    }
  },
  required: ['name', 'parent_name', 'occurrences', 'rank'],
  type: 'object'
} as const

export const $OccurrenceReference = {
  additionalProperties: false,
  properties: {
    authors: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    doi: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    journal: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    original: {
      type: 'boolean'
    },
    original_source: {
      type: 'boolean'
    },
    title: {
      type: 'string'
    },
    verbatim: {
      type: 'string'
    },
    year: {
      format: 'int32',
      type: 'integer'
    }
  },
  required: ['id', 'code', 'authors', 'year', 'original_source', 'meta'],
  type: 'object'
} as const

export const $OccurrenceReferenceInput = {
  additionalProperties: false,
  properties: {
    code: {
      type: 'string'
    },
    original: {
      type: 'boolean'
    }
  },
  required: ['code'],
  type: 'object'
} as const

export const $OccurrenceWithCategory = {
  additionalProperties: false,
  properties: {
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    comments: {
      type: 'string'
    },
    element: {
      $ref: '#/components/schemas/OccurrenceElement'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInner'
    }
  },
  required: ['category', 'element', 'id', 'comments', 'sampling', 'identification'],
  type: 'object'
} as const

export const $OptionalBioMaterial = {
  additionalProperties: false,
  properties: {
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    code_history: {
      items: {
        $ref: '#/components/schemas/CodeHistory'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    external: {
      $ref: '#/components/schemas/OptionalExternalBioMatSpecific'
    },
    has_sequences: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    is_congruent: {
      type: 'boolean'
    },
    is_homogenous: {
      type: 'boolean'
    },
    is_type: {
      type: 'boolean'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInner'
    },
    seq_consensus: {
      $ref: '#/components/schemas/OptionalTaxon'
    }
  },
  required: [
    'has_sequences',
    'is_homogenous',
    'is_congruent',
    'meta',
    'sampling',
    'identification',
    'id',
    'category',
    'is_type',
    'code'
  ],
  type: ['object', 'null']
} as const

export const $OptionalCountry = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Country.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['DE'],
      type: 'string'
    },
    continent: {
      examples: ['Europe'],
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    name: {
      examples: ['Germany'],
      type: 'string'
    },
    subcontinent: {
      examples: ['Western Europe'],
      type: 'string'
    }
  },
  required: ['id', 'name', 'code', 'continent', 'subcontinent'],
  type: ['object', 'null']
} as const

export const $OptionalDataSource = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/DataSource.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    link_template: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    url: {
      type: 'string'
    }
  },
  required: ['meta', 'id', 'label', 'code'],
  type: ['object', 'null']
} as const

export const $OptionalDateWithPrecision = {
  additionalProperties: false,
  properties: {
    date: {
      format: 'date-time',
      type: 'string'
    },
    precision: {
      $ref: '#/components/schemas/DatePrecision'
    }
  },
  required: ['precision'],
  type: ['object', 'null']
} as const

export const $OptionalExtSeqSpecificsBioMaterial = {
  additionalProperties: false,
  properties: {
    origin: {
      $ref: '#/components/schemas/ExtSeqOrigin'
    },
    original_taxon: {
      type: 'string'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    referenced_in: {
      items: {
        $ref: '#/components/schemas/SeqReference'
      },
      type: 'array'
    },
    source_sample: {
      $ref: '#/components/schemas/OptionalBioMaterial'
    },
    specimen_identifier: {
      type: 'string'
    }
  },
  required: ['origin', 'specimen_identifier'],
  type: ['object', 'null']
} as const

export const $OptionalExternalBioMatSpecific = {
  additionalProperties: false,
  properties: {
    archive: {
      $ref: '#/components/schemas/SpecimenVoucher'
    },
    comments: {
      type: 'string'
    },
    content: {
      items: {
        $ref: '#/components/schemas/ExternalBioMatContent'
      },
      type: 'array'
    },
    content_description: {
      type: 'string'
    },
    original_link: {
      type: 'string'
    },
    original_source: {
      $ref: '#/components/schemas/OptionalDataSource'
    },
    original_taxon: {
      type: 'string'
    },
    quantity: {
      $ref: '#/components/schemas/Quantity'
    }
  },
  required: ['quantity', 'archive', 'comments'],
  type: ['object', 'null']
} as const

export const $OptionalHabitatRecord = {
  additionalProperties: false,
  properties: {
    description: {
      description: 'Optional habitat description',
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    incompatible: {
      items: {
        $ref: '#/components/schemas/HabitatInner'
      },
      type: 'array'
    },
    label: {
      description: 'A short label for the habitat.',
      examples: ['Lotic'],
      maxLength: 32,
      minLength: 3,
      type: 'string'
    }
  },
  required: ['incompatible', 'id', 'label'],
  type: ['object', 'null']
} as const

export const $OptionalLegacySeqID = {
  additionalProperties: false,
  properties: {
    alignment_code: {
      type: 'string'
    },
    code: {
      type: 'string'
    },
    id: {
      format: 'int32',
      type: 'integer'
    }
  },
  required: ['id', 'code', 'alignment_code'],
  type: ['object', 'null']
} as const

export const $OptionalPersonInner = {
  additionalProperties: false,
  properties: {
    alias: {
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    contact: {
      format: 'email',
      type: 'string'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    full_name: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    }
  },
  required: ['id', 'full_name', 'alias', 'contact', 'comment', 'first_name', 'last_name'],
  type: ['object', 'null']
} as const

export const $OptionalTaxon = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Taxon.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    GBIF_ID: {
      examples: [2206247],
      format: 'int64',
      type: 'integer'
    },
    anchor: {
      type: 'boolean'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    children_count: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      examples: ['ASEaquaticus'],
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['id', 'code', 'anchor', 'children_count', 'meta', 'name', 'status', 'rank'],
  type: ['object', 'null']
} as const

export const $OptionalUserInner = {
  additionalProperties: false,
  properties: {
    email: {
      format: 'email',
      type: 'string'
    },
    email_confirmed: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    login: {
      type: 'string'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    }
  },
  required: ['id', 'email', 'login', 'role', 'email_confirmed'],
  type: ['object', 'null']
} as const

export const $OptionalUserShortIdentity = {
  additionalProperties: false,
  properties: {
    alias: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    login: {
      type: 'string'
    },
    name: {
      type: 'string'
    }
  },
  required: ['id', 'login', 'name', 'alias'],
  type: ['object', 'null']
} as const

export const $OrgKind = {
  enum: ['Lab', 'FundingAgency', 'SequencingPlatform', 'Other'],
  title: 'OrgKind',
  type: 'string'
} as const

export const $Organisation = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Organisation.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['LEHNA'],
      maxLength: 12,
      minLength: 2,
      type: 'string'
    },
    description: {
      examples: ['Where this database was born.'],
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    kind: {
      $ref: '#/components/schemas/OrgKind',
      examples: ['Lab']
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ["Laboratoire d'Écologie des Hydrosystèmes Naturels et Anthropisés"],
      maxLength: 128,
      minLength: 10,
      type: 'string'
    },
    people: {
      description: 'Known members of this organisation',
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    }
  },
  required: ['meta', 'id', 'name', 'code', 'kind'],
  type: 'object'
} as const

export const $OrganisationInner = {
  additionalProperties: false,
  properties: {
    code: {
      examples: ['LEHNA'],
      maxLength: 12,
      minLength: 2,
      type: 'string'
    },
    description: {
      examples: ['Where this database was born.'],
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    kind: {
      $ref: '#/components/schemas/OrgKind',
      examples: ['Lab']
    },
    name: {
      examples: ["Laboratoire d'Écologie des Hydrosystèmes Naturels et Anthropisés"],
      maxLength: 128,
      minLength: 10,
      type: 'string'
    }
  },
  required: ['id', 'name', 'code', 'kind'],
  type: 'object'
} as const

export const $OrganisationInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/OrganisationInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['LEHNA'],
      maxLength: 12,
      minLength: 2,
      type: 'string'
    },
    description: {
      examples: ['Where this database was born.'],
      type: 'string'
    },
    kind: {
      $ref: '#/components/schemas/OrgKind',
      examples: ['Lab']
    },
    name: {
      examples: ["Laboratoire d'Écologie des Hydrosystèmes Naturels et Anthropisés"],
      maxLength: 128,
      minLength: 10,
      type: 'string'
    }
  },
  required: ['name', 'code', 'kind'],
  type: 'object'
} as const

export const $OrganisationUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/OrganisationUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['LEHNA'],
      type: 'string'
    },
    description: {
      examples: ['Where this database was born.'],
      type: ['string', 'null']
    },
    kind: {
      $ref: '#/components/schemas/OrgKind',
      examples: ['Lab']
    },
    name: {
      examples: ["Laboratoire d'Écologie des Hydrosystèmes Naturels et Anthropisés"],
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Organization = {
  additionalProperties: false,
  properties: {
    acronym: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    department: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    id: {
      items: {
        $ref: '#/components/schemas/Identifier'
      },
      type: 'array'
    },
    name: {
      type: 'string'
    },
    place: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  type: 'object'
} as const

export const $PaginatedListBioMaterialWithDetails = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/PaginatedListBioMaterialWithDetails.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    items: {
      items: {
        $ref: '#/components/schemas/BioMaterialWithDetails'
      },
      type: 'array'
    },
    total_count: {
      format: 'int64',
      type: 'integer'
    }
  },
  required: ['items', 'total_count'],
  type: 'object'
} as const

export const $PasswordInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/PasswordInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    password: {
      description: 'Your new password',
      type: 'string'
    },
    password_confirmation: {
      description: 'New password confirmation',
      type: 'string'
    }
  },
  required: ['password', 'password_confirmation'],
  type: 'object'
} as const

export const $PasswordResetRequest = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/PasswordResetRequest.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    email: {
      format: 'email',
      type: 'string'
    },
    handler: {
      description:
        'A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.',
      format: 'uri',
      type: 'string'
    }
  },
  required: ['email'],
  type: 'object'
} as const

export const $PendingUserRequest = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/PendingUserRequest.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    created_on: {
      format: 'date-time',
      type: 'string'
    },
    email: {
      format: 'email',
      type: 'string'
    },
    email_verified: {
      type: 'boolean'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    full_name: {
      type: 'string'
    },
    id: {
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    motive: {
      type: 'string'
    },
    organisation: {
      type: 'string'
    }
  },
  required: ['id', 'full_name', 'created_on', 'email_verified', 'email', 'first_name', 'last_name'],
  type: 'object'
} as const

export const $PendingUserRequestInput = {
  additionalProperties: false,
  properties: {
    email: {
      format: 'email',
      type: 'string'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    motive: {
      type: 'string'
    },
    organisation: {
      type: 'string'
    }
  },
  required: ['email', 'first_name', 'last_name'],
  type: 'object'
} as const

export const $Person = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Person.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    alias: {
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    contact: {
      format: 'email',
      type: 'string'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    full_name: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    organisations: {
      items: {
        $ref: '#/components/schemas/OrganisationInner'
      },
      type: 'array'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    },
    user: {
      $ref: '#/components/schemas/OptionalUserInner'
    }
  },
  required: [
    'organisations',
    'meta',
    'user',
    'id',
    'full_name',
    'alias',
    'contact',
    'comment',
    'first_name',
    'last_name'
  ],
  type: 'object'
} as const

export const $PersonInner = {
  additionalProperties: false,
  properties: {
    alias: {
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    contact: {
      format: 'email',
      type: 'string'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    full_name: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    }
  },
  required: ['id', 'full_name', 'alias', 'contact', 'comment', 'first_name', 'last_name'],
  type: 'object'
} as const

export const $PersonInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/PersonInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    alias: {
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    contact: {
      format: 'email',
      type: 'string'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    organisations: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  required: ['first_name', 'last_name'],
  type: 'object'
} as const

export const $PersonUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/PersonUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    alias: {
      type: 'string'
    },
    comment: {
      type: ['string', 'null']
    },
    contact: {
      type: ['string', 'null']
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    organisations: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  type: 'object'
} as const

export const $PersonUser = {
  additionalProperties: false,
  properties: {
    alias: {
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    contact: {
      format: 'email',
      type: 'string'
    },
    first_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    full_name: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    last_name: {
      maxLength: 32,
      minLength: 2,
      type: 'string'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    },
    user: {
      $ref: '#/components/schemas/OptionalUserInner'
    }
  },
  required: ['user', 'id', 'full_name', 'alias', 'contact', 'comment', 'first_name', 'last_name'],
  type: 'object'
} as const

export const $Program = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Program.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    datasets: {
      items: {
        $ref: '#/components/schemas/DatasetInner'
      },
      type: 'array'
    },
    description: {
      type: 'string'
    },
    end_year: {
      examples: [2025],
      format: 'int64',
      type: 'integer'
    },
    funding_agencies: {
      items: {
        $ref: '#/components/schemas/OrganisationInner'
      },
      type: 'array'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    managers: {
      items: {
        $ref: '#/components/schemas/PersonInner'
      },
      minItems: 1,
      type: 'array'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    start_year: {
      examples: [2019],
      format: 'int64',
      minimum: 1900,
      type: 'integer'
    }
  },
  required: ['managers', 'funding_agencies', 'datasets', 'meta', 'id', 'label', 'code'],
  type: 'object'
} as const

export const $ProgramInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ProgramInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['PHD_ALICE'],
      type: 'string'
    },
    datasets: {
      examples: [['dataset1']],
      items: {
        type: 'string'
      },
      type: 'array'
    },
    description: {
      type: 'string'
    },
    end_year: {
      examples: [2025],
      format: 'int32',
      type: 'integer'
    },
    funding_agencies: {
      examples: [['CNRS']],
      items: {
        type: 'string'
      },
      type: 'array'
    },
    label: {
      examples: ["Alice's PhD"],
      type: 'string'
    },
    managers: {
      examples: [['adoe', 'fmalard']],
      items: {
        type: 'string'
      },
      minItems: 1,
      type: 'array'
    },
    start_year: {
      examples: [2022],
      format: 'int32',
      minimum: 1900,
      type: 'integer'
    }
  },
  required: ['label', 'code', 'managers'],
  type: 'object'
} as const

export const $ProgramUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ProgramUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      examples: ['PHD_ALICE'],
      type: 'string'
    },
    datasets: {
      examples: [['dataset1']],
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    description: {
      type: ['string', 'null']
    },
    end_year: {
      examples: [2025],
      format: 'int32',
      type: ['integer', 'null']
    },
    funding_agencies: {
      examples: [['CNRS']],
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    label: {
      examples: ["Alice's PhD"],
      type: 'string'
    },
    managers: {
      examples: [['adoe', 'fmalard']],
      items: {
        type: 'string'
      },
      minItems: 1,
      type: ['array', 'null']
    },
    start_year: {
      examples: [2022],
      format: 'int32',
      minimum: 1900,
      type: ['integer', 'null']
    }
  },
  type: 'object'
} as const

export const $Property = {
  additionalProperties: false,
  properties: {
    'asserted-by': {
      type: 'string'
    },
    id: {
      type: 'string'
    },
    'id-type': {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Quantity = {
  enum: ['Unknown', 'One', 'Several', 'Dozen', 'Tens', 'Hundred'],
  title: 'Quantity',
  type: 'string'
} as const

export const $Reference = {
  additionalProperties: false,
  properties: {
    'article-title': {
      type: 'string'
    },
    author: {
      type: 'string'
    },
    component: {
      type: 'string'
    },
    doi: {
      type: 'string'
    },
    'doi-asserted-by': {
      type: 'string'
    },
    edition: {
      type: 'string'
    },
    'first-page': {
      type: 'string'
    },
    isbn: {
      type: 'string'
    },
    'isbn-type': {
      type: 'string'
    },
    issn: {
      type: 'string'
    },
    'issn-type': {
      type: 'string'
    },
    issue: {
      type: 'string'
    },
    'journal-title': {
      type: 'string'
    },
    key: {
      type: 'string'
    },
    'series-title': {
      type: 'string'
    },
    'standard-designator': {
      type: 'string'
    },
    'standards-body': {
      type: 'string'
    },
    unstructured: {
      type: 'string'
    },
    volume: {
      type: 'string'
    },
    'volume-title': {
      type: 'string'
    },
    year: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $RefreshTokenBody = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/RefreshTokenBody.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    refresh_token: {
      type: 'string'
    }
  },
  required: ['refresh_token'],
  type: 'object'
} as const

export const $RegisterInputBody = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/RegisterInputBody.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    data: {
      $ref: '#/components/schemas/PendingUserRequestInput'
    },
    verification_path: {
      type: 'string'
    }
  },
  required: ['data', 'verification_path'],
  type: 'object'
} as const

export const $ResendEmailVerificationInputBody = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ResendEmailVerificationInputBody.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    email: {
      format: 'email',
      type: 'string'
    },
    verification_url: {
      description:
        'A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.',
      format: 'uri',
      type: 'string'
    }
  },
  required: ['email', 'verification_url'],
  type: 'object'
} as const

export const $ReverseGeocodeInputBody = {
  additionalProperties: true,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ReverseGeocodeInputBody.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    latitude: {
      examples: [43.5684],
      format: 'float',
      maximum: 90,
      minimum: -90,
      type: 'number'
    },
    longitude: {
      examples: [3.5678],
      format: 'float',
      maximum: 180,
      minimum: -180,
      type: 'number'
    }
  },
  required: ['latitude', 'longitude'],
  type: 'object'
} as const

export const $Review = {
  additionalProperties: false,
  properties: {
    'competing-interest-statement': {
      type: 'string'
    },
    language: {
      type: 'string'
    },
    recommendation: {
      type: 'string'
    },
    'revision-round': {
      type: 'string'
    },
    'running-number': {
      type: 'string'
    },
    stage: {
      type: 'string'
    },
    type: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $Sampling = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Sampling.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    access_points: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    duration: {
      description: 'Sampling duration in minutes',
      format: 'int64',
      type: 'integer'
    },
    fixatives: {
      items: {
        $ref: '#/components/schemas/Fixative'
      },
      type: 'array'
    },
    habitats: {
      items: {
        $ref: '#/components/schemas/Habitat'
      },
      type: 'array'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    methods: {
      items: {
        $ref: '#/components/schemas/SamplingMethod'
      },
      type: 'array'
    },
    occurring_taxa: {
      items: {
        $ref: '#/components/schemas/Taxon'
      },
      type: 'array'
    },
    samples: {
      items: {
        $ref: '#/components/schemas/BioMaterial'
      },
      type: 'array'
    },
    target: {
      $ref: '#/components/schemas/SamplingTarget'
    }
  },
  required: ['meta', 'id', 'code', 'target'],
  type: 'object'
} as const

export const $SamplingEventWithOccurrences = {
  additionalProperties: false,
  properties: {
    date: {
      $ref: '#/components/schemas/DateWithPrecision'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    occurrences: {
      items: {
        $ref: '#/components/schemas/OccurrenceAtSite'
      },
      type: 'array'
    },
    occurring_taxa: {
      items: {
        $ref: '#/components/schemas/Taxon'
      },
      type: 'array'
    },
    target: {
      $ref: '#/components/schemas/SamplingTarget'
    }
  },
  required: ['id', 'date', 'target', 'occurrences'],
  type: 'object'
} as const

export const $SamplingInner = {
  additionalProperties: false,
  properties: {
    access_points: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    code: {
      type: 'string'
    },
    comments: {
      type: 'string'
    },
    duration: {
      description: 'Sampling duration in minutes',
      format: 'int64',
      type: 'integer'
    },
    fixatives: {
      items: {
        $ref: '#/components/schemas/Fixative'
      },
      type: 'array'
    },
    habitats: {
      items: {
        $ref: '#/components/schemas/Habitat'
      },
      type: 'array'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    methods: {
      items: {
        $ref: '#/components/schemas/SamplingMethod'
      },
      type: 'array'
    },
    target: {
      $ref: '#/components/schemas/SamplingTarget'
    }
  },
  required: ['id', 'code', 'target'],
  type: 'object'
} as const

export const $SamplingInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SamplingInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    access_points: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    duration: {
      description: 'Sampling duration in minutes',
      format: 'int32',
      type: 'integer'
    },
    fixatives: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    habitats: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    methods: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    target: {
      $ref: '#/components/schemas/SamplingTargetInput'
    }
  },
  required: ['target'],
  type: 'object'
} as const

export const $SamplingInputWithEvent = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SamplingInputWithEvent.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    access_points: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    duration: {
      description: 'Sampling duration in minutes',
      format: 'int32',
      type: 'integer'
    },
    event_id: {
      type: 'string'
    },
    fixatives: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    habitats: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    methods: {
      items: {
        type: 'string'
      },
      type: 'array'
    },
    target: {
      $ref: '#/components/schemas/SamplingTargetInput'
    }
  },
  required: ['event_id', 'target'],
  type: 'object'
} as const

export const $SamplingMethod = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SamplingMethod.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    }
  },
  required: ['meta', 'id', 'label', 'code'],
  type: 'object'
} as const

export const $SamplingMethodInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SamplingMethodInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: 'string'
    },
    label: {
      type: 'string'
    }
  },
  required: ['label', 'code'],
  type: 'object'
} as const

export const $SamplingMethodUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SamplingMethodUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    code: {
      type: 'string'
    },
    description: {
      type: ['string', 'null']
    },
    label: {
      type: 'string'
    }
  },
  type: 'object'
} as const

export const $SamplingTarget = {
  additionalProperties: false,
  properties: {
    kind: {
      $ref: '#/components/schemas/SamplingTargetKind'
    },
    taxa: {
      items: {
        $ref: '#/components/schemas/Taxon'
      },
      type: 'array'
    }
  },
  required: ['kind'],
  type: 'object'
} as const

export const $SamplingTargetInput = {
  additionalProperties: false,
  properties: {
    kind: {
      $ref: '#/components/schemas/SamplingTargetKind'
    },
    taxa: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  required: ['kind'],
  type: 'object'
} as const

export const $SamplingTargetKind = {
  enum: ['Community', 'Unknown', 'Taxa'],
  title: 'SamplingTargetKind',
  type: 'string'
} as const

export const $SamplingUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SamplingUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    access_points: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    comments: {
      type: ['string', 'null']
    },
    duration: {
      description: 'Sampling duration in minutes',
      format: 'int32',
      type: ['integer', 'null']
    },
    fixatives: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    habitats: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    methods: {
      items: {
        type: 'string'
      },
      type: ['array', 'null']
    },
    target: {
      $ref: '#/components/schemas/SamplingTargetInput'
    }
  },
  required: ['target'],
  type: 'object'
} as const

export const $SecuritySettings = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SecuritySettings.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    invitation_token_lifetime: {
      description: 'Invitation token lifetime in days',
      format: 'int32',
      minimum: 1,
      type: 'integer'
    },
    min_password_strength: {
      description: 'The level of complexity required for account passwords.',
      format: 'int32',
      maximum: 5,
      minimum: 3,
      type: 'integer'
    },
    refresh_token_lifetime: {
      description: 'User session lifetime in hours',
      format: 'int32',
      minimum: 1,
      type: 'integer'
    }
  },
  required: ['min_password_strength', 'refresh_token_lifetime', 'invitation_token_lifetime'],
  type: 'object'
} as const

export const $SecuritySettingsInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SecuritySettingsInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    invitation_token_lifetime: {
      description: 'Invitation token lifetime in days',
      format: 'int32',
      minimum: 1,
      type: 'integer'
    },
    min_password_strength: {
      description: 'The level of complexity required for account passwords.',
      format: 'int32',
      maximum: 5,
      minimum: 3,
      type: 'integer'
    },
    refresh_token_lifetime: {
      description: 'User session lifetime in hours',
      format: 'int32',
      minimum: 1,
      type: 'integer'
    }
  },
  required: ['min_password_strength', 'refresh_token_lifetime', 'invitation_token_lifetime'],
  type: 'object'
} as const

export const $SeqReference = {
  additionalProperties: false,
  properties: {
    accession: {
      type: 'string'
    },
    db: {
      $ref: '#/components/schemas/DataSource'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    is_origin: {
      type: 'boolean'
    }
  },
  required: ['id', 'db', 'accession', 'is_origin'],
  type: 'object'
} as const

export const $Sequence = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Sequence.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    code_history: {
      items: {
        $ref: '#/components/schemas/CodeHistory'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    event: {
      $ref: '#/components/schemas/EventInner'
    },
    external: {
      $ref: '#/components/schemas/OptionalExtSeqSpecificsBioMaterial'
    },
    gene: {
      $ref: '#/components/schemas/Gene'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    label: {
      type: 'string'
    },
    legacy: {
      $ref: '#/components/schemas/OptionalLegacySeqID'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    sampling: {
      $ref: '#/components/schemas/SamplingInner'
    },
    sequence: {
      type: 'string'
    }
  },
  required: ['id', 'event', 'meta', 'sampling', 'identification', 'gene', 'category', 'code'],
  type: 'object'
} as const

export const $SequenceDataset = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SequenceDataset.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/DatasetCategory'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    maintainers: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    pinned: {
      type: 'boolean'
    },
    sequences: {
      items: {
        $ref: '#/components/schemas/Sequence'
      },
      type: 'array'
    },
    sites: {
      items: {
        $ref: '#/components/schemas/SiteItem'
      },
      type: 'array'
    },
    slug: {
      type: 'string'
    }
  },
  required: [
    'sites',
    'sequences',
    'maintainers',
    'meta',
    'id',
    'label',
    'slug',
    'pinned',
    'description',
    'category'
  ],
  type: 'object'
} as const

export const $SequenceWithDetails = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SequenceWithDetails.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/OccurrenceCategory'
    },
    code: {
      type: 'string'
    },
    code_history: {
      items: {
        $ref: '#/components/schemas/CodeHistory'
      },
      type: 'array'
    },
    comments: {
      type: 'string'
    },
    event: {
      $ref: '#/components/schemas/EventInner'
    },
    external: {
      $ref: '#/components/schemas/OptionalExtSeqSpecificsBioMaterial'
    },
    gene: {
      $ref: '#/components/schemas/Gene'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identification: {
      $ref: '#/components/schemas/Identification'
    },
    label: {
      type: 'string'
    },
    legacy: {
      $ref: '#/components/schemas/OptionalLegacySeqID'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    published_in: {
      items: {
        $ref: '#/components/schemas/OccurrenceReference'
      },
      type: 'array'
    },
    sampling: {
      $ref: '#/components/schemas/Sampling'
    },
    sequence: {
      type: 'string'
    }
  },
  required: ['id', 'event', 'meta', 'sampling', 'identification', 'gene', 'category', 'code'],
  type: 'object'
} as const

export const $ServiceSettings = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ServiceSettings.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    geoapify_api_key: {
      type: 'string'
    }
  },
  required: ['geoapify_api_key'],
  type: 'object'
} as const

export const $ServiceSettingsUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/ServiceSettingsUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    geoapify_api_key: {
      type: ['string', 'null']
    }
  },
  required: ['geoapify_api_key'],
  type: 'object'
} as const

export const $Site = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Site.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    altitude: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      maxLength: 8,
      minLength: 4,
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates'
    },
    country: {
      $ref: '#/components/schemas/OptionalCountry'
    },
    datasets: {
      items: {
        $ref: '#/components/schemas/DatasetInner'
      },
      type: 'array'
    },
    description: {
      type: 'string'
    },
    events: {
      items: {
        $ref: '#/components/schemas/Event'
      },
      type: 'array'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    locality: {
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      minLength: 4,
      type: 'string'
    },
    user_defined_locality: {
      type: 'boolean'
    }
  },
  required: ['meta', 'id', 'code', 'coordinates', 'user_defined_locality'],
  type: 'object'
} as const

export const $SiteDataset = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SiteDataset.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    category: {
      $ref: '#/components/schemas/DatasetCategory'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    label: {
      type: 'string'
    },
    maintainers: {
      items: {
        $ref: '#/components/schemas/PersonUser'
      },
      type: 'array'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    pinned: {
      type: 'boolean'
    },
    sites: {
      items: {
        $ref: '#/components/schemas/SiteItem'
      },
      type: 'array'
    },
    slug: {
      type: 'string'
    }
  },
  required: [
    'sites',
    'maintainers',
    'meta',
    'id',
    'label',
    'slug',
    'pinned',
    'description',
    'category'
  ],
  type: 'object'
} as const

export const $SiteDatasetInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SiteDatasetInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    description: {
      type: 'string'
    },
    label: {
      maxLength: 32,
      minLength: 4,
      type: 'string'
    },
    maintainers: {
      description:
        'Dataset maintainers identified by their person alias. Dataset creator is always a maintainer by default.',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    new_sites: {
      description: 'New sites to include in the dataset',
      items: {
        $ref: '#/components/schemas/SiteInput'
      },
      type: 'array'
    },
    pinned: {
      type: 'boolean'
    },
    sites: {
      description: 'Existing site codes to include in the dataset',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    slug: {
      type: 'string'
    }
  },
  required: ['label', 'slug', 'maintainers'],
  type: 'object'
} as const

export const $SiteInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SiteInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    altitude: {
      description: 'Site altitude in meters',
      format: 'int32',
      type: 'integer'
    },
    code: {
      description: 'A short unique uppercase alphanumeric identifier',
      examples: ['SITE89'],
      maxLength: 10,
      minLength: 4,
      pattern: '[A-Z0-9]+',
      patternDescription: 'alphanum',
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates',
      description: 'Site coordinates in decimal degrees'
    },
    country_code: {
      description: 'ISO 3166-1 alpha-3 country code',
      examples: ['FRA'],
      format: 'country-code',
      pattern: '[A-Z]{3}',
      type: 'string'
    },
    description: {
      type: 'string'
    },
    locality: {
      description: 'Nearest populated place',
      type: 'string'
    },
    name: {
      description: 'A short descriptive name',
      minLength: 4,
      type: 'string'
    },
    user_defined_locality: {
      description:
        'Signals if locality was manually entered by user, and automatically inferred from coordinates',
      type: 'boolean'
    }
  },
  required: ['code', 'coordinates'],
  type: 'object'
} as const

export const $SiteItem = {
  additionalProperties: false,
  properties: {
    altitude: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      maxLength: 8,
      minLength: 4,
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates'
    },
    country: {
      $ref: '#/components/schemas/OptionalCountry'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    locality: {
      type: 'string'
    },
    name: {
      minLength: 4,
      type: 'string'
    },
    user_defined_locality: {
      type: 'boolean'
    }
  },
  required: ['id', 'code', 'coordinates', 'user_defined_locality'],
  type: 'object'
} as const

export const $SiteSamplingStatus = {
  enum: ['All', 'Sampled', 'Occurrences'],
  title: 'SiteSamplingStatus',
  type: 'string'
} as const

export const $SiteUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SiteUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    altitude: {
      description: 'Site altitude in meters',
      format: 'int32',
      type: ['integer', 'null']
    },
    code: {
      description: 'A short unique uppercase alphanumeric identifier',
      examples: ['SITE89'],
      maxLength: 10,
      minLength: 4,
      pattern: '[A-Z0-9]+',
      patternDescription: 'alphanum',
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates',
      description: 'Site coordinates in decimal degrees'
    },
    country_code: {
      examples: ['FR'],
      format: 'country-code',
      pattern: '[A-Z]{2}',
      type: ['string', 'null']
    },
    description: {
      type: ['string', 'null']
    },
    locality: {
      description: 'Nearest populated place',
      type: ['string', 'null']
    },
    name: {
      minLength: 4,
      type: ['string', 'null']
    },
    user_defined_locality: {
      description:
        'Signals whether locality was manually entered by user, and automatically inferred from coordinates',
      type: 'boolean'
    }
  },
  type: 'object'
} as const

export const $SiteWithDistance = {
  additionalProperties: false,
  properties: {
    altitude: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      maxLength: 8,
      minLength: 4,
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates'
    },
    country: {
      $ref: '#/components/schemas/OptionalCountry'
    },
    description: {
      type: 'string'
    },
    distance: {
      format: 'double',
      type: 'number'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    locality: {
      type: 'string'
    },
    name: {
      minLength: 4,
      type: 'string'
    },
    user_defined_locality: {
      type: 'boolean'
    }
  },
  required: ['distance', 'id', 'code', 'coordinates', 'user_defined_locality'],
  type: 'object'
} as const

export const $SiteWithOccurrences = {
  additionalProperties: false,
  properties: {
    altitude: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      maxLength: 8,
      minLength: 4,
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates'
    },
    country: {
      $ref: '#/components/schemas/OptionalCountry'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    last_visited: {
      $ref: '#/components/schemas/OptionalDateWithPrecision'
    },
    locality: {
      type: 'string'
    },
    name: {
      minLength: 4,
      type: 'string'
    },
    samplings: {
      items: {
        $ref: '#/components/schemas/SamplingEventWithOccurrences'
      },
      type: 'array'
    },
    user_defined_locality: {
      type: 'boolean'
    }
  },
  required: ['samplings', 'id', 'code', 'coordinates', 'user_defined_locality'],
  type: 'object'
} as const

export const $SiteWithScore = {
  additionalProperties: false,
  properties: {
    altitude: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      maxLength: 8,
      minLength: 4,
      type: 'string'
    },
    coordinates: {
      $ref: '#/components/schemas/Coordinates'
    },
    country: {
      $ref: '#/components/schemas/OptionalCountry'
    },
    description: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    locality: {
      type: 'string'
    },
    name: {
      minLength: 4,
      type: 'string'
    },
    score: {
      format: 'float',
      type: 'number'
    },
    user_defined_locality: {
      type: 'boolean'
    }
  },
  required: ['score', 'id', 'code', 'coordinates', 'user_defined_locality'],
  type: 'object'
} as const

export const $SitesProximityQuery = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/SitesProximityQuery.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    exclude: {
      description: 'List of site codes to exclude from the result',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    latitude: {
      examples: [43.5684],
      format: 'float',
      maximum: 90,
      minimum: -90,
      type: 'number'
    },
    limit: {
      format: 'int64',
      type: 'integer'
    },
    longitude: {
      examples: [3.5678],
      format: 'float',
      maximum: 180,
      minimum: -180,
      type: 'number'
    },
    radius: {
      description: 'Radius in meters',
      examples: [20000],
      format: 'int32',
      type: 'integer'
    }
  },
  required: ['radius', 'latitude', 'longitude'],
  type: 'object'
} as const

export const $SpecimenVoucher = {
  additionalProperties: false,
  properties: {
    collection: {
      type: 'string'
    },
    vouchers: {
      items: {
        type: 'string'
      },
      type: 'array'
    }
  },
  required: ['collection', 'vouchers'],
  type: 'object'
} as const

export const $Status = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Status.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    available: {
      type: 'boolean'
    },
    has_api_key: {
      type: 'boolean'
    },
    limit: {
      format: 'int64',
      type: 'integer'
    },
    requests: {
      format: 'int64',
      type: 'integer'
    }
  },
  required: ['available', 'has_api_key', 'requests', 'limit'],
  type: 'object'
} as const

export const $Taxon = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Taxon.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    GBIF_ID: {
      examples: [2206247],
      format: 'int64',
      type: 'integer'
    },
    anchor: {
      type: 'boolean'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    children_count: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      examples: ['ASEaquaticus'],
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['id', 'code', 'anchor', 'children_count', 'meta', 'name', 'status', 'rank'],
  type: 'object'
} as const

export const $TaxonInner = {
  additionalProperties: false,
  properties: {
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['name', 'status', 'rank'],
  type: 'object'
} as const

export const $TaxonInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/TaxonInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    code: {
      examples: ['Asellus_aquaticus'],
      minLength: 4,
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    parent: {
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['parent', 'name', 'status', 'rank'],
  type: 'object'
} as const

export const $TaxonRank = {
  enum: ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species', 'Subspecies'],
  title: 'TaxonRank',
  type: 'string'
} as const

export const $TaxonStatus = {
  enum: ['Accepted', 'Unreferenced', 'Unclassified'],
  title: 'TaxonStatus',
  type: 'string'
} as const

export const $TaxonUpdate = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/TaxonUpdate.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    authorship: {
      type: ['string', 'null']
    },
    code: {
      type: 'string'
    },
    comment: {
      type: ['string', 'null']
    },
    name: {
      type: 'string'
    },
    parent: {
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank'
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus'
    }
  },
  type: 'object'
} as const

export const $TaxonWithLineage = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/TaxonWithLineage.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    GBIF_ID: {
      examples: [2206247],
      format: 'int64',
      type: 'integer'
    },
    anchor: {
      type: 'boolean'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    children: {
      items: {
        $ref: '#/components/schemas/Taxon'
      },
      type: 'array'
    },
    children_count: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      examples: ['ASEaquaticus'],
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    lineage: {
      $ref: '#/components/schemas/Lineage'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    parent: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['lineage', 'id', 'code', 'anchor', 'children_count', 'meta', 'name', 'status', 'rank'],
  type: 'object'
} as const

export const $TaxonWithParentRef = {
  additionalProperties: false,
  properties: {
    GBIF_ID: {
      examples: [2206247],
      format: 'int64',
      type: 'integer'
    },
    anchor: {
      type: 'boolean'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    children_count: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      examples: ['ASEaquaticus'],
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    parent: {
      type: 'string'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['parent', 'id', 'code', 'anchor', 'children_count', 'meta', 'name', 'status', 'rank'],
  type: 'object'
} as const

export const $TaxonWithRelatives = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/TaxonWithRelatives.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    GBIF_ID: {
      examples: [2206247],
      format: 'int64',
      type: 'integer'
    },
    anchor: {
      type: 'boolean'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    children: {
      items: {
        $ref: '#/components/schemas/Taxon'
      },
      type: 'array'
    },
    children_count: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      examples: ['ASEaquaticus'],
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    parent: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['id', 'code', 'anchor', 'children_count', 'meta', 'name', 'status', 'rank'],
  type: 'object'
} as const

export const $Taxonomy = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Taxonomy.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    GBIF_ID: {
      examples: [2206247],
      format: 'int64',
      type: 'integer'
    },
    anchor: {
      type: 'boolean'
    },
    authorship: {
      examples: ['(Linnaeus, 1758)'],
      type: 'string'
    },
    children: {
      items: {
        $ref: '#/components/schemas/Taxonomy'
      },
      type: 'array'
    },
    children_count: {
      format: 'int64',
      type: 'integer'
    },
    code: {
      examples: ['ASEaquaticus'],
      type: 'string'
    },
    comment: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    meta: {
      $ref: '#/components/schemas/Meta'
    },
    name: {
      examples: ['Asellus aquaticus'],
      type: 'string'
    },
    parent: {
      $ref: '#/components/schemas/OptionalTaxon'
    },
    rank: {
      $ref: '#/components/schemas/TaxonRank',
      examples: ['Species']
    },
    status: {
      $ref: '#/components/schemas/TaxonStatus',
      examples: ['Accepted']
    }
  },
  required: ['id', 'code', 'anchor', 'children_count', 'meta', 'name', 'status', 'rank'],
  type: 'object'
} as const

export const $URL = {
  description:
    'A URL used to generate the verification link, which can be set by the web client. Verification token will be added as a URL query parameter.',
  format: 'uri',
  type: 'string'
} as const

export const $UpdatePasswordInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/UpdatePasswordInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    new_password: {
      $ref: '#/components/schemas/PasswordInput'
    },
    password: {
      description: 'Your current password',
      type: 'string'
    }
  },
  required: ['password', 'new_password'],
  type: 'object'
} as const

export const $Updated = {
  additionalProperties: false,
  properties: {
    doi: {
      type: 'string'
    },
    label: {
      type: 'string'
    },
    type: {
      type: 'string'
    },
    updated: {
      $ref: '#/components/schemas/DateObject'
    }
  },
  type: 'object'
} as const

export const $User = {
  additionalProperties: false,
  properties: {
    email: {
      format: 'email',
      type: 'string'
    },
    email_confirmed: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    identity: {
      $ref: '#/components/schemas/PersonInner'
    },
    login: {
      type: 'string'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    }
  },
  required: ['identity', 'id', 'email', 'login', 'role', 'email_confirmed'],
  type: 'object'
} as const

export const $UserCredentials = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/UserCredentials.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    identifier: {
      type: 'string'
    },
    password: {
      type: 'string'
    }
  },
  required: ['identifier', 'password'],
  type: 'object'
} as const

export const $UserInner = {
  additionalProperties: false,
  properties: {
    email: {
      format: 'email',
      type: 'string'
    },
    email_confirmed: {
      type: 'boolean'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    login: {
      type: 'string'
    },
    role: {
      $ref: '#/components/schemas/UserRole'
    }
  },
  required: ['id', 'email', 'login', 'role', 'email_confirmed'],
  type: 'object'
} as const

export const $UserInput = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/UserInput.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    email: {
      format: 'email',
      type: 'string'
    },
    login: {
      type: 'string'
    },
    password: {
      description: 'Your new password',
      type: 'string'
    },
    password_confirmation: {
      description: 'New password confirmation',
      type: 'string'
    }
  },
  required: ['login', 'email', 'password', 'password_confirmation'],
  type: 'object'
} as const

export const $UserRole = {
  enum: ['Visitor', 'Contributor', 'Maintainer', 'Admin'],
  title: 'UserRole',
  type: 'string'
} as const

export const $UserShortIdentity = {
  additionalProperties: false,
  properties: {
    alias: {
      type: 'string'
    },
    id: {
      format: 'uuid',
      type: 'string'
    },
    login: {
      type: 'string'
    },
    name: {
      type: 'string'
    }
  },
  required: ['id', 'login', 'name', 'alias'],
  type: 'object'
} as const

export const $Works = {
  additionalProperties: false,
  properties: {
    $schema: {
      description: 'A URL to the JSON Schema for this object.',
      examples: ['/api/v1/schemas/Works.json'],
      format: 'uri',
      readOnly: true,
      type: 'string'
    },
    message: {
      $ref: '#/components/schemas/Message'
    },
    'message-type': {
      type: 'string'
    },
    'message-version': {
      type: 'string'
    },
    status: {
      type: 'string'
    }
  },
  type: 'object'
} as const
