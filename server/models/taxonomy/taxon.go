package taxonomy

import (
	"context"
	"darco/proto/models"
	"darco/proto/models/people"
	_ "embed"
	"encoding/json"
	"slices"
	"strconv"

	"github.com/edgedb/edgedb-go"
)

type TaxonInner struct {
	Name   string      `edgedb:"name" json:"name" example:"Asellus aquaticus" binding:"required,alpha"`
	Status TaxonStatus `edgedb:"status" json:"status" example:"Accepted" binding:"required"`
	Rank   TaxonRank   `edgedb:"rank" json:"rank" example:"Species" binding:"required"`
}

type TaxonInput struct {
	TaxonInner `edgedb:"$inline"`
	Parent     string                       `json:"parent" binding:"required,exist=taxonomy::Taxon.code"`                // Parent taxon code
	Code       models.OptionalInput[string] `json:"code,omitempty" example:"ASEaquaticus" binding:"omitnil,alpha,min=4"` // Autogenerated if not provided
	Authorship models.OptionalInput[string] `json:"authorship,omitempty" example:"(Linnaeus, 1758)"`
	Comment    models.OptionalInput[string] `json:"comment,omitempty" edgedb:"comment"`
}

type Taxon struct {
	ID            edgedb.UUID          `edgedb:"id" json:"id" format:"uuid" binding:"required"`
	GBIF_ID       edgedb.OptionalInt32 `edgedb:"GBIF_ID" json:"GBIF_ID,omitempty" example:"2206247" binding:"numeric"`
	Code          string               `edgedb:"code" json:"code" example:"ASEaquaticus" binding:"required"`
	TaxonInner    `edgedb:"$inline"`
	Authorship    edgedb.OptionalStr `edgedb:"authorship" json:"authorship,omitempty" example:"(Linnaeus, 1758)"`
	Anchor        bool               `edgedb:"anchor" json:"anchor"`
	ChildrenCount int64              `edgedb:"children_count" json:"children_count"`
	Comment       edgedb.OptionalStr `json:"comment,omitempty" edgedb:"comment"`
	Meta          people.Meta        `edgedb:"meta" json:"meta" binding:"required"`
}

type TaxonWithParentRef struct {
	Taxon  `edgedb:"$inline" json:",inline"`
	Parent edgedb.OptionalStr `edgedb:"parent_code" json:"parent"`
}

type Lineage struct {
	Kingdom    models.Optional[Taxon] `edgedb:"kingdom" json:"kingdom,omitempty"`
	Phylum     models.Optional[Taxon] `edgedb:"phylum" json:"phylum,omitempty"`
	Class      models.Optional[Taxon] `edgedb:"class" json:"class,omitempty"`
	Order      models.Optional[Taxon] `edgedb:"order" json:"order,omitempty"`
	Family     models.Optional[Taxon] `edgedb:"family" json:"family,omitempty"`
	Genus      models.Optional[Taxon] `edgedb:"genus" json:"genus,omitempty"`
	Species    models.Optional[Taxon] `edgedb:"species" json:"species,omitempty"`
	Subspecies models.Optional[Taxon] `edgedb:"subspecies" json:"subspecies,omitempty"`
}

type TaxonWithRelatives struct {
	Taxon    `edgedb:"$inline" json:",inline"`
	Parent   models.Optional[Taxon] `edgedb:"parent" json:"parent,omitempty"`
	Children []Taxon                `edgedb:"children" json:"children,omitempty"`
}

type TaxonWithLineage struct {
	TaxonWithRelatives `edgedb:"$inline" json:",inline"`
	Lineage            Lineage `edgedb:"$inline" json:"lineage"`
}

// Taxonomy type is a tree like representation of the taxonomy, or part of it.
type Taxonomy struct {
	Taxon    `edgedb:"$inline" json:",inline"`
	Parent   models.Optional[Taxon] `edgedb:"parent" json:"parent,omitempty"`
	Children []Taxonomy             `edgedb:"children" json:"children,omitempty"`
}

type TaxonomyQuery struct {
	Identifier string    `json:"identifier,omitempty" query:"identifier" doc:"Taxon code or UUID"`
	MaxDepth   TaxonRank `json:"max_depth" query:"max-depth"`
}

func GetTaxonomyChildren(db edgedb.Executor, parent Taxonomy) ([]Taxonomy, error) {
	var children []Taxonomy
	if parent.Code == "ROOT" {
		query := `with module taxonomy,
	select Taxon { *, meta: {*} }
	filter .rank = Rank.Kingdom
	order by .name;`
		if err := db.Query(context.Background(), query, &children); err != nil {
			return nil, err
		}
	} else {
		query := `with module taxonomy,
	select Taxon { *, meta: {*}, parent: { * } }
	filter .parent.code = <str>$0
	order by .name;`
		if err := db.Query(context.Background(), query, &children, parent.Code); err != nil {
			return nil, err
		}
	}

	for i, taxon := range children {
		descendants, err := GetTaxonomyChildren(db, taxon)
		if err != nil {
			return nil, err
		}
		(&children[i]).Children = slices.Concat(taxon.Children, descendants)
	}
	return children, nil
}

// GetTaxonomy returns a taxonomy tree or subtree,
// with a pseudo root node when querying for the full taxonomy.
func GetTaxonomy(db edgedb.Executor, q TaxonomyQuery) (*Taxonomy, error) {

	var taxonomy = Taxonomy{
		Taxon: Taxon{
			Code: "ROOT",
			TaxonInner: TaxonInner{
				Name: "ROOT",
			},
		},
	}

	if q.Identifier != "" {
		maybeUUID, _ := edgedb.ParseUUID(q.Identifier)
		query := `with module taxonomy,
			select assert_single(
				Taxon { *, meta: {*}, parent: { * } }
				filter .code = <str>$0 or .id = <uuid>$1
			);`
		if err := db.QuerySingle(context.Background(), query, &taxonomy, q.Identifier, maybeUUID); err != nil {
			return nil, err
		}
	}
	if descendants, err := GetTaxonomyChildren(db, taxonomy); err != nil {
		return nil, err
	} else {
		taxonomy.Children = descendants
	}

	return &taxonomy, nil
}

type ListFilters struct {
	Pattern  string              `json:"pattern,omitempty" query:"pattern"`
	Rank     TaxonRank           `query:"rank"`
	Status   TaxonStatus         `json:"status,omitempty" query:"status"`
	IsAnchor edgedb.OptionalBool `json:"anchors_only,omitempty" query:"anchor"`
	Parent   string              `json:"parent,omitempty" query:"parent"`
	Limit    int64               `json:"limit,omitempty" query:"limit"`
}

func ListTaxa(db edgedb.Executor, filters ListFilters) ([]TaxonWithParentRef, error) {

	var taxa = make([]TaxonWithParentRef, 0)
	var (
		order_by = ".name"
		limit    = "{}"
	)
	if filters.Pattern != "" {
		order_by = "ext::pg_trgm::word_similarity_dist(pattern, .name)"
	}
	if filters.Limit > 0 {
		limit = strconv.FormatInt(filters.Limit, 10)
	}
	query := `with module taxonomy,
				pattern := <str>$0,
				rank := <Rank>(<str>$1 if len(<str>$1) > 0 else <str>{}),
				status := <TaxonStatus>(<str>$2 if len(<str>$2) > 0 else <str>{}),
				is_anchor := <optional bool>$3,
				parent := <optional str>$4
			select Taxon { *, meta: {*}, parent_code := .parent.code }
			filter (.rank = rank if exists rank else true)
			and (.status = status if exists status else true)
			and (.anchor = is_anchor if exists is_anchor else true)
			and (.parent.code ilike parent if len(parent) > 0 else true)` +
		"order by " + order_by + " then .rank asc then .name asc " +
		"limit " + limit
	err := db.Query(context.Background(), query, &taxa,
		filters.Pattern, filters.Rank, filters.Status, filters.IsAnchor, filters.Parent)
	return taxa, err
}

func FindByID(db edgedb.Executor, id edgedb.UUID) (taxon TaxonWithLineage, err error) {
	query := `
		select taxonomy::Taxon { *,
			meta: { * },
			parent : { *, meta: { * } },
			children : { *, meta: { * } },
			kingdom: { *, meta: { * } },
			phylum: { *, meta: { * } },
			class: { *, meta: { * } },
			order: { *, meta: { * } },
			family: { *, meta: { * } },
			genus: { *, meta: { * } },
			species: { *, meta: { * } },
		}
		filter .id = <uuid>$0;
	`
	err = db.QuerySingle(context.Background(), query, &taxon, id)
	return taxon, err
}

func FindByCode(db edgedb.Executor, code string) (taxon TaxonWithLineage, err error) {
	query := `
		select taxonomy::Taxon { *,
			meta : { * },
			parent : { *, meta: { * } },
			children : { *, meta: { * } },
			kingdom: { *, meta: { * } },
			phylum: { *, meta: { * } },
			class: { *, meta: { * } },
			order: { *, meta: { * } },
			family: { *, meta: { * } },
			genus: { *, meta: { * } },
			species: { *, meta: { * } },
		}
		filter .code = <str>$0;
	`
	err = db.QuerySingle(context.Background(), query, &taxon, code)
	return taxon, err
}

func Delete(db edgedb.Executor, code string) (taxon TaxonWithRelatives, err error) {
	query := `select (
		delete taxonomy::Taxon filter .code = <str>$0
	) { *, meta: { * }, parent : { * , meta: { * }}, children : { * , meta: { * }} };`
	err = db.QuerySingle(context.Background(), query, &taxon, code)
	return
}

//go:embed queries/create_taxon.edgeql
var createTaxonCmd string

func (taxon TaxonInput) Create(db edgedb.Executor) (created TaxonWithRelatives, err error) {
	args, _ := json.Marshal(taxon)
	err = db.QuerySingle(context.Background(), createTaxonCmd, &created, args)
	return created, err
}

type TaxonUpdate struct {
	GBIF_ID    *int32       `json:"GBIF_ID,omitempty" binding:"omitnil,numeric"`
	Name       *string      `json:"name,omitempty" binding:"omitnil,alpha"`
	Code       *string      `json:"code,omitempty" binding:"omitnil,alpha"`
	Status     *TaxonStatus `json:"status,omitempty" binding:"omitnil"`
	Authorship *string      `json:"authorship,omitempty" binding:"omitnil,alphanumunicode"`
	Rank       *TaxonRank   `json:"rank,omitempty" binding:"omitnil"`
	Parent     *string      `json:"parent,omitempty" binding:"omitnil"` // parent code
}

//go:embed queries/update_taxon.edgeql
var updateTaxonCmd string

func (taxon TaxonUpdate) Update(db edgedb.Executor, code string) (uuid edgedb.UUID, err error) {
	args, _ := json.Marshal(taxon)
	err = db.QuerySingle(context.Background(), updateTaxonCmd, &uuid, code, args)
	return uuid, err
}
