package taxonomy

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"slices"
	"strconv"
	"strings"

	"github.com/lsdch/biome/db"
	"github.com/lsdch/biome/models"
	"github.com/lsdch/biome/models/people"

	"github.com/edgedb/edgedb-go"
)

// TaxonCode generates a code from a taxon name, replacing spaces with underscores.
func TaxonCode(name string) string {
	return strings.ReplaceAll(name, " ", "_")
}

func TaxonShortCode(name string) string {
	fragments := strings.Split(name, "")
	if len(fragments) > 1 {
		return string(fragments[0][0]) + "_" + strings.Join(fragments[1:], "_")
	}
	return name
}

type TaxonInner struct {
	Name   string      `edgedb:"name" json:"name" example:"Asellus aquaticus" binding:"required,alpha"`
	Status TaxonStatus `edgedb:"status" json:"status" example:"Accepted" binding:"required"`
	Rank   TaxonRank   `edgedb:"rank" json:"rank" example:"Species" binding:"required"`
}

type TaxonInput struct {
	TaxonInner `edgedb:"$inline"`
	Parent     string                       `json:"parent" binding:"required,exist=taxonomy::Taxon.code"`     // Parent taxon code
	Code       models.OptionalInput[string] `json:"code,omitempty" example:"Asellus_aquaticus" minLength:"4"` // Autogenerated if not provided
	Authorship models.OptionalInput[string] `json:"authorship,omitempty" example:"(Linnaeus, 1758)"`
	Comment    models.OptionalInput[string] `json:"comment,omitempty" edgedb:"comment"`
}

func (i *TaxonInput) UnmarshalJSON(data []byte) error {
	type innerType TaxonInput
	inner := &innerType{}
	if err := json.Unmarshal(data, inner); err != nil {
		return err
	}
	*i = TaxonInput(*inner)
	if !i.Code.HasValue() {
		i.Code.SetValue(strings.ReplaceAll(i.Name, " ", "_"))
	}
	return nil
}

type Taxon struct {
	ID            edgedb.UUID          `edgedb:"id" json:"id" format:"uuid" binding:"required"`
	GBIF_ID       edgedb.OptionalInt32 `edgedb:"GBIF_ID" json:"GBIF_ID,omitempty" example:"2206247" binding:"numeric"`
	Code          string               `edgedb:"code" json:"code" example:"ASEaquaticus" binding:"required"`
	TaxonInner    `edgedb:"$inline"`
	Authorship    edgedb.OptionalStr `edgedb:"authorship" json:"authorship,omitempty" example:"(Linnaeus, 1758)"`
	Anchor        bool               `edgedb:"anchor" json:"anchor"`
	ChildrenCount int64              `edgedb:"children_count" json:"children_count"`
	Comment       edgedb.OptionalStr `json:"comment,omitempty" edgedb:"comment"`
	Meta          people.Meta        `edgedb:"meta" json:"meta" binding:"required"`
}

type TaxonWithParentRef struct {
	Taxon  `edgedb:"$inline" json:",inline"`
	Parent edgedb.OptionalStr `edgedb:"parent_code" json:"parent"`
}

type Lineage struct {
	Kingdom    models.Optional[Taxon] `edgedb:"kingdom" json:"kingdom,omitempty"`
	Phylum     models.Optional[Taxon] `edgedb:"phylum" json:"phylum,omitempty"`
	Class      models.Optional[Taxon] `edgedb:"class" json:"class,omitempty"`
	Order      models.Optional[Taxon] `edgedb:"order" json:"order,omitempty"`
	Family     models.Optional[Taxon] `edgedb:"family" json:"family,omitempty"`
	Genus      models.Optional[Taxon] `edgedb:"genus" json:"genus,omitempty"`
	Species    models.Optional[Taxon] `edgedb:"species" json:"species,omitempty"`
	Subspecies models.Optional[Taxon] `edgedb:"subspecies" json:"subspecies,omitempty"`
}

type TaxonWithRelatives struct {
	Taxon    `edgedb:"$inline" json:",inline"`
	Parent   models.Optional[Taxon] `edgedb:"parent" json:"parent,omitempty"`
	Children []Taxon                `edgedb:"children" json:"children,omitempty"`
}

type TaxonWithLineage struct {
	TaxonWithRelatives `edgedb:"$inline" json:",inline"`
	Lineage            Lineage `edgedb:"$inline" json:"lineage"`
}

// Taxonomy type is a tree like representation of the taxonomy, or part of it.
type Taxonomy struct {
	Taxon    `edgedb:"$inline" json:",inline"`
	Parent   models.Optional[Taxon] `edgedb:"parent" json:"parent,omitempty"`
	Children []Taxonomy             `edgedb:"children" json:"children,omitempty"`
}

type TaxonomyQuery struct {
	Identifier string    `json:"identifier,omitempty" query:"identifier" doc:"Taxon code or UUID"`
	MaxDepth   TaxonRank `json:"max_depth" query:"max-depth"`
}

func GetTaxonomyChildren(db edgedb.Executor, parent Taxonomy) ([]Taxonomy, error) {
	var children []Taxonomy
	if parent.Code == "ROOT" {
		query := `#edgeql
			with module taxonomy,
			select Taxon { *, meta: {*} }
			filter .rank = Rank.Kingdom
			order by .name;
		`
		if err := db.Query(context.Background(), query, &children); err != nil {
			return nil, err
		}
	} else {
		query := `#edgeql
			with module taxonomy,
			select Taxon { *, meta: {*}, parent: { * } }
			filter .parent.code = <str>$0
			order by .name
		`
		if err := db.Query(context.Background(), query, &children, parent.Code); err != nil {
			return nil, err
		}
	}

	for i, taxon := range children {
		descendants, err := GetTaxonomyChildren(db, taxon)
		if err != nil {
			return nil, err
		}
		(&children[i]).Children = slices.Concat(taxon.Children, descendants)
	}
	return children, nil
}

// GetTaxonomy returns a taxonomy tree or subtree,
// with a pseudo root node when querying for the full taxonomy.
func GetTaxonomy(db edgedb.Executor, q TaxonomyQuery) (*Taxonomy, error) {

	var taxonomy = Taxonomy{
		Taxon: Taxon{
			Code: "ROOT",
			TaxonInner: TaxonInner{
				Name: "ROOT",
			},
		},
	}

	if q.Identifier != "" {
		maybeUUID, _ := edgedb.ParseUUID(q.Identifier)
		query := `#edgeql
			with module taxonomy,
			select assert_single(
				Taxon { *, meta: {*}, parent: { * } }
				filter .code = <str>$0 or .id = <uuid>$1
			);`
		if err := db.QuerySingle(context.Background(), query, &taxonomy, q.Identifier, maybeUUID); err != nil {
			return nil, err
		}
	}
	if descendants, err := GetTaxonomyChildren(db, taxonomy); err != nil {
		return nil, err
	} else {
		taxonomy.Children = descendants
	}

	return &taxonomy, nil
}

type ListFilters struct {
	Pattern  string              `json:"pattern,omitempty" query:"pattern"`
	Ranks    []TaxonRank         `query:"ranks"`
	Status   TaxonStatus         `json:"status,omitempty" query:"status"`
	IsAnchor edgedb.OptionalBool `json:"anchors_only,omitempty" query:"anchor"`
	Parent   string              `json:"parent,omitempty" query:"parent"`
	Limit    int64               `json:"limit,omitempty" query:"limit"`
}

func ListTaxa(db edgedb.Executor, filters ListFilters) ([]TaxonWithParentRef, error) {

	var taxa = []TaxonWithParentRef{}
	if filters.Ranks == nil {
		filters.Ranks = []TaxonRank{}
	}
	var (
		order_by = ".name"
		limit    = "{}"
	)
	if filters.Pattern != "" {
		order_by = `#edgeql
			ext::pg_trgm::word_similarity_dist(pattern, .name)
		`
	}
	if filters.Limit > 0 {
		limit = strconv.FormatInt(filters.Limit, 10)
	}
	query := `#edgeql
		with module taxonomy,
			pattern := <str>$0,
			ranks := <Rank>(array_unpack(<array<str>>$1) if len(<array<str>>$1) > 0 else <str>{}),
			status := <TaxonStatus>(<str>$2 if len(<str>$2) > 0 else <str>{}),
			is_anchor := <optional bool>$3,
			parent := <optional str>$4
		select Taxon { *, meta: {*}, parent_code := .parent.code }
		filter (.rank in ranks if exists ranks else true)
		and (.status = status if exists status else true)
		and (.anchor = is_anchor if exists is_anchor else true)
		and (.parent.code ilike parent if len(parent) > 0 else true)` +
		"order by " + order_by + " then .rank asc then .name asc " +
		"limit " + limit
	err := db.Query(context.Background(), query, &taxa,
		filters.Pattern, filters.Ranks, filters.Status, filters.IsAnchor, filters.Parent)
	return taxa, err
}

const TAXON_LINEAGE_SHAPE = `#edgeql
		{ *,
			meta: { * },
			parent : { *, meta: { * } },
			children : { *, meta: { * } },
			kingdom: { *, meta: { * } },
			phylum: { *, meta: { * } },
			class: { *, meta: { * } },
			order: { *, meta: { * } },
			family: { *, meta: { * } },
			genus: { *, meta: { * } },
			species: { *, meta: { * } },
		}`

func FindByID(db edgedb.Executor, id edgedb.UUID) (taxon TaxonWithLineage, err error) {
	query := fmt.Sprintf(
		`select taxonomy::Taxon %s filter .id = <uuid>$0;`,
		TAXON_LINEAGE_SHAPE)
	err = db.QuerySingle(context.Background(), query, &taxon, id)
	return taxon, err
}

func FindByCode(db edgedb.Executor, code string) (taxon TaxonWithLineage, err error) {
	query := fmt.Sprintf(
		`select taxonomy::Taxon %s filter .code = <str>$0;`,
		TAXON_LINEAGE_SHAPE)
	err = db.QuerySingle(context.Background(), query, &taxon, code)
	return taxon, err
}

func Delete(db edgedb.Executor, code string) (taxon TaxonWithRelatives, err error) {
	err = db.QuerySingle(context.Background(), `#edgeql
		select (
			delete taxonomy::Taxon filter .code = <str>$0
		) { *, meta: { * }, parent : { * , meta: { * }}, children : { * , meta: { * }} }
	`, &taxon, code)
	return
}

//go:embed queries/create_taxon.edgeql
var createTaxonCmd string

func (taxon TaxonInput) Save(db edgedb.Executor) (created TaxonWithRelatives, err error) {
	args, _ := json.Marshal(taxon)
	err = db.QuerySingle(context.Background(), createTaxonCmd, &created, args)
	return created, err
}

type TaxonUpdate struct {
	Name       models.OptionalInput[string]      `edgedb:"name" json:"name,omitempty"`
	Code       models.OptionalInput[string]      `edgedb:"code" json:"code,omitempty"`
	Status     models.OptionalInput[TaxonStatus] `edgedb:"status" json:"status,omitempty"`
	Authorship models.OptionalNull[string]       `edgedb:"authorship" json:"authorship,omitempty"`
	Rank       models.OptionalInput[TaxonRank]   `edgedb:"rank" json:"rank,omitempty"`
	Parent     models.OptionalInput[string]      `edgedb:"parent" json:"parent,omitempty"` // parent code
}

func (u TaxonUpdate) Save(e edgedb.Executor, code string) (updated Taxon, err error) {
	data, _ := json.Marshal(u)
	query := db.UpdateQuery{
		Frame: fmt.Sprintf(`#edgeql
			with item := <json>$1,
			select (update taxonomy::Taxon filter .code = <str>$0 set {
				%s
			}) %s`,
			"%s", TAXON_LINEAGE_SHAPE),
		Mappings: map[string]string{
			"name":       "<str>item['name']",
			"code":       "<str>item['code']",
			"status":     "<taxonomy::TaxonStatus>item['status']",
			"rank":       "<taxonomy::Rank>item['rank']",
			"authorship": "<str>item['authorship']",
			"parent": `#edgeql
				(
					select detached taxonomy::Taxon filter .code = <str>item['parent']
				)`,
		},
	}
	err = e.QuerySingle(context.Background(), query.Query(u), &updated, code, data)
	return
}
